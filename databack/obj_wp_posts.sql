/*
SQLyog Ultimate
MySQL - 5.7.20-log : Database - wordpressnew
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`wordpressnew` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `wordpressnew`;

/*Table structure for table `wp_posts` */

CREATE TABLE `wp_posts` (
  `ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `post_author` bigint(20) unsigned NOT NULL DEFAULT '0',
  `post_date` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_date_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content` longtext NOT NULL,
  `post_title` text NOT NULL,
  `post_excerpt` text NOT NULL,
  `post_status` varchar(20) NOT NULL DEFAULT 'publish',
  `comment_status` varchar(20) NOT NULL DEFAULT 'open',
  `ping_status` varchar(20) NOT NULL DEFAULT 'open',
  `post_password` varchar(20) NOT NULL DEFAULT '',
  `post_name` varchar(200) NOT NULL DEFAULT '',
  `to_ping` text NOT NULL,
  `pinged` text NOT NULL,
  `post_modified` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_modified_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content_filtered` longtext NOT NULL,
  `post_parent` bigint(20) unsigned NOT NULL DEFAULT '0',
  `guid` varchar(255) NOT NULL DEFAULT '',
  `menu_order` int(11) NOT NULL DEFAULT '0',
  `post_type` varchar(20) NOT NULL DEFAULT 'post',
  `post_mime_type` varchar(100) NOT NULL DEFAULT '',
  `comment_count` bigint(20) NOT NULL DEFAULT '0',
  PRIMARY KEY (`ID`),
  KEY `post_name` (`post_name`),
  KEY `type_status_date` (`post_type`,`post_status`,`post_date`,`ID`),
  KEY `post_parent` (`post_parent`),
  KEY `post_author` (`post_author`)
) ENGINE=InnoDB AUTO_INCREMENT=238 DEFAULT CHARSET=utf8;

/*Data for the table `wp_posts` */

insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (9,1,'2013-08-15 13:24:54','2013-08-15 05:24:54','在实例化子类时 首先会调用父类的构造器（如果有的话），如果父类的属性是私有的话 子类是无法继承的只能通过public get方法来获取属性 还有一个陷阱就是 如果子类与父类某个方法名是一样的话如果要在子类里调用父类的方法 那么需要添加super.method() 。 通过super关键字来调用父类的方法','java 继承 note','','publish','open','open','','java-%e7%bb%a7%e6%89%bf-note','','','2013-08-15 13:24:54','2013-08-15 05:24:54','',0,'http://localhost/wordpress-new/?p=9',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (10,1,'2013-08-15 13:24:54','2013-08-15 05:24:54','在实例化子类时 首先会调用父类的构造器（如果有的话），如果父类的属性是私有的话 子类是无法继承的只能通过public get方法来获取属性 还有一个陷阱就是 如果子类与父类某个方法名是一样的话如果要在子类里调用父类的方法 那么需要添加super.method() 。 通过super关键字来调用父类的方法','java 继承 note','','inherit','open','open','','9-revision-v1','','','2013-08-15 13:24:54','2013-08-15 05:24:54','',9,'http://localhost/wordpress-new/?p=10',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (11,1,'2013-08-15 13:26:23','2013-08-15 05:26:23','在java里要使用线程 需要实现 接口 Runnable 并实现其定义的方法run  通过 Thread t = new Thread(实现接口的实例)  来创建一个线程 并通过 t.start(); 来启动线程 线程是非常有意思的功能哟 要知道更多关于线程的东西 就去看corejava 第1卷第14章 比如 牵涉到 资源访问的 同步 以及锁等问题','java 线程','','publish','open','open','','java-%e7%ba%bf%e7%a8%8b','','','2013-08-15 13:26:23','2013-08-15 05:26:23','',0,'http://localhost/wordpress-new/?p=11',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (12,1,'2013-08-15 13:26:23','2013-08-15 05:26:23','在java里要使用线程 需要实现 接口 Runnable 并实现其定义的方法run  通过 Thread t = new Thread(实现接口的实例)  来创建一个线程 并通过 t.start(); 来启动线程 线程是非常有意思的功能哟 要知道更多关于线程的东西 就去看corejava 第1卷第14章 比如 牵涉到 资源访问的 同步 以及锁等问题','java 线程','','inherit','open','open','','11-revision-v1','','','2013-08-15 13:26:23','2013-08-15 05:26:23','',11,'http://localhost/wordpress-new/?p=12',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (14,1,'2013-08-23 13:36:13','2013-08-23 05:36:13','rpc、soap与rmi调用的区别:\r\n\r\n传输协议的区别：\r\n\r\n<strong>RMI</strong>目前使用Java远程消息交换协议JRMP（Java Remote Messaging Protocol）进行通信，但由于JRMP是专为Java对象制定的，因此，RMI对于用非Java语言开发的应用系统的支持不足。不能与用非Java语言书写的对象进行通信。\r\n\r\n<strong>xml-rpc</strong> 这种远程过程调用使用http作为传输协议，XML作为传送信息的编码格式。Xml-Rpc的定义尽可能的保持了简单，但同时能够传送、处理、返回复杂的数据结构。SOAP 可以看成是xml-rpc 升级版\r\n\r\n<strong>IIOP</strong>，Internet Inter-ORB Protocol(互联网内部对象请求代理协议)，它是一个用于CORBA 2.0及兼容平台上的协议。用来在CORBA对象请求代理之间交流的协议。Java中使得程序可以和其他语言的CORBA实现实现互操作性的协议。\r\n\r\n<strong>RMI-IIOP</strong>出现以前，只有RMI和CORBA两种选择来进行分布式程序设计，二者之间不能协作。RMI-IIOP综合了RMI 和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。','RPC RMI SOAP CORBA','','publish','open','open','','rpc-rmi-soap-corba','','','2013-08-23 13:36:13','2013-08-23 05:36:13','',0,'http://localhost/wordpress-new/?p=14',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (15,1,'2013-08-23 13:36:13','2013-08-23 05:36:13','rpc、soap与rmi调用的区别:\r\n\r\n传输协议的区别：\r\n\r\n<strong>RMI</strong>目前使用Java远程消息交换协议JRMP（Java Remote Messaging Protocol）进行通信，但由于JRMP是专为Java对象制定的，因此，RMI对于用非Java语言开发的应用系统的支持不足。不能与用非Java语言书写的对象进行通信。\r\n\r\n<strong>xml-rpc</strong> 这种远程过程调用使用http作为传输协议，XML作为传送信息的编码格式。Xml-Rpc的定义尽可能的保持了简单，但同时能够传送、处理、返回复杂的数据结构。SOAP 可以看成是xml-rpc 升级版\r\n\r\n<strong>IIOP</strong>，Internet Inter-ORB Protocol(互联网内部对象请求代理协议)，它是一个用于CORBA 2.0及兼容平台上的协议。用来在CORBA对象请求代理之间交流的协议。Java中使得程序可以和其他语言的CORBA实现实现互操作性的协议。\r\n\r\n<strong>RMI-IIOP</strong>出现以前，只有RMI和CORBA两种选择来进行分布式程序设计，二者之间不能协作。RMI-IIOP综合了RMI 和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。','RPC RMI SOAP CORBA','','inherit','open','open','','14-revision-v1','','','2013-08-23 13:36:13','2013-08-23 05:36:13','',14,'http://localhost/wordpress-new/?p=15',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (16,1,'2013-08-23 13:37:12','2013-08-23 05:37:12','对于需要序列化的类 必须实现Serializable 接口  下面的代码实现了 如何实现对象流输出到文本 （Java里的远程调用 以及J2EE里的EJB等应用都是基于对象流来处理的）\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\nclass ObjectStreamTest\r\n{\r\npublic static void main(String[] args)\r\n{\r\nEmployee harry = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1);\r\nManager carl = new Manager(\"Carl Cracker\", 80000, 1987, 12, 15);\r\ncarl.setSecretary(harry);\r\nManager tony = new Manager(\"Tony Tester\", 40000, 1990, 3, 15);\r\ntony.setSecretary(harry);\r\n\r\nEmployee[] staff = new Employee[3];\r\n\r\nstaff[0] = carl;\r\nstaff[1] = harry;\r\nstaff[2] = tony;\r\n\r\ntry\r\n{\r\n// save all employee records to the file employee.dat\r\nObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.dat\"));\r\nout.writeObject(staff);//序列化\r\nout.close();\r\n\r\n// retrieve all records into a new array\r\nObjectInputStream in = new ObjectInputStream(new FileInputStream(\"employee.dat\"));\r\nEmployee[] newStaff = (Employee[]) in.readObject();//反序列化\r\nin.close();\r\n\r\n// raise secretary\'s salary\r\nnewStaff[1].raiseSalary(10);\r\n\r\n// print the newly read employee records\r\nfor (Employee e : newStaff)\r\nSystem.out.println(e);\r\n}\r\ncatch (Exception e)\r\n{\r\ne.printStackTrace();\r\n}\r\n}\r\n}\r\n\r\nclass Employee implements Serializable\r\n{\r\npublic Employee()\r\n{\r\n}\r\n\r\npublic Employee(String n, double s, int year, int month, int day)\r\n{\r\nname = n;\r\nsalary = s;\r\nGregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);\r\nhireDay = calendar.getTime();\r\n}\r\n\r\npublic String getName()\r\n{\r\nreturn name;\r\n}\r\n\r\npublic double getSalary()\r\n{\r\nreturn salary;\r\n}\r\n\r\npublic Date getHireDay()\r\n{\r\nreturn hireDay;\r\n}\r\n\r\npublic void raiseSalary(double byPercent)\r\n{\r\ndouble raise = salary * byPercent / 100;\r\nsalary += raise;\r\n}\r\n\r\npublic String toString()\r\n{\r\nreturn getClass().getName() + \"[name=\" + name + \",salary=\" + salary + \",hireDay=\" + hireDay\r\n+ \"]\";\r\n}\r\n\r\nprivate String name;\r\nprivate double salary;\r\nprivate Date hireDay;\r\n}\r\n\r\nclass Manager extends Employee\r\n{\r\npublic Manager(String n, double s, int year, int month, int day)\r\n{\r\nsuper(n, s, year, month, day);\r\nsecretary = null;\r\n}\r\npublic void setSecretary(Employee s)\r\n{\r\nsecretary = s;\r\n}\r\n\r\npublic String toString()\r\n{\r\nreturn super.toString() + \"[secretary=\" + secretary + \"]\";\r\n}\r\n\r\nprivate Employee secretary;\r\n}','java 序列化 对象流','','publish','open','open','','java-%e5%ba%8f%e5%88%97%e5%8c%96-%e5%af%b9%e8%b1%a1%e6%b5%81','','','2013-08-23 13:37:12','2013-08-23 05:37:12','',0,'http://localhost/wordpress-new/?p=16',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (17,1,'2013-08-23 13:37:12','2013-08-23 05:37:12','对于需要序列化的类 必须实现Serializable 接口  下面的代码实现了 如何实现对象流输出到文本 （Java里的远程调用 以及J2EE里的EJB等应用都是基于对象流来处理的）\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\nclass ObjectStreamTest\r\n{\r\npublic static void main(String[] args)\r\n{\r\nEmployee harry = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1);\r\nManager carl = new Manager(\"Carl Cracker\", 80000, 1987, 12, 15);\r\ncarl.setSecretary(harry);\r\nManager tony = new Manager(\"Tony Tester\", 40000, 1990, 3, 15);\r\ntony.setSecretary(harry);\r\n\r\nEmployee[] staff = new Employee[3];\r\n\r\nstaff[0] = carl;\r\nstaff[1] = harry;\r\nstaff[2] = tony;\r\n\r\ntry\r\n{\r\n// save all employee records to the file employee.dat\r\nObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.dat\"));\r\nout.writeObject(staff);//序列化\r\nout.close();\r\n\r\n// retrieve all records into a new array\r\nObjectInputStream in = new ObjectInputStream(new FileInputStream(\"employee.dat\"));\r\nEmployee[] newStaff = (Employee[]) in.readObject();//反序列化\r\nin.close();\r\n\r\n// raise secretary\'s salary\r\nnewStaff[1].raiseSalary(10);\r\n\r\n// print the newly read employee records\r\nfor (Employee e : newStaff)\r\nSystem.out.println(e);\r\n}\r\ncatch (Exception e)\r\n{\r\ne.printStackTrace();\r\n}\r\n}\r\n}\r\n\r\nclass Employee implements Serializable\r\n{\r\npublic Employee()\r\n{\r\n}\r\n\r\npublic Employee(String n, double s, int year, int month, int day)\r\n{\r\nname = n;\r\nsalary = s;\r\nGregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);\r\nhireDay = calendar.getTime();\r\n}\r\n\r\npublic String getName()\r\n{\r\nreturn name;\r\n}\r\n\r\npublic double getSalary()\r\n{\r\nreturn salary;\r\n}\r\n\r\npublic Date getHireDay()\r\n{\r\nreturn hireDay;\r\n}\r\n\r\npublic void raiseSalary(double byPercent)\r\n{\r\ndouble raise = salary * byPercent / 100;\r\nsalary += raise;\r\n}\r\n\r\npublic String toString()\r\n{\r\nreturn getClass().getName() + \"[name=\" + name + \",salary=\" + salary + \",hireDay=\" + hireDay\r\n+ \"]\";\r\n}\r\n\r\nprivate String name;\r\nprivate double salary;\r\nprivate Date hireDay;\r\n}\r\n\r\nclass Manager extends Employee\r\n{\r\npublic Manager(String n, double s, int year, int month, int day)\r\n{\r\nsuper(n, s, year, month, day);\r\nsecretary = null;\r\n}\r\npublic void setSecretary(Employee s)\r\n{\r\nsecretary = s;\r\n}\r\n\r\npublic String toString()\r\n{\r\nreturn super.toString() + \"[secretary=\" + secretary + \"]\";\r\n}\r\n\r\nprivate Employee secretary;\r\n}','java 序列化 对象流','','inherit','open','open','','16-revision-v1','','','2013-08-23 13:37:12','2013-08-23 05:37:12','',16,'http://localhost/wordpress-new/?p=17',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (18,1,'2013-08-23 13:37:46','2013-08-23 05:37:46','下面的代码显示了普通流与缓冲流以及内存映射机制对文件操作的性能测试 根据测试缓冲流与内存映射能提高文件的解析性能(大文件&gt;5m) 并且很大    import java.io.*;\r\nimport java.nio.*;\r\nimport java.nio.channels.*;\r\nimport java.util.zip.*;\r\npublic class NIOTest\r\n{\r\npublic static long checksumInputStream(String filename) throws IOException\r\n{\r\nInputStream in = new FileInputStream(filename);\r\nCRC32 crc = new CRC32();\r\n\r\nint c;\r\nwhile ((c = in.read()) != -1)\r\ncrc.update(c);\r\nreturn crc.getValue();\r\n}\r\n\r\npublic static long checksumBufferedInputStream(String filename) throws IOException\r\n{\r\nInputStream in = new BufferedInputStream(new FileInputStream(filename));\r\nCRC32 crc = new CRC32();\r\n\r\nint c;\r\nwhile ((c = in.read()) != -1)\r\ncrc.update(c);\r\nreturn crc.getValue();\r\n}\r\n\r\npublic static long checksumRandomAccessFile(String filename) throws IOException\r\n{\r\nRandomAccessFile file = new RandomAccessFile(filename, \"r\");\r\nlong length = file.length();\r\nCRC32 crc = new CRC32();\r\n\r\nfor (long p = 0; p &lt; length; p++)\r\n{\r\nfile.seek(p);\r\nint c = file.readByte();\r\ncrc.update(c);\r\n}\r\nreturn crc.getValue();\r\n}\r\n\r\npublic static long checksumMappedFile(String filename) throws IOException\r\n{\r\nFileInputStream in = new FileInputStream(filename);\r\nFileChannel channel = in.getChannel();\r\n\r\nCRC32 crc = new CRC32();\r\nint length = (int) channel.size();\r\nMappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, length);\r\n\r\nfor (int p = 0; p &lt; length; p++)\r\n{\r\nint c = buffer.get(p);\r\ncrc.update(c);\r\n}\r\nreturn crc.getValue();\r\n}\r\n\r\npublic static void main(String[] args) throws IOException\r\n{\r\nSystem.out.println(\"Input Stream:\");\r\nlong start = System.currentTimeMillis();\r\nlong crcValue = checksumInputStream(\"d:\\\\1.txt\");\r\nlong end = System.currentTimeMillis();\r\nSystem.out.println(Long.toHexString(crcValue));\r\nSystem.out.println((end - start) + \" milliseconds\");\r\n\r\nSystem.out.println(\"Buffered Input Stream:\");\r\nstart = System.currentTimeMillis();\r\ncrcValue = checksumBufferedInputStream(\"d:\\\\1.txt\");\r\nend = System.currentTimeMillis();\r\nSystem.out.println(Long.toHexString(crcValue));\r\nSystem.out.println((end - start) + \" milliseconds\");\r\n\r\nSystem.out.println(\"Random Access File:\");\r\nstart = System.currentTimeMillis();\r\ncrcValue = checksumRandomAccessFile(\"d:\\\\1.txt\");\r\nend = System.currentTimeMillis();\r\nSystem.out.println(Long.toHexString(crcValue));\r\nSystem.out.println((end - start) + \" milliseconds\");\r\n\r\nSystem.out.println(\"Mapped File:\");\r\nstart = System.currentTimeMillis();\r\ncrcValue = checksumMappedFile(\"d:\\\\1.txt\");\r\nend = System.currentTimeMillis();\r\nSystem.out.println(Long.toHexString(crcValue));\r\nSystem.out.println((end - start) + \" milliseconds\");\r\n}\r\n}','java 缓冲流 内存映射文件','','publish','open','open','','java-%e7%bc%93%e5%86%b2%e6%b5%81-%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6','','','2013-08-23 13:37:46','2013-08-23 05:37:46','',0,'http://localhost/wordpress-new/?p=18',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (19,1,'2013-08-23 13:37:46','2013-08-23 05:37:46','下面的代码显示了普通流与缓冲流以及内存映射机制对文件操作的性能测试 根据测试缓冲流与内存映射能提高文件的解析性能(大文件&gt;5m) 并且很大    import java.io.*;\r\nimport java.nio.*;\r\nimport java.nio.channels.*;\r\nimport java.util.zip.*;\r\npublic class NIOTest\r\n{\r\npublic static long checksumInputStream(String filename) throws IOException\r\n{\r\nInputStream in = new FileInputStream(filename);\r\nCRC32 crc = new CRC32();\r\n\r\nint c;\r\nwhile ((c = in.read()) != -1)\r\ncrc.update(c);\r\nreturn crc.getValue();\r\n}\r\n\r\npublic static long checksumBufferedInputStream(String filename) throws IOException\r\n{\r\nInputStream in = new BufferedInputStream(new FileInputStream(filename));\r\nCRC32 crc = new CRC32();\r\n\r\nint c;\r\nwhile ((c = in.read()) != -1)\r\ncrc.update(c);\r\nreturn crc.getValue();\r\n}\r\n\r\npublic static long checksumRandomAccessFile(String filename) throws IOException\r\n{\r\nRandomAccessFile file = new RandomAccessFile(filename, \"r\");\r\nlong length = file.length();\r\nCRC32 crc = new CRC32();\r\n\r\nfor (long p = 0; p &lt; length; p++)\r\n{\r\nfile.seek(p);\r\nint c = file.readByte();\r\ncrc.update(c);\r\n}\r\nreturn crc.getValue();\r\n}\r\n\r\npublic static long checksumMappedFile(String filename) throws IOException\r\n{\r\nFileInputStream in = new FileInputStream(filename);\r\nFileChannel channel = in.getChannel();\r\n\r\nCRC32 crc = new CRC32();\r\nint length = (int) channel.size();\r\nMappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, length);\r\n\r\nfor (int p = 0; p &lt; length; p++)\r\n{\r\nint c = buffer.get(p);\r\ncrc.update(c);\r\n}\r\nreturn crc.getValue();\r\n}\r\n\r\npublic static void main(String[] args) throws IOException\r\n{\r\nSystem.out.println(\"Input Stream:\");\r\nlong start = System.currentTimeMillis();\r\nlong crcValue = checksumInputStream(\"d:\\\\1.txt\");\r\nlong end = System.currentTimeMillis();\r\nSystem.out.println(Long.toHexString(crcValue));\r\nSystem.out.println((end - start) + \" milliseconds\");\r\n\r\nSystem.out.println(\"Buffered Input Stream:\");\r\nstart = System.currentTimeMillis();\r\ncrcValue = checksumBufferedInputStream(\"d:\\\\1.txt\");\r\nend = System.currentTimeMillis();\r\nSystem.out.println(Long.toHexString(crcValue));\r\nSystem.out.println((end - start) + \" milliseconds\");\r\n\r\nSystem.out.println(\"Random Access File:\");\r\nstart = System.currentTimeMillis();\r\ncrcValue = checksumRandomAccessFile(\"d:\\\\1.txt\");\r\nend = System.currentTimeMillis();\r\nSystem.out.println(Long.toHexString(crcValue));\r\nSystem.out.println((end - start) + \" milliseconds\");\r\n\r\nSystem.out.println(\"Mapped File:\");\r\nstart = System.currentTimeMillis();\r\ncrcValue = checksumMappedFile(\"d:\\\\1.txt\");\r\nend = System.currentTimeMillis();\r\nSystem.out.println(Long.toHexString(crcValue));\r\nSystem.out.println((end - start) + \" milliseconds\");\r\n}\r\n}','java 缓冲流 内存映射文件','','inherit','open','open','','18-revision-v1','','','2013-08-23 13:37:46','2013-08-23 05:37:46','',18,'http://localhost/wordpress-new/?p=19',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (20,1,'2013-08-23 13:38:29','2013-08-23 05:38:29','java本身提供了 DOM,SAX 解析器 DOM更适合比较小的xml文档 对于比较大的文档且如果不需要了解整个xml文档结构的话非常适用 且DOM占用的内存很大 而XPATH提供了更为精细的访问节点的方法并且提供了 很多有用的函数比如 计算节点的个数函数 count，abs，floor等等 XPATH的访问更像是路径的访问一样 如 /bookstore/book/title  这将得到 所有路径下的title节点 它返回一个节点的集合  当然对于xml解析很多第3方包提供了支持 如 jdom dom4j等等\r\n\r\nXSLT则提供了对xml的转换功能他可以 把xml转换成文本 html 或其他xml 格式 比较常用的就是 通过 XSLT把一个记录了一些书籍的销售信息 转换到 web页面 并添加css样式输出','java DOM SAX XPATH XSLT','','publish','open','open','','java-dom-sax-xpath-xslt','','','2013-08-23 13:38:29','2013-08-23 05:38:29','',0,'http://localhost/wordpress-new/?p=20',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (21,1,'2013-08-23 13:38:29','2013-08-23 05:38:29','java本身提供了 DOM,SAX 解析器 DOM更适合比较小的xml文档 对于比较大的文档且如果不需要了解整个xml文档结构的话非常适用 且DOM占用的内存很大 而XPATH提供了更为精细的访问节点的方法并且提供了 很多有用的函数比如 计算节点的个数函数 count，abs，floor等等 XPATH的访问更像是路径的访问一样 如 /bookstore/book/title  这将得到 所有路径下的title节点 它返回一个节点的集合  当然对于xml解析很多第3方包提供了支持 如 jdom dom4j等等\r\n\r\nXSLT则提供了对xml的转换功能他可以 把xml转换成文本 html 或其他xml 格式 比较常用的就是 通过 XSLT把一个记录了一些书籍的销售信息 转换到 web页面 并添加css样式输出','java DOM SAX XPATH XSLT','','inherit','open','open','','20-revision-v1','','','2013-08-23 13:38:29','2013-08-23 05:38:29','',20,'http://localhost/wordpress-new/?p=21',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (22,1,'2013-08-23 13:39:35','2013-08-23 05:39:35','socket本身是非线程的 需要与线程thread结合 才能实现多客户端 同时连接服务器 但只提供线程的方式 并不能实现 更高的性能  如果要提供性能 需要结合 java.nio里的新的特性 socket也是基于输入输出流 来处理的 对于客户端来说 需要提供服务器的 host/ip 以及端口 port  来访问服务器 通过建立 Socket s = new Socket(host,port); 创建一个到服务器的连接。并产生一个到服务器的 输入流InputStream  服务器获取从客户端来的输入流 并提供在需要时的输出流 把需要提供的信息或数据通过 输出流 OutputStream  输出到客户端\r\n\r\n在服务器端 我们需要创建一个 监听的进程 来接受客户端的 请求 如\r\n\r\nServerSocket s = new ServerSocket(8189); 8189 是端口号\r\n\r\nSocket incoming = s.accept(); //这里设置监听器 对所有来自客户端的连接 创建一个socket 通过输入输出流 就可以与客户端进行通信了 在实际的开发中为了 能同时让多个客户端同时访问服务器 则需要 将监听器 设置为 线程\r\n\r\n通过socket 访问服务器 根据同一个host 但不同的port端口号可以获得不同的服务 如80是http服务 25是邮件服务当然是默认情况 并都可以通过输入输出流来获得响应信息\r\n\r\n这里需要讲到 URL与URI的区别\r\n\r\nURI只能用于解析标识他不能获得任何资源 而 URL则可以访问任何一个流比如常用的http，https，ftp。java网络API提供了很多用于编写请求服务器的API如URL，URLConnection 等等具体的实现细节 可以参考corejava第2卷第3章网络编程。需要注意的是在编写访问http服务的时候对于发送的请求数据需要进行URLEncoder转换并且如果是POST提交的请求 需要设置名-值的对应参数 参数值需要进行URLEncoder编码 。注意这里与邮件服务进行身份验证提供的编码方式是不同的 邮件服务器提供的是Base64Encoder(加密数据) 更多的关于编码的细节可以参看相关文档 如 ASCII UTF-8 Base64等','java socket','','publish','open','open','','java-socket','','','2013-08-23 13:39:35','2013-08-23 05:39:35','',0,'http://localhost/wordpress-new/?p=22',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (24,1,'2013-08-23 13:39:35','2013-08-23 05:39:35','socket本身是非线程的 需要与线程thread结合 才能实现多客户端 同时连接服务器 但只提供线程的方式 并不能实现 更高的性能  如果要提供性能 需要结合 java.nio里的新的特性 socket也是基于输入输出流 来处理的 对于客户端来说 需要提供服务器的 host/ip 以及端口 port  来访问服务器 通过建立 Socket s = new Socket(host,port); 创建一个到服务器的连接。并产生一个到服务器的 输入流InputStream  服务器获取从客户端来的输入流 并提供在需要时的输出流 把需要提供的信息或数据通过 输出流 OutputStream  输出到客户端\r\n\r\n在服务器端 我们需要创建一个 监听的进程 来接受客户端的 请求 如\r\n\r\nServerSocket s = new ServerSocket(8189); 8189 是端口号\r\n\r\nSocket incoming = s.accept(); //这里设置监听器 对所有来自客户端的连接 创建一个socket 通过输入输出流 就可以与客户端进行通信了 在实际的开发中为了 能同时让多个客户端同时访问服务器 则需要 将监听器 设置为 线程\r\n\r\n通过socket 访问服务器 根据同一个host 但不同的port端口号可以获得不同的服务 如80是http服务 25是邮件服务当然是默认情况 并都可以通过输入输出流来获得响应信息\r\n\r\n这里需要讲到 URL与URI的区别\r\n\r\nURI只能用于解析标识他不能获得任何资源 而 URL则可以访问任何一个流比如常用的http，https，ftp。java网络API提供了很多用于编写请求服务器的API如URL，URLConnection 等等具体的实现细节 可以参考corejava第2卷第3章网络编程。需要注意的是在编写访问http服务的时候对于发送的请求数据需要进行URLEncoder转换并且如果是POST提交的请求 需要设置名-值的对应参数 参数值需要进行URLEncoder编码 。注意这里与邮件服务进行身份验证提供的编码方式是不同的 邮件服务器提供的是Base64Encoder(加密数据) 更多的关于编码的细节可以参看相关文档 如 ASCII UTF-8 Base64等','java socket','','inherit','open','open','','22-revision-v1','','','2013-08-23 13:39:35','2013-08-23 05:39:35','',22,'http://localhost/wordpress-new/?p=24',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (25,1,'2013-08-23 13:40:06','2013-08-23 05:40:06','在这之前我们需要讲一点就是Telnet(远程登录)协议 Telnet客户端用来与telnet服务器进行通信。很多通信方式如 email，web通信等等方式他们都是使用类似于Telnet一样的连接。因此 你可以使用Telnet 来访问email服务器并在shell命令里输入同样的命令一样可以发送email邮件比如你可以在windows下打开cmd输入 telnet ipaddress:25 可以连接上email的服务器并根据email协议 输入相应的指令就可以发送邮件。下面是一个具体的实例。这里给出一个发送E-mail的程序列子 。为了发送email必须建立一个到一个创建了SMTP服务的服务器连接默认端口号是 25 SMTP即 简单邮件传输协议 SMTP服务器可以接受来自任何人发送的email 但是在垃圾邮件等以及安全问题下 很多服务器都提供了 验证或检测功能。\r\n\r\n下面的程序实现了通过 smtp.qq.com 的smtp服务器发送一封邮件到gmail。首先你得需要一个QQ邮箱。我们采用的是网络上免费SMTP服务器 因此 不需要在本地搭建一个SMTP服务器。\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.io.PrintWriter;\r\nimport java.net.InetAddress;\r\nimport java.net.Socket;\r\nimport java.util.Scanner;\r\nimport sun.misc.BASE64Encoder;\r\n\r\npublic class AAA {\r\npublic static void main(String[] args)\r\n{\r\ntry\r\n{\r\nSocket s = new Socket(\"smtp.qq.com\", 25);\r\nInputStream inStream = s.getInputStream();\r\nOutputStream outStream = s.getOutputStream();\r\nScanner in = new Scanner(inStream);\r\nPrintWriter out = new PrintWriter(outStream, true /* autoFlush */);\r\nString hostName = InetAddress.getLocalHost().getHostName();\r\nreceive(in);\r\nsend(\"HELO \" + hostName,out);//发送mail命令\r\nreceive(in);\r\nsend(\"AUTH LOGIN\",out); //请求验证 命令\r\nreceive(in);\r\nBASE64Encoder encode=new BASE64Encoder();\r\nsend(encode.encode(\"33836858@qq.com\".getBytes()),out);//发送以base64加密的用户名\r\nSystem.out.println(encode.encode(\"33836858@qq.com\".getBytes()));\r\nreceive(in);\r\nsend(encode.encode(\"gigi117\".getBytes()),out);//发送以base64加密的密码\r\nSystem.out.println(encode.encode(\"gigi117\".getBytes()));\r\nreceive(in);\r\nsend(\"MAIL FROM: &lt;\" +\"33836858@qq.com\" + \"&gt;\",out);//本地地址\r\nreceive(in);\r\nsend(\"RCPT TO: &lt;\" + \"harlemnight.jeff@gmail.com\" + \"&gt;\",out);//发送地址\r\nreceive(in);\r\nsend(\"DATA\",out);//设置数据 命令\r\nreceive(in);\r\nsend(\"From: 33836858@qq.com\",out);//发送人\r\nsend(\"To: harlemnight.jeff@gmail.com\",out);//接收人\r\nsend(\"Subject: test mail\",out);//邮件标题\r\nsend(\"Hi,奈奈德熊 is so greate \",out);//主体\r\nsend(\".\",out);\r\nreceive(in);\r\nsend(\"QUIT\",out);//退出\r\nreceive(in);\r\ns.close();\r\n}\r\ncatch (IOException e)\r\n{\r\nSystem.out.println(e);\r\n}\r\n}\r\n\r\npublic static void send(String s,PrintWriter out) throws IOException\r\n{\r\nout.print(s.replaceAll(\"\\n\", \"\\r\\n\"));\r\nout.print(\"\\r\\n\");///注意 每一行 需要\\r\\n结尾 这是标准详细请看email规范\r\nout.flush();\r\n}\r\n\r\npublic static void receive(Scanner in) throws IOException\r\n{\r\nString line = in.nextLine();\r\nSystem.out.println(line);\r\n}\r\n}\r\n\r\n------这里是服务器的响应信息\r\n\r\n220 smtp.qq.com Esmtp QQ Mail Server  //连接成功    成功代码220/返回信息\r\n\r\nEsmtp表示需要提供验证信息 注册的用户名和密码\r\n250 smtp.qq.com\r\n334 VXNlcm5hbWU6         //用户名成功 返回信息\r\nMzM4MzY4NThAcXEuY29t\r\n334 UGFzc3dvcmQ6      //密码成功返回信息\r\nZ2lnaTExNw==\r\n235 Authentication successful    //验证成功返回信息\r\n250 Ok\r\n250 Ok\r\n354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;\r\n250 Ok: queued as\r\n221 Bye\r\n\r\n几秒后 你可以在harlemnight.jeff@gmail.com邮箱里收到来自33836858@qq.com的邮件\r\n\r\n-----------------------java mail 是由sun提供了一套API用于简化 mail  Java Mail API封装了网络协议的实现细节不需要像上面一样发送命令 该类实现了 邮件协议，认证，以及附件处理等等下面是采用javamail 获取QQ.com邮件的 一段代码\r\n\r\nString popServer=\"pop.qq.com\"; //邮件服务器 邮件服务器查看官方提供的信息\r\nString popUser=\"33836858\"; //根据自已的用户名修改\r\nString popPassword=\"gigi117\"; //根据自已的密码修改\r\nreceive(popServer, popUser, popPassword);\r\n\r\nreceive(String popServer, String popUser, String popPassword){\r\nStore store=null;\r\nFolder folder=null;\r\ntry{\r\nProperties props = System.getProperties();\r\nSession session = Session.getDefaultInstance(props, null);\r\nstore = session.getStore(\"pop3\");//pop3协议与邮件服务器提供的对应服务协议要匹配\r\nstore.connect(popServer, popUser, popPassword);\r\nSystem.out.println(store.isConnected());//连接成功  println   true\r\nfolder = store.getDefaultFolder();\r\nif (folder == null) throw new Exception(\"No default folder\");\r\nfolder = folder.getFolder(\"INBOX\");//获取收件箱目录\r\nif (folder == null) throw new Exception(\"No POP3 INBOX\");\r\nfolder.open(Folder.READ_ONLY);//只读方式打开目录\r\nMessage[] msgs = folder.getMessages();\r\nfor (int msgNum = 0; msgNum &lt; msgs.length; msgNum++){\r\n/*这里 你可以获取你所想要的 邮件信息 */\r\n\r\n}\r\n}catch (Exception ex){\r\nex.printStackTrace();\r\n}\r\n}\r\n\r\n&nbsp;','java mail','','publish','open','open','','java-mail','','','2013-08-23 13:40:06','2013-08-23 05:40:06','',0,'http://localhost/wordpress-new/?p=25',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (26,1,'2013-08-23 13:40:06','2013-08-23 05:40:06','在这之前我们需要讲一点就是Telnet(远程登录)协议 Telnet客户端用来与telnet服务器进行通信。很多通信方式如 email，web通信等等方式他们都是使用类似于Telnet一样的连接。因此 你可以使用Telnet 来访问email服务器并在shell命令里输入同样的命令一样可以发送email邮件比如你可以在windows下打开cmd输入 telnet ipaddress:25 可以连接上email的服务器并根据email协议 输入相应的指令就可以发送邮件。下面是一个具体的实例。这里给出一个发送E-mail的程序列子 。为了发送email必须建立一个到一个创建了SMTP服务的服务器连接默认端口号是 25 SMTP即 简单邮件传输协议 SMTP服务器可以接受来自任何人发送的email 但是在垃圾邮件等以及安全问题下 很多服务器都提供了 验证或检测功能。\r\n\r\n下面的程序实现了通过 smtp.qq.com 的smtp服务器发送一封邮件到gmail。首先你得需要一个QQ邮箱。我们采用的是网络上免费SMTP服务器 因此 不需要在本地搭建一个SMTP服务器。\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.io.PrintWriter;\r\nimport java.net.InetAddress;\r\nimport java.net.Socket;\r\nimport java.util.Scanner;\r\nimport sun.misc.BASE64Encoder;\r\n\r\npublic class AAA {\r\npublic static void main(String[] args)\r\n{\r\ntry\r\n{\r\nSocket s = new Socket(\"smtp.qq.com\", 25);\r\nInputStream inStream = s.getInputStream();\r\nOutputStream outStream = s.getOutputStream();\r\nScanner in = new Scanner(inStream);\r\nPrintWriter out = new PrintWriter(outStream, true /* autoFlush */);\r\nString hostName = InetAddress.getLocalHost().getHostName();\r\nreceive(in);\r\nsend(\"HELO \" + hostName,out);//发送mail命令\r\nreceive(in);\r\nsend(\"AUTH LOGIN\",out); //请求验证 命令\r\nreceive(in);\r\nBASE64Encoder encode=new BASE64Encoder();\r\nsend(encode.encode(\"33836858@qq.com\".getBytes()),out);//发送以base64加密的用户名\r\nSystem.out.println(encode.encode(\"33836858@qq.com\".getBytes()));\r\nreceive(in);\r\nsend(encode.encode(\"gigi117\".getBytes()),out);//发送以base64加密的密码\r\nSystem.out.println(encode.encode(\"gigi117\".getBytes()));\r\nreceive(in);\r\nsend(\"MAIL FROM: &lt;\" +\"33836858@qq.com\" + \"&gt;\",out);//本地地址\r\nreceive(in);\r\nsend(\"RCPT TO: &lt;\" + \"harlemnight.jeff@gmail.com\" + \"&gt;\",out);//发送地址\r\nreceive(in);\r\nsend(\"DATA\",out);//设置数据 命令\r\nreceive(in);\r\nsend(\"From: 33836858@qq.com\",out);//发送人\r\nsend(\"To: harlemnight.jeff@gmail.com\",out);//接收人\r\nsend(\"Subject: test mail\",out);//邮件标题\r\nsend(\"Hi,奈奈德熊 is so greate \",out);//主体\r\nsend(\".\",out);\r\nreceive(in);\r\nsend(\"QUIT\",out);//退出\r\nreceive(in);\r\ns.close();\r\n}\r\ncatch (IOException e)\r\n{\r\nSystem.out.println(e);\r\n}\r\n}\r\n\r\npublic static void send(String s,PrintWriter out) throws IOException\r\n{\r\nout.print(s.replaceAll(\"\\n\", \"\\r\\n\"));\r\nout.print(\"\\r\\n\");///注意 每一行 需要\\r\\n结尾 这是标准详细请看email规范\r\nout.flush();\r\n}\r\n\r\npublic static void receive(Scanner in) throws IOException\r\n{\r\nString line = in.nextLine();\r\nSystem.out.println(line);\r\n}\r\n}\r\n\r\n------这里是服务器的响应信息\r\n\r\n220 smtp.qq.com Esmtp QQ Mail Server  //连接成功    成功代码220/返回信息\r\n\r\nEsmtp表示需要提供验证信息 注册的用户名和密码\r\n250 smtp.qq.com\r\n334 VXNlcm5hbWU6         //用户名成功 返回信息\r\nMzM4MzY4NThAcXEuY29t\r\n334 UGFzc3dvcmQ6      //密码成功返回信息\r\nZ2lnaTExNw==\r\n235 Authentication successful    //验证成功返回信息\r\n250 Ok\r\n250 Ok\r\n354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;\r\n250 Ok: queued as\r\n221 Bye\r\n\r\n几秒后 你可以在harlemnight.jeff@gmail.com邮箱里收到来自33836858@qq.com的邮件\r\n\r\n-----------------------java mail 是由sun提供了一套API用于简化 mail  Java Mail API封装了网络协议的实现细节不需要像上面一样发送命令 该类实现了 邮件协议，认证，以及附件处理等等下面是采用javamail 获取QQ.com邮件的 一段代码\r\n\r\nString popServer=\"pop.qq.com\"; //邮件服务器 邮件服务器查看官方提供的信息\r\nString popUser=\"33836858\"; //根据自已的用户名修改\r\nString popPassword=\"gigi117\"; //根据自已的密码修改\r\nreceive(popServer, popUser, popPassword);\r\n\r\nreceive(String popServer, String popUser, String popPassword){\r\nStore store=null;\r\nFolder folder=null;\r\ntry{\r\nProperties props = System.getProperties();\r\nSession session = Session.getDefaultInstance(props, null);\r\nstore = session.getStore(\"pop3\");//pop3协议与邮件服务器提供的对应服务协议要匹配\r\nstore.connect(popServer, popUser, popPassword);\r\nSystem.out.println(store.isConnected());//连接成功  println   true\r\nfolder = store.getDefaultFolder();\r\nif (folder == null) throw new Exception(\"No default folder\");\r\nfolder = folder.getFolder(\"INBOX\");//获取收件箱目录\r\nif (folder == null) throw new Exception(\"No POP3 INBOX\");\r\nfolder.open(Folder.READ_ONLY);//只读方式打开目录\r\nMessage[] msgs = folder.getMessages();\r\nfor (int msgNum = 0; msgNum &lt; msgs.length; msgNum++){\r\n/*这里 你可以获取你所想要的 邮件信息 */\r\n\r\n}\r\n}catch (Exception ex){\r\nex.printStackTrace();\r\n}\r\n}\r\n\r\n&nbsp;','java mail','','inherit','open','open','','25-revision-v1','','','2013-08-23 13:40:06','2013-08-23 05:40:06','',25,'http://localhost/wordpress-new/?p=26',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (27,1,'2013-08-23 13:40:38','2013-08-23 05:40:38','<strong>Base64 </strong>Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到。比如通过smtp验证时传输的用户名和密码是通过Base64编码后传输的。对于编码规则 可以参看相关文档\r\n\r\n<strong>ASCii</strong> 0～255 是最基本的 目前计算机中用得最广泛的字符集及其编码，是由美国国家标准局(ANSI)制定的ASCII码（American Standard Code for Information Interchange，美国标准信息交换码）比如在Java里\r\n\r\nString str = \"A\";\r\nbyte[] b = str.getBytes();\r\nSystem.out.println(b[0]);\r\n\r\n将得到整数  65  而65 正好是ASCii码里对应的字符 大写的 A .1个byte(字节)是 由8位二进制组成 对与中文来说 需要2个byte来表示 也就是 b.length = 2 在java里可以通过 Integer类的\r\n\r\ntoBinaryString(2)  toHexString(16) toOctalString(8) 方法来获取不同的进制的转换结果\r\n\r\n<strong>Unicode</strong> 由于AScii只有1个字节 无法满足当前多语言的需要如中文 日文等由此而诞生了unicode分 UTF-8、UTF-16、UTF-32等 现在常用的是2个字节的，unicode码有几种字符集，有的是2个字节，有的是4个字节。而且在某些版本下，汉字是3个字节的\r\n\r\n&nbsp;','字符集','','publish','open','open','','%e5%ad%97%e7%ac%a6%e9%9b%86','','','2013-08-23 13:40:38','2013-08-23 05:40:38','',0,'http://localhost/wordpress-new/?p=27',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (28,1,'2013-08-23 13:40:38','2013-08-23 05:40:38','<strong>Base64 </strong>Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到。比如通过smtp验证时传输的用户名和密码是通过Base64编码后传输的。对于编码规则 可以参看相关文档\r\n\r\n<strong>ASCii</strong> 0～255 是最基本的 目前计算机中用得最广泛的字符集及其编码，是由美国国家标准局(ANSI)制定的ASCII码（American Standard Code for Information Interchange，美国标准信息交换码）比如在Java里\r\n\r\nString str = \"A\";\r\nbyte[] b = str.getBytes();\r\nSystem.out.println(b[0]);\r\n\r\n将得到整数  65  而65 正好是ASCii码里对应的字符 大写的 A .1个byte(字节)是 由8位二进制组成 对与中文来说 需要2个byte来表示 也就是 b.length = 2 在java里可以通过 Integer类的\r\n\r\ntoBinaryString(2)  toHexString(16) toOctalString(8) 方法来获取不同的进制的转换结果\r\n\r\n<strong>Unicode</strong> 由于AScii只有1个字节 无法满足当前多语言的需要如中文 日文等由此而诞生了unicode分 UTF-8、UTF-16、UTF-32等 现在常用的是2个字节的，unicode码有几种字符集，有的是2个字节，有的是4个字节。而且在某些版本下，汉字是3个字节的\r\n\r\n&nbsp;','字符集','','inherit','open','open','','27-revision-v1','','','2013-08-23 13:40:38','2013-08-23 05:40:38','',27,'http://localhost/wordpress-new/?p=28',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (29,1,'2013-08-23 13:41:04','2013-08-23 05:41:04','这篇文章是讲解如何使用Apache开源日志框架commons-logging 来记录日志信息的 首先你需要2个 包commons-logging.jar ,log4j.jar 以及一个配置文件 log4j.properties代码如下\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\n\r\npublic class B {\r\nprivate static Log log = LogFactory.getLog(B.class);\r\npublic void method() {\r\nlog.debug(\"this is a debug\");\r\nlog.info(\"this is a info\");\r\nlog.error(\"this is a error\");\r\nlog.warn(\"this is a warn\");\r\n}\r\n}\r\n\r\n采用logging来记录日志非常的简单 只需要 设置 Log log = LogFactory.getLog(B.class) 然后就可以使用Log里的方法 debug info error 等方法记录日志 logging通过配置文件 log4j.properties来设置如何记录日志信息 如输出地（文件，数据库，后台），输出等级(调试，信息，错误等等) 下面是上面代码的一个简单的配置信息  配置文件名为 log4j.properties 需要放在Classpath路径下\r\n\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender #控制台\r\nlog4j.appender.stdout.Target=System.out\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n\r\n\r\nlog4j.appender.file=org.apache.log4j.RollingFileAppender #输出到文件\r\nlog4j.appender.file.File=D:/coreapp.log #文件地址与名字\r\nlog4j.appender.file.MaxFileSize=1KB #文件大小\r\nlog4j.appender.file.MaxBackupIndex=100 #文件索引最多100个coreapp.log\r\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n\r\n\r\nlog4j.rootLogger=DEBUG,file,stdout\r\n#输出等级DEBUG就是说DEBUG以上的都需要输出包括info等信息,file,stdout设置输出变量\r\n\r\ncommons-logging 日志的记录方式是优先采用log4j方式他会 查找lib里是否有log4j包 有则优先使用log4j方式并需要配置文件 log4j.properties  如果没有则使用自身的配置信息 也需要配置文件  commons-logging.properties 在上面则使用java自带的日志记录方式\r\n\r\n&nbsp;','日志 logger','','publish','open','open','','%e6%97%a5%e5%bf%97-logger','','','2013-08-23 13:41:04','2013-08-23 05:41:04','',0,'http://localhost/wordpress-new/?p=29',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (30,1,'2013-08-23 13:41:04','2013-08-23 05:41:04','这篇文章是讲解如何使用Apache开源日志框架commons-logging 来记录日志信息的 首先你需要2个 包commons-logging.jar ,log4j.jar 以及一个配置文件 log4j.properties代码如下\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\n\r\npublic class B {\r\nprivate static Log log = LogFactory.getLog(B.class);\r\npublic void method() {\r\nlog.debug(\"this is a debug\");\r\nlog.info(\"this is a info\");\r\nlog.error(\"this is a error\");\r\nlog.warn(\"this is a warn\");\r\n}\r\n}\r\n\r\n采用logging来记录日志非常的简单 只需要 设置 Log log = LogFactory.getLog(B.class) 然后就可以使用Log里的方法 debug info error 等方法记录日志 logging通过配置文件 log4j.properties来设置如何记录日志信息 如输出地（文件，数据库，后台），输出等级(调试，信息，错误等等) 下面是上面代码的一个简单的配置信息  配置文件名为 log4j.properties 需要放在Classpath路径下\r\n\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender #控制台\r\nlog4j.appender.stdout.Target=System.out\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n\r\n\r\nlog4j.appender.file=org.apache.log4j.RollingFileAppender #输出到文件\r\nlog4j.appender.file.File=D:/coreapp.log #文件地址与名字\r\nlog4j.appender.file.MaxFileSize=1KB #文件大小\r\nlog4j.appender.file.MaxBackupIndex=100 #文件索引最多100个coreapp.log\r\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n\r\n\r\nlog4j.rootLogger=DEBUG,file,stdout\r\n#输出等级DEBUG就是说DEBUG以上的都需要输出包括info等信息,file,stdout设置输出变量\r\n\r\ncommons-logging 日志的记录方式是优先采用log4j方式他会 查找lib里是否有log4j包 有则优先使用log4j方式并需要配置文件 log4j.properties  如果没有则使用自身的配置信息 也需要配置文件  commons-logging.properties 在上面则使用java自带的日志记录方式\r\n\r\n&nbsp;','日志 logger','','inherit','open','open','','29-revision-v1','','','2013-08-23 13:41:04','2013-08-23 05:41:04','',29,'http://localhost/wordpress-new/?p=30',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (31,1,'2013-08-23 13:41:35','2013-08-23 05:41:35','分布式技术是指：客户机产生一个请求，然后将这个请求通过网络发送到服务器。服务器处理这个请求并发送回一个针对该客户端的响应，供客户端进行分析。其原理是在客户端与服务器端设置分别设置代理对象，客户端与服务器端通过代理对象来进行沟通，而代理则与各自的客户端与服务器端进行交流，这样看起来客户端与服务器端都是与本地对象进行交流。对于客户端与服务器端来说 都可以是桌面应用程序或者http的web服务等等\r\n\r\n通常有3种技术来实现\r\n\r\n1.RMI 基于java的远程方法调用 只用于客户与服务端都是基于java的程序。2.corba 支持对象之间的通信。3.web服务（web-ws）使用基于xml通信格式  采用（SOAP）协议。corba与web服务都是独立与语言的客户与服务器端程序可以是任何编程语言 如 c,c++ ,java等等. 而RMI是对企业java技术来说相当重要，它是企业Bean（EJB）之间通信时所使用的协议。\r\n\r\n当客户代码要在远程对象上调用一个远程方法时，实际上调用的是代理对象上的一个普通的方法，我们称此代理对象为存根（stub） 如下\r\n\r\nWarehouse  wh = get stub object；double price = wh.getPrice(\"test\");\r\n\r\n存根位于客户端机器上。它知道如何通过网络与服务器联系。存根将远程方法所需的参数打包成一组字节。并编组转换成适合在虚拟机之间进行传递的格式。在RMI协议中，对象是使用序列化机制进行编码的。它由如下几部分组成\r\n\r\n1.被使用的远程对象的标识符。2.被嗲用的方法的描述。3.被编组后的参数。然后，存根将此信息发送给服务器。在服务器端，接收对象执行以下操作。1.定位要调用的远程对象。2.调用所需的方法，并传递客户端提供的参数。3。捕获返回值或调用产生的异常。将返回值编组，打包送回给客户端存根。 客户端存根对来自服务器端的返回值或异常进行反编组，就成为了调用存根的返回值。如果远程方法抛出了一个异常，那么存根就在客户端发起调用的处理空间中重新抛出该异常。这个过程很复杂，当然对于程序员来说是透明的。 但是你最好还是了解一下细节，对你或许是有一定帮助的。','java 分布式对象 - 1','','publish','open','open','','java-%e5%88%86%e5%b8%83%e5%bc%8f%e5%af%b9%e8%b1%a1-1','','','2013-08-23 13:41:35','2013-08-23 05:41:35','',0,'http://localhost/wordpress-new/?p=31',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (32,1,'2013-08-23 13:41:35','2013-08-23 05:41:35','分布式技术是指：客户机产生一个请求，然后将这个请求通过网络发送到服务器。服务器处理这个请求并发送回一个针对该客户端的响应，供客户端进行分析。其原理是在客户端与服务器端设置分别设置代理对象，客户端与服务器端通过代理对象来进行沟通，而代理则与各自的客户端与服务器端进行交流，这样看起来客户端与服务器端都是与本地对象进行交流。对于客户端与服务器端来说 都可以是桌面应用程序或者http的web服务等等\r\n\r\n通常有3种技术来实现\r\n\r\n1.RMI 基于java的远程方法调用 只用于客户与服务端都是基于java的程序。2.corba 支持对象之间的通信。3.web服务（web-ws）使用基于xml通信格式  采用（SOAP）协议。corba与web服务都是独立与语言的客户与服务器端程序可以是任何编程语言 如 c,c++ ,java等等. 而RMI是对企业java技术来说相当重要，它是企业Bean（EJB）之间通信时所使用的协议。\r\n\r\n当客户代码要在远程对象上调用一个远程方法时，实际上调用的是代理对象上的一个普通的方法，我们称此代理对象为存根（stub） 如下\r\n\r\nWarehouse  wh = get stub object；double price = wh.getPrice(\"test\");\r\n\r\n存根位于客户端机器上。它知道如何通过网络与服务器联系。存根将远程方法所需的参数打包成一组字节。并编组转换成适合在虚拟机之间进行传递的格式。在RMI协议中，对象是使用序列化机制进行编码的。它由如下几部分组成\r\n\r\n1.被使用的远程对象的标识符。2.被嗲用的方法的描述。3.被编组后的参数。然后，存根将此信息发送给服务器。在服务器端，接收对象执行以下操作。1.定位要调用的远程对象。2.调用所需的方法，并传递客户端提供的参数。3。捕获返回值或调用产生的异常。将返回值编组，打包送回给客户端存根。 客户端存根对来自服务器端的返回值或异常进行反编组，就成为了调用存根的返回值。如果远程方法抛出了一个异常，那么存根就在客户端发起调用的处理空间中重新抛出该异常。这个过程很复杂，当然对于程序员来说是透明的。 但是你最好还是了解一下细节，对你或许是有一定帮助的。','java 分布式对象 - 1','','inherit','open','open','','31-revision-v1','','','2013-08-23 13:41:35','2013-08-23 05:41:35','',31,'http://localhost/wordpress-new/?p=32',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (33,1,'2013-08-23 13:42:04','2013-08-23 05:42:04','接着上一节这里讲解如何实现一个RMI应用下面是代码\r\n\r\n1. Warehouse.java Warehouse远程接口客户端通过该接口获取远程对象\r\n\r\npublic interface Warehouse extends Remote\r\n{\r\nB getB(int id) throws RemoteException;\r\nString getSub(String x,String y) throws RemoteException;\r\nList&lt;B&gt; getListB() throws RemoteException;\r\n}\r\n\r\n2.WarehouseImpl .java接口Warehouse的服务器实现实现具体的业务逻辑\r\n\r\npublic class WarehouseImpl extends UnicastRemoteObject implements Warehouse\r\n{\r\nprotected WarehouseImpl() throws RemoteException {}\r\npublic String getSub(String x, String y) throws RemoteException {return x+y;}\r\npublic B getB(int id) throws RemoteException {return new B(id);}\r\npublic List&lt;B&gt; getListB() throws RemoteException {\r\nList&lt;B&gt; list = new ArrayList&lt;B&gt;();\r\nlist.add(new B(123));\r\nlist.add(new B(456));\r\nlist.add(new B(789));\r\nreturn list;\r\n}\r\n}\r\n\r\n3.B.java 在RMI里类必须实现序列接口 java.io.Serializable\r\n\r\npublic class B implements Serializable {\r\nprivate int id;\r\npublic B (int id){this.id = id;}\r\npublic int getId() {return this.id;}\r\npublic void setId(int id) {this.id = id;}\r\n}\r\n\r\n4.WarehouseServer.java 编写服务器端的 RMI注册代码 并把对象绑定到上下文环境如下 绑定的对象名为rmi://localhost:1099/central_warehouse  rmi:为标准前缀.localhost为具体的服务器host或者ip地址 1099为默认的端口号  central_warehouse 为具体的绑定名称 通过 central_warehouse 客户端可以获取到远程接口的 Warehouse 的实例对象,就像在本地使用它一样.当启动main方法时下面的程序为创建一个RMI服务并等待客户端的访问请求。当然服务器可以是任何应用程序如application或者web服务\r\n\r\npublic class WarehouseServer\r\n{\r\npublic static void main(String[] args) throws RemoteException, NamingException\r\n{\r\nSystem.out.println(\"Constructing server implementation...\");\r\nWarehouseImpl centralWarehouse = new WarehouseImpl();\r\nLocateRegistry.createRegistry(1099);//以编写代码的形式在本地创建一个RMI服务\r\nSystem.out.println(\"Binding server implementation to registry...\");\r\nContext namingContext = new InitialContext();//初始化上下文\r\nnamingContext.rebind(\"rmi:central_warehouse\", centralWarehouse);//绑定实现了接口 Warehouse 的对象  centralWarehouse  名称为  central_warehouse\r\nSystem.out.println(\"Waiting for invocations from clients...\");\r\n}\r\n}\r\n\r\n5. WarehouseClient.java 客户端代码 通过给定的RMI服务提供的URL rmi://[hostname]/central_warehouse 通过上下文查找远程对象,然后就像本地对象一样使用。RMI自动帮你实现了底层的socket网络访问过程\r\n\r\npublic class WarehouseClient\r\n{\r\npublic static void main(String[] args) throws NamingException, RemoteException\r\n{\r\nContext namingContext = new InitialContext();\r\nString url = \"rmi://localhost/central_warehouse\"; //RMI服务提供的注册的rmi服务名\r\nWarehouse centralWarehouse = (Warehouse) namingContext.lookup(url); //通过jndi查找上下文根据提供的服务名获取对应的对象提供给远程接口，供给客户端的远程接口使用\r\nString price = centralWarehouse.getSub(\"123asdf\",\"2sadvfaf\");\r\nfor(int i=0;i&lt;centralWarehouse.getListB().size();i++) {\r\nSystem.out.println(centralWarehouse.getListB().get(i).getId());\r\n}\r\n}\r\n}\r\n\r\n最后启动  WarehouseServer RMI服务等待访问请求。然后你可以在命令行下通过java WarehouseClient 来运行客户端程序。注意请确保远程接口与客户端需要调用的类与客户端在一起该例是（interface Warehouse，class B）备注在通过RMI传递对象时是使用的拷贝如 往服务器端传递对象A ，服务器重新设置A的属性并返回A 而此时的A与客户端传递给服务端的A是不同的对象. RMI入门讲解就到此。\r\n\r\n小结：java企业应用EJB也是基于RMI协议。因此j2ee最重要的一点就是分布式。通过分布式把客户端程序与服务器端分开实现高性能的访问，如集群,EAI(企业应用集成)。EAI就是通过把服务器核心业务放在一个单独的服务器里，通过客户端如web服务，桌面，webservice等等来访问核心业务。通过这种模式使业务集成，相当与在一处写业务所有的客户端都可以使用，避免了多次编写代码带来额繁琐工作量。','java 分布式对象 - 2','','publish','open','open','','java-%e5%88%86%e5%b8%83%e5%bc%8f%e5%af%b9%e8%b1%a1-2','','','2013-08-23 13:42:04','2013-08-23 05:42:04','',0,'http://localhost/wordpress-new/?p=33',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (34,1,'2013-08-23 13:42:04','2013-08-23 05:42:04','接着上一节这里讲解如何实现一个RMI应用下面是代码\r\n\r\n1. Warehouse.java Warehouse远程接口客户端通过该接口获取远程对象\r\n\r\npublic interface Warehouse extends Remote\r\n{\r\nB getB(int id) throws RemoteException;\r\nString getSub(String x,String y) throws RemoteException;\r\nList&lt;B&gt; getListB() throws RemoteException;\r\n}\r\n\r\n2.WarehouseImpl .java接口Warehouse的服务器实现实现具体的业务逻辑\r\n\r\npublic class WarehouseImpl extends UnicastRemoteObject implements Warehouse\r\n{\r\nprotected WarehouseImpl() throws RemoteException {}\r\npublic String getSub(String x, String y) throws RemoteException {return x+y;}\r\npublic B getB(int id) throws RemoteException {return new B(id);}\r\npublic List&lt;B&gt; getListB() throws RemoteException {\r\nList&lt;B&gt; list = new ArrayList&lt;B&gt;();\r\nlist.add(new B(123));\r\nlist.add(new B(456));\r\nlist.add(new B(789));\r\nreturn list;\r\n}\r\n}\r\n\r\n3.B.java 在RMI里类必须实现序列接口 java.io.Serializable\r\n\r\npublic class B implements Serializable {\r\nprivate int id;\r\npublic B (int id){this.id = id;}\r\npublic int getId() {return this.id;}\r\npublic void setId(int id) {this.id = id;}\r\n}\r\n\r\n4.WarehouseServer.java 编写服务器端的 RMI注册代码 并把对象绑定到上下文环境如下 绑定的对象名为rmi://localhost:1099/central_warehouse  rmi:为标准前缀.localhost为具体的服务器host或者ip地址 1099为默认的端口号  central_warehouse 为具体的绑定名称 通过 central_warehouse 客户端可以获取到远程接口的 Warehouse 的实例对象,就像在本地使用它一样.当启动main方法时下面的程序为创建一个RMI服务并等待客户端的访问请求。当然服务器可以是任何应用程序如application或者web服务\r\n\r\npublic class WarehouseServer\r\n{\r\npublic static void main(String[] args) throws RemoteException, NamingException\r\n{\r\nSystem.out.println(\"Constructing server implementation...\");\r\nWarehouseImpl centralWarehouse = new WarehouseImpl();\r\nLocateRegistry.createRegistry(1099);//以编写代码的形式在本地创建一个RMI服务\r\nSystem.out.println(\"Binding server implementation to registry...\");\r\nContext namingContext = new InitialContext();//初始化上下文\r\nnamingContext.rebind(\"rmi:central_warehouse\", centralWarehouse);//绑定实现了接口 Warehouse 的对象  centralWarehouse  名称为  central_warehouse\r\nSystem.out.println(\"Waiting for invocations from clients...\");\r\n}\r\n}\r\n\r\n5. WarehouseClient.java 客户端代码 通过给定的RMI服务提供的URL rmi://[hostname]/central_warehouse 通过上下文查找远程对象,然后就像本地对象一样使用。RMI自动帮你实现了底层的socket网络访问过程\r\n\r\npublic class WarehouseClient\r\n{\r\npublic static void main(String[] args) throws NamingException, RemoteException\r\n{\r\nContext namingContext = new InitialContext();\r\nString url = \"rmi://localhost/central_warehouse\"; //RMI服务提供的注册的rmi服务名\r\nWarehouse centralWarehouse = (Warehouse) namingContext.lookup(url); //通过jndi查找上下文根据提供的服务名获取对应的对象提供给远程接口，供给客户端的远程接口使用\r\nString price = centralWarehouse.getSub(\"123asdf\",\"2sadvfaf\");\r\nfor(int i=0;i&lt;centralWarehouse.getListB().size();i++) {\r\nSystem.out.println(centralWarehouse.getListB().get(i).getId());\r\n}\r\n}\r\n}\r\n\r\n最后启动  WarehouseServer RMI服务等待访问请求。然后你可以在命令行下通过java WarehouseClient 来运行客户端程序。注意请确保远程接口与客户端需要调用的类与客户端在一起该例是（interface Warehouse，class B）备注在通过RMI传递对象时是使用的拷贝如 往服务器端传递对象A ，服务器重新设置A的属性并返回A 而此时的A与客户端传递给服务端的A是不同的对象. RMI入门讲解就到此。\r\n\r\n小结：java企业应用EJB也是基于RMI协议。因此j2ee最重要的一点就是分布式。通过分布式把客户端程序与服务器端分开实现高性能的访问，如集群,EAI(企业应用集成)。EAI就是通过把服务器核心业务放在一个单独的服务器里，通过客户端如web服务，桌面，webservice等等来访问核心业务。通过这种模式使业务集成，相当与在一处写业务所有的客户端都可以使用，避免了多次编写代码带来额繁琐工作量。','java 分布式对象 - 2','','inherit','open','open','','33-revision-v1','','','2013-08-23 13:42:04','2013-08-23 05:42:04','',33,'http://localhost/wordpress-new/?p=34',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (35,1,'2013-08-23 13:42:31','2013-08-23 05:42:31','接上一节。除了上一节所说的采用本地编程的方式 LocateRegistry.createRegistry(1099);通过在本地环境设置RMI服务外下面还将介绍另外部署RMI服务的方式。\r\n\r\n一种:.通过rmiregistry.exe 来注册RMI 它是jdk自带的在bin目录下面 通过这种方法来使用RMI首先需要获取实现远程接口的存根stub 下面讲解步骤。\r\n\r\n1.首先使用 rmic.exe 它也是jdk自带的在bin目录下，用来生成存根stub的。已上一节程序为例子在命令行下输入 rmic WarehouseImpl  （注意：在编译时请确保相实现该接口的相关类都存在不然无法通过）运行后 它会生成  WarehouseImpl_Stub.class 的stub存根文件。存根文件就是我们以前提到的客户端通过该存根文件访问远程对象时所调用的代理类,因此在客户端访问远程对象时请确保该存根文件也在客户端，不然客户端无法查找远程代理对象。\r\n\r\n2.然后启动RMI注册服务运行命令 rmiregistry\r\n\r\n3.然后启动服务器端程序命令 java WarehouseServer\r\n\r\n4.最后启动客户端程序调用服务器端 java WarehouseClient 如果没有问题的话你将会看到你所期望的结果\r\n\r\n另外一种是通过把实现接口的存根stub放在网络上的一台服务器上 比如一个web目录http://www.123.net:8080/stubclass/ 在该目录下放置我们编译好的XXXXX_Stub.classs文件（注意是整个包）然后客户端在运行时动态加载该存根 运行命令 java -Djava.rmi.server.codebase= http://www.123.net:8080/stubclass/ WarehouseImpl 由于需要访问网络上的类文件 需要设置java的安全管理器 需要配置文件 xxx.policy并与客户端一个目录下文件内容为 设置全部的许可\r\n\r\ngrant{\r\npermission java.security.AllPermission;\r\n}\r\n\r\n在客户端需要添加代码\r\n\r\nSystem.setProperty (\"java.security.policy\",\r\nPerfectTimeClient.class.getResource (\"server.policy\").toString ());\r\nSystem.setSecurityManager(new RMISecurityManager());\r\n\r\n客户端才可以动态的加载网络上的存根','java 分布式对象 - 3','','publish','open','open','','java-%e5%88%86%e5%b8%83%e5%bc%8f%e5%af%b9%e8%b1%a1-3','','','2013-08-23 13:42:31','2013-08-23 05:42:31','',0,'http://localhost/wordpress-new/?p=35',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (36,1,'2013-08-23 13:42:31','2013-08-23 05:42:31','接上一节。除了上一节所说的采用本地编程的方式 LocateRegistry.createRegistry(1099);通过在本地环境设置RMI服务外下面还将介绍另外部署RMI服务的方式。\r\n\r\n一种:.通过rmiregistry.exe 来注册RMI 它是jdk自带的在bin目录下面 通过这种方法来使用RMI首先需要获取实现远程接口的存根stub 下面讲解步骤。\r\n\r\n1.首先使用 rmic.exe 它也是jdk自带的在bin目录下，用来生成存根stub的。已上一节程序为例子在命令行下输入 rmic WarehouseImpl  （注意：在编译时请确保相实现该接口的相关类都存在不然无法通过）运行后 它会生成  WarehouseImpl_Stub.class 的stub存根文件。存根文件就是我们以前提到的客户端通过该存根文件访问远程对象时所调用的代理类,因此在客户端访问远程对象时请确保该存根文件也在客户端，不然客户端无法查找远程代理对象。\r\n\r\n2.然后启动RMI注册服务运行命令 rmiregistry\r\n\r\n3.然后启动服务器端程序命令 java WarehouseServer\r\n\r\n4.最后启动客户端程序调用服务器端 java WarehouseClient 如果没有问题的话你将会看到你所期望的结果\r\n\r\n另外一种是通过把实现接口的存根stub放在网络上的一台服务器上 比如一个web目录http://www.123.net:8080/stubclass/ 在该目录下放置我们编译好的XXXXX_Stub.classs文件（注意是整个包）然后客户端在运行时动态加载该存根 运行命令 java -Djava.rmi.server.codebase= http://www.123.net:8080/stubclass/ WarehouseImpl 由于需要访问网络上的类文件 需要设置java的安全管理器 需要配置文件 xxx.policy并与客户端一个目录下文件内容为 设置全部的许可\r\n\r\ngrant{\r\npermission java.security.AllPermission;\r\n}\r\n\r\n在客户端需要添加代码\r\n\r\nSystem.setProperty (\"java.security.policy\",\r\nPerfectTimeClient.class.getResource (\"server.policy\").toString ());\r\nSystem.setSecurityManager(new RMISecurityManager());\r\n\r\n客户端才可以动态的加载网络上的存根','java 分布式对象 - 3','','inherit','open','open','','35-revision-v1','','','2013-08-23 13:42:31','2013-08-23 05:42:31','',35,'http://localhost/wordpress-new/?p=36',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (37,1,'2013-08-23 13:42:56','2013-08-23 05:42:56','在jdk6发布后 开发webservices变得很简单 jdk6直接支持使用java使用 JAX-WS2.0开发web服务。在这之前都采用第3方开发工具xfire,axis等等来实现web服务。而且实现的方式都大相径庭。在jdk6里开发web服务更简便因为省去了第3方工具。下面是一个例子。\r\n\r\n1.Warehouse.java是一个简单的POJO用于返回一个double的数据类型,要实现它的远程访问在jdk6里可以这样编写\r\n\r\n@WebService //声明为web服务\r\npublic class Warehouse\r\n{\r\npublic Warehouse()\r\n{\r\nprices = new HashMap&lt;String, Double&gt;();\r\nprices.put(\"Blackwell Toaster\", 24.95);\r\nprices.put(\"ZapXpress Microwave Oven\", 49.95);\r\n}\r\npublic double getPrice(@WebParam(name=\"description\") String description)//设置参数名\r\n{\r\nDouble price = prices.get(description);\r\nreturn price == null ? 0 : price;\r\n}\r\nprivate Map&lt;String, Double&gt; prices;\r\n}\r\n\r\n2.公布该远程对象使他在网络上能更被客户端访问 只需要在main函数里如下设置.\r\n\r\nEndpoint.publish(\"http://localhost:8080/WebServices/warehouse\", new Warehouse())\r\n\r\n3.在客户端可以通过http://localhost:8080/WebServices/warehouse?wsdl  得到该web服务的WSDL文件.\r\n\r\n4.客户通过wsimport -p com.test.webservice -keep   http://localhost:8080/WebServices/warehouse?wsdl 就可以得到该远程方法对应的本地代理文件存根等客户端类如\r\n\r\nGetPrice.class,GetPriceResponse.class,ObjectFactory.class,package-info.class,Warehouse.class,WarehouseService.class通过这些类客户端就可以访问web服务了.如下.\r\n\r\npublic class WarehouseClient\r\n{\r\npublic static void main(String[] args) throws NamingException, RemoteException\r\n{\r\nWarehouseService service = new WarehouseService(); //根据WSDL配置实例化Servicesname\r\nWarehouse port = service.getPort(Warehouse.class);// 根据WSDL配置中的prottype调用引用接口\r\nString descr = \"Blackwell Toaster\";\r\ndouble price = port.getPrice(descr);//调用WSDL配置中的&lt;operation name=\"<strong>getPrice</strong>\"&gt;方法\r\nSystem.out.println(descr + \": \" + price);\r\n}\r\n}\r\n\r\n注意：在JAX-WS2.0里的两个命令 1.wsgen 用于在服务器端为公布为web服务的类生成代理封装类的工具它会在包  xxx.xxx.jaxws.GetGreeting, xxx.xxx.jaxws.GetGreetingResponse两个代理类 当然如果不手动生成这两个类 在 启动web服务的时候 系统第一次启动的时候会自动动态的生成这两个类. 2.wsimport 用于根据web服务提供着 提供的WSDL生成用于客户端可调用的代码. 如果你是用的IDE 工具 如 eclipse(myeclipse)可以用ant来代替在shell中输入命令如\r\n\r\n你可以在 你的项目工程根目录里创建一个 build.xml文件下面是 2个例子\r\n\r\n1.wsgen 命令\r\n\r\n&lt;project default=\"wsgen\"&gt;\r\n&lt;target name=\"wsgen\" &gt;\r\n&lt;exec executable=\"wsgen\"&gt;\r\n&lt;arg line=\"-cp ./bin -keep -s ./src -d ./bin com.ws.wser.Hello\"/&gt;\r\n&lt;/exec&gt;\r\n&lt;/target&gt;\r\n&lt;/project&gt;\r\n\r\n2.wsimport 命令\r\n\r\n&lt;project default=\"wsimport\"&gt;\r\n&lt;target name=\"wsimport\" &gt;\r\n&lt;exec executable=\"wsimport\"&gt;\r\n&lt;arg line=\"-p com.ws.wser.client -keep http://localhost:8080/wsServerExample?wsdl\"/&gt;\r\n&lt;/exec&gt;\r\n&lt;/target&gt;\r\n&lt;/project&gt;\r\n\r\n&nbsp;','java 分布式对象之web services -1','','publish','open','open','','java-%e5%88%86%e5%b8%83%e5%bc%8f%e5%af%b9%e8%b1%a1%e4%b9%8bweb-services-1','','','2013-08-23 13:42:56','2013-08-23 05:42:56','',0,'http://localhost/wordpress-new/?p=37',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (38,1,'2013-08-23 13:42:56','2013-08-23 05:42:56','在jdk6发布后 开发webservices变得很简单 jdk6直接支持使用java使用 JAX-WS2.0开发web服务。在这之前都采用第3方开发工具xfire,axis等等来实现web服务。而且实现的方式都大相径庭。在jdk6里开发web服务更简便因为省去了第3方工具。下面是一个例子。\r\n\r\n1.Warehouse.java是一个简单的POJO用于返回一个double的数据类型,要实现它的远程访问在jdk6里可以这样编写\r\n\r\n@WebService //声明为web服务\r\npublic class Warehouse\r\n{\r\npublic Warehouse()\r\n{\r\nprices = new HashMap&lt;String, Double&gt;();\r\nprices.put(\"Blackwell Toaster\", 24.95);\r\nprices.put(\"ZapXpress Microwave Oven\", 49.95);\r\n}\r\npublic double getPrice(@WebParam(name=\"description\") String description)//设置参数名\r\n{\r\nDouble price = prices.get(description);\r\nreturn price == null ? 0 : price;\r\n}\r\nprivate Map&lt;String, Double&gt; prices;\r\n}\r\n\r\n2.公布该远程对象使他在网络上能更被客户端访问 只需要在main函数里如下设置.\r\n\r\nEndpoint.publish(\"http://localhost:8080/WebServices/warehouse\", new Warehouse())\r\n\r\n3.在客户端可以通过http://localhost:8080/WebServices/warehouse?wsdl  得到该web服务的WSDL文件.\r\n\r\n4.客户通过wsimport -p com.test.webservice -keep   http://localhost:8080/WebServices/warehouse?wsdl 就可以得到该远程方法对应的本地代理文件存根等客户端类如\r\n\r\nGetPrice.class,GetPriceResponse.class,ObjectFactory.class,package-info.class,Warehouse.class,WarehouseService.class通过这些类客户端就可以访问web服务了.如下.\r\n\r\npublic class WarehouseClient\r\n{\r\npublic static void main(String[] args) throws NamingException, RemoteException\r\n{\r\nWarehouseService service = new WarehouseService(); //根据WSDL配置实例化Servicesname\r\nWarehouse port = service.getPort(Warehouse.class);// 根据WSDL配置中的prottype调用引用接口\r\nString descr = \"Blackwell Toaster\";\r\ndouble price = port.getPrice(descr);//调用WSDL配置中的&lt;operation name=\"<strong>getPrice</strong>\"&gt;方法\r\nSystem.out.println(descr + \": \" + price);\r\n}\r\n}\r\n\r\n注意：在JAX-WS2.0里的两个命令 1.wsgen 用于在服务器端为公布为web服务的类生成代理封装类的工具它会在包  xxx.xxx.jaxws.GetGreeting, xxx.xxx.jaxws.GetGreetingResponse两个代理类 当然如果不手动生成这两个类 在 启动web服务的时候 系统第一次启动的时候会自动动态的生成这两个类. 2.wsimport 用于根据web服务提供着 提供的WSDL生成用于客户端可调用的代码. 如果你是用的IDE 工具 如 eclipse(myeclipse)可以用ant来代替在shell中输入命令如\r\n\r\n你可以在 你的项目工程根目录里创建一个 build.xml文件下面是 2个例子\r\n\r\n1.wsgen 命令\r\n\r\n&lt;project default=\"wsgen\"&gt;\r\n&lt;target name=\"wsgen\" &gt;\r\n&lt;exec executable=\"wsgen\"&gt;\r\n&lt;arg line=\"-cp ./bin -keep -s ./src -d ./bin com.ws.wser.Hello\"/&gt;\r\n&lt;/exec&gt;\r\n&lt;/target&gt;\r\n&lt;/project&gt;\r\n\r\n2.wsimport 命令\r\n\r\n&lt;project default=\"wsimport\"&gt;\r\n&lt;target name=\"wsimport\" &gt;\r\n&lt;exec executable=\"wsimport\"&gt;\r\n&lt;arg line=\"-p com.ws.wser.client -keep http://localhost:8080/wsServerExample?wsdl\"/&gt;\r\n&lt;/exec&gt;\r\n&lt;/target&gt;\r\n&lt;/project&gt;\r\n\r\n&nbsp;','java 分布式对象之web services -1','','inherit','open','open','','37-revision-v1','','','2013-08-23 13:42:56','2013-08-23 05:42:56','',37,'http://localhost/wordpress-new/?p=38',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (39,1,'2013-08-23 13:43:31','2013-08-23 05:43:31','前面讲了在java使用JAX-WS来创建web services 这里来讲解关于web services的一些东东.Web 服务已经出现很久了。首先是 SOAP，但 SOAP 仅描述消息的情况，然后是 WSDL，WSDL 并不会告诉您如何使用 Java™ 编写 Web 服务。在这种情况下，JAX-RPC 1.0 应运而生。经过数月使用之后，编写此规范的 Java Community Process (JCP) 人员认识到需要对其进行一些调整，调整的结果就是 JAX-RPC 1.1。该规范使用大约一年之后，JCP 人员希望构建一个更好的版本：JAX-RPC 2.0。其主要目标是与行业方向保持一致，但行业中不仅只使用 RPC Web 服务，还使用面向消息的 Web 服务。因此从名称中去掉了“RPC”，取而代之的是“WS”（当然表示的是 Web 服务）。因此 JAX-RPC 1.1 的后续版本是 JAX-WS 2.0——Java API for XML-based Web services。\r\n\r\n哪些内容保持不变？\r\n\r\n在列出 JAX-RPC 1.1 和 JAX-WS 2.0 的差异前，我们应该首先讨论一下二者的相同之处。\r\nJAX-WS 仍然支持 SOAP 1.1 over HTTP 1.1，因此互操作性将不会受到影响，仍然可以在网上传递相同的消息。\r\nJAX-WS 仍然支持 WSDL 1.1，因此您所学到的有关该规范的知识仍然有用。WSDL 2.0 规范已经接近完成，但在 JAX-WS 2.0 相关工作结束时其工作仍在进行中。\r\n\r\n区别何在？\r\nSOAP 1.2\r\n\r\nJAX-RPC 和 JAX-WS 都支持 SOAP 1.1。JAX-WS 还支持 SOAP 1.2。\r\nXML/HTTP\r\n\r\nWSDL 1.1 规范在 HTTP 绑定中定义，这意味着利用此规范可以在不使用 SOAP 的情况下通过 HTTP 发送 XML 消息。JAX-RPC 忽略了 HTTP 绑定。而 JAX-WS 添加了对其的支持。\r\nWS-I Basic Profile\r\n\r\nJAX-RPC 支持 WS-I Basic Profile (BP) V1.0。JAX-WS 支持 BP 1.1。（WS-I 即 Web 服务互操作性组织。）\r\n新 Java 功能\r\nJAX-RPC 映射到 Java 1.4。JAX-WS 映射到 Java 5.0。JAX-WS 依赖于 Java 5.0 中的很多新功能。\r\nJava EE 5 是 J2EE 1.4 的后续版本，添加了对 JAX-WS 的支持，但仍然支持 JAX-RPC，这可能会对 Web 服务新手造成混淆。\r\n数据映射模型\r\nJAX-RPC 具有自己的映射模型，此模型大约涵盖了所有模式类型中的 90%。它没有涵盖的部分映射到了 javax.xml.soap.SOAPElement。\r\nJAX-WS 的数据映射模型是 JAXB。JAXB 可保证所有 XML 模式的映射。\r\n接口映射模型\r\n\r\nJAX-WS 的基本接口映射模型与 JAX-RPC 的区别并不大，不过二者之间存在以下差异：\r\nJAX-WS 的模型使用新的 Java 5.0 功能。\r\nJAX-WS 的模型引入了异步功能。\r\n动态编程模型\r\nJAX-WS 的动态客户机模型与 JAX-RPC 的对应模型差别很大。很多更改都是为了认可行业需求：\r\n引入了面向消息的功能。\r\n引入了动态异步功能。\r\nJAX-WS 还添加了动态服务器模型，而 JAX-RPC 则没有此模型。\r\n消息传输优化机制（Message Transmission Optimization Mechanism，MTOM）\r\n\r\nJAX-WS 通过 JAXB 添加了对新附件规范 MTOM 的支持。Microsoft 从来没有给 SOAP 添加附件规范；但似乎大家都支持 MTOM，因此应该能够实现附件互操作性。\r\n处理程序模型\r\n从 JAX-RPC 到 JAX-WS 的过程中，处理程序模型发生了很大的变化。\r\nJAX-RPC 处理程序依赖于 SAAJ 1.2。JAX-WS 处理程序依赖于新的 SAAJ 1.3 规范\r\n\r\n总结\r\n\r\nJAX-WS 2.0 是 JAX-RPC 1.1 的后续版本。其中有些内容保持不变，但大部分编程模型都或多或少有些不同。本技巧文章中介绍的主题将在一系列技巧文章中展开讨论，这个系列的文章对 JAX-WS 和 JAX-RPC 间的区别进行了详细的讨论，我们将在随后的数月中陆续发布。大致看来，可能会因为以下这些原因而决定从 JAX-RPC 迁移到 JAX-WS，或保持不变。\r\n\r\n希望继续使用 JAX-RPC 1.1 的原因：\r\n如果您希望继续使用现有的东西，JAX-RPC 将在今后一段时间内继续得到支持。\r\n如果您不希望升级到 Java 5。\r\n如果您希望发送采用 SOAP 编码的消息或创建 RPC/encoded 样式的 WSDL。\r\n\r\n升级到 JAX-WS 2.0 的原因：\r\n如果您希望使用新的面向消息的 API。\r\n如果您希望使用 MTOM 发送附件数据。\r\n如果您希望通过 JAXB 更好地支持 XML 模式。\r\n如果您希望在 Web 服务客户机中采用异步编程模型。\r\n如果您需要使用能够处理 SOAP 1.2 消息的客户机或服务。\r\n如果您希望在 Web 服务中消除对 SOAP 的需求，而直接使用 XML/HTTP 绑定。\r\n如果您喜欢使用领先的尖端技术。','java 分布式对象之web services -2','','publish','open','open','','java-%e5%88%86%e5%b8%83%e5%bc%8f%e5%af%b9%e8%b1%a1%e4%b9%8bweb-services-2','','','2013-08-23 13:43:31','2013-08-23 05:43:31','',0,'http://localhost/wordpress-new/?p=39',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (40,1,'2013-08-23 13:43:31','2013-08-23 05:43:31','前面讲了在java使用JAX-WS来创建web services 这里来讲解关于web services的一些东东.Web 服务已经出现很久了。首先是 SOAP，但 SOAP 仅描述消息的情况，然后是 WSDL，WSDL 并不会告诉您如何使用 Java™ 编写 Web 服务。在这种情况下，JAX-RPC 1.0 应运而生。经过数月使用之后，编写此规范的 Java Community Process (JCP) 人员认识到需要对其进行一些调整，调整的结果就是 JAX-RPC 1.1。该规范使用大约一年之后，JCP 人员希望构建一个更好的版本：JAX-RPC 2.0。其主要目标是与行业方向保持一致，但行业中不仅只使用 RPC Web 服务，还使用面向消息的 Web 服务。因此从名称中去掉了“RPC”，取而代之的是“WS”（当然表示的是 Web 服务）。因此 JAX-RPC 1.1 的后续版本是 JAX-WS 2.0——Java API for XML-based Web services。\r\n\r\n哪些内容保持不变？\r\n\r\n在列出 JAX-RPC 1.1 和 JAX-WS 2.0 的差异前，我们应该首先讨论一下二者的相同之处。\r\nJAX-WS 仍然支持 SOAP 1.1 over HTTP 1.1，因此互操作性将不会受到影响，仍然可以在网上传递相同的消息。\r\nJAX-WS 仍然支持 WSDL 1.1，因此您所学到的有关该规范的知识仍然有用。WSDL 2.0 规范已经接近完成，但在 JAX-WS 2.0 相关工作结束时其工作仍在进行中。\r\n\r\n区别何在？\r\nSOAP 1.2\r\n\r\nJAX-RPC 和 JAX-WS 都支持 SOAP 1.1。JAX-WS 还支持 SOAP 1.2。\r\nXML/HTTP\r\n\r\nWSDL 1.1 规范在 HTTP 绑定中定义，这意味着利用此规范可以在不使用 SOAP 的情况下通过 HTTP 发送 XML 消息。JAX-RPC 忽略了 HTTP 绑定。而 JAX-WS 添加了对其的支持。\r\nWS-I Basic Profile\r\n\r\nJAX-RPC 支持 WS-I Basic Profile (BP) V1.0。JAX-WS 支持 BP 1.1。（WS-I 即 Web 服务互操作性组织。）\r\n新 Java 功能\r\nJAX-RPC 映射到 Java 1.4。JAX-WS 映射到 Java 5.0。JAX-WS 依赖于 Java 5.0 中的很多新功能。\r\nJava EE 5 是 J2EE 1.4 的后续版本，添加了对 JAX-WS 的支持，但仍然支持 JAX-RPC，这可能会对 Web 服务新手造成混淆。\r\n数据映射模型\r\nJAX-RPC 具有自己的映射模型，此模型大约涵盖了所有模式类型中的 90%。它没有涵盖的部分映射到了 javax.xml.soap.SOAPElement。\r\nJAX-WS 的数据映射模型是 JAXB。JAXB 可保证所有 XML 模式的映射。\r\n接口映射模型\r\n\r\nJAX-WS 的基本接口映射模型与 JAX-RPC 的区别并不大，不过二者之间存在以下差异：\r\nJAX-WS 的模型使用新的 Java 5.0 功能。\r\nJAX-WS 的模型引入了异步功能。\r\n动态编程模型\r\nJAX-WS 的动态客户机模型与 JAX-RPC 的对应模型差别很大。很多更改都是为了认可行业需求：\r\n引入了面向消息的功能。\r\n引入了动态异步功能。\r\nJAX-WS 还添加了动态服务器模型，而 JAX-RPC 则没有此模型。\r\n消息传输优化机制（Message Transmission Optimization Mechanism，MTOM）\r\n\r\nJAX-WS 通过 JAXB 添加了对新附件规范 MTOM 的支持。Microsoft 从来没有给 SOAP 添加附件规范；但似乎大家都支持 MTOM，因此应该能够实现附件互操作性。\r\n处理程序模型\r\n从 JAX-RPC 到 JAX-WS 的过程中，处理程序模型发生了很大的变化。\r\nJAX-RPC 处理程序依赖于 SAAJ 1.2。JAX-WS 处理程序依赖于新的 SAAJ 1.3 规范\r\n\r\n总结\r\n\r\nJAX-WS 2.0 是 JAX-RPC 1.1 的后续版本。其中有些内容保持不变，但大部分编程模型都或多或少有些不同。本技巧文章中介绍的主题将在一系列技巧文章中展开讨论，这个系列的文章对 JAX-WS 和 JAX-RPC 间的区别进行了详细的讨论，我们将在随后的数月中陆续发布。大致看来，可能会因为以下这些原因而决定从 JAX-RPC 迁移到 JAX-WS，或保持不变。\r\n\r\n希望继续使用 JAX-RPC 1.1 的原因：\r\n如果您希望继续使用现有的东西，JAX-RPC 将在今后一段时间内继续得到支持。\r\n如果您不希望升级到 Java 5。\r\n如果您希望发送采用 SOAP 编码的消息或创建 RPC/encoded 样式的 WSDL。\r\n\r\n升级到 JAX-WS 2.0 的原因：\r\n如果您希望使用新的面向消息的 API。\r\n如果您希望使用 MTOM 发送附件数据。\r\n如果您希望通过 JAXB 更好地支持 XML 模式。\r\n如果您希望在 Web 服务客户机中采用异步编程模型。\r\n如果您需要使用能够处理 SOAP 1.2 消息的客户机或服务。\r\n如果您希望在 Web 服务中消除对 SOAP 的需求，而直接使用 XML/HTTP 绑定。\r\n如果您喜欢使用领先的尖端技术。','java 分布式对象之web services -2','','inherit','open','open','','39-revision-v1','','','2013-08-23 13:43:31','2013-08-23 05:43:31','',39,'http://localhost/wordpress-new/?p=40',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (41,1,'2013-08-23 13:44:04','2013-08-23 05:44:04','JAX-RPC 1.0 是 Java 方面的 Web 服务的原始标准。虽然 JAX-RPC 的设计思想是可以为实际 Web 服务实现使用不同的协议实现，但在实践中，仅将其用于 SOAP 服务。已经开发了多个不同的 JAX-RPC 实现，其中使用最广泛的可能就是 Apache(axis)框架了，其次是 Sun Microsystems 作为 Java Web Services Developer Pack 的一部分分发的 Reference Implementation。这里就来讲讲如何使用 axis JAX-RPC 构建 RPC 服务和客户机\r\n\r\n<strong>JAX-RPC 把 API 与实现分隔开</strong>\r\n\r\nJAX-RPC 的设计者定义了一个规范，然后编写了许多接口。这些接口定义类名和行为，但是它们没有实现 这些行为。生产商可以编写自己的 API 来实现 JAX-RPC 的标准接口。\r\n\r\n您必须明白一点：JAX-RPC 本身没什么用。它有许多方法和接口，但是没有支持和实现它们的代码。因此，实际上 “安装 JAX-RPC” 是没有意义的。安装 JAX-RPC 实际上是指安装 JAX-RPC 的一种实现。为了方便，所有 JAX-RPC 接口都附带有可用的实现，而且经过适当的打包。所以尽管可以下载 JAX-RPC 规范文档（参见 参考资料），但是不需要安装 JAX-RPC，只需安装这个 API 的某种实现。\r\n\r\n<strong>安装 Apache Axis</strong>\r\n\r\n本教程使用的 JAX-RPC 实现是 Apache Axis。Axis 是免费的、开放源码且得到良好的支持。本教程使用 Apache Axis 1.4 而不是 Axis 2.0，因为后者不太适合 RPC 应用程序。Axis 1.4 仍然是当前支持的版本。 选择最新版本；本教程使用 1.4 版。选择一个版本之后，可以选择一个镜像站点。最后，选择适合自己平台的二进制下载文件。Windows® 用户应该选择以 .zip 结尾的文件。Mac OS X 或 Linux® 用户应该选择 .tar.gz 版本。所以对于 Mac OS X 平台，选择 axis-bi-1_4.tar.gz；Windows 用户选择 axis-bin-1_4.zip。\r\n\r\n<strong>安装 Apache Axis Web 应用程序</strong>\r\n\r\nApache Axis 附带一个示例 Web 应用程序，这个程序可以部署在任何 servlet 容器中。只需把这个 Axis Web 应用程序复制到 servlet 容器中驻留 Web 应用程序的地方，然后测试 Axis。\r\n\r\n现在，把 Axis 安装中的 webapps/ 目录中的 Axis 目录复制到 servlet 引擎的 webapps/ 目录  找到刚才安装的 Axis Web 应用程序。通常，只需输入 servlet 引擎的 URL、前向斜杠（/）和 Web 应用程序的名称：axis。因此，如果 servlet 引擎驻留在 http://localhost:8080，Axis 完整的 URL 就是 http://localhost:8080/axis/。 Axis Web 应用程序已经安装好了\r\n\r\naxis提供了一些可选的组件如 mail.jar xmlsec.jar 由于不需要考虑邮件和安全性 可以不用加载这2个包\r\n\r\n访问axis web主页 点击call连接 可以看到一个测试的 web服务的wsdl\r\n<div>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</div>\r\n<div>\r\n<div><a onclick=\"return false\" href=\"#\" onfocus=\"h()\">-</a> &lt;soapenv:Envelope xmlns:soapenv=\"<strong>http://schemas.xmlsoap.org/soap/envelope/</strong>\" xmlns:xsd=\"<strong>http://www.w3.org/2001/XMLSchema</strong>\" xmlns:xsi=\"<strong>http://www.w3.org/2001/XMLSchema-instance</strong>\"&gt;</div>\r\n<div>\r\n<div>\r\n<div><a onclick=\"return false\" href=\"#\" onfocus=\"h()\">-</a> &lt;soapenv:Body&gt;</div>\r\n<div>\r\n<div>\r\n<div><a onclick=\"return false\" href=\"#\" onfocus=\"h()\">-</a> &lt;listResponse soapenv:encodingStyle=\"<strong>http://schemas.xmlsoap.org/soap/encoding/</strong>\"&gt;</div>\r\n<div>\r\n<div>\r\n<div><a onclick=\"return false\" href=\"#\" onfocus=\"h()\">-</a> &lt;listReturn soapenc:arrayType=\"<strong>xsd:string[8]</strong>\" xsi:type=\"<strong>soapenc:Array</strong>\" xmlns:soapenc=\"<strong>http://schemas.xmlsoap.org/soap/encoding/</strong>\"&gt;</div>\r\n<div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;accept:image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/msword, application/vnd.ms-excel, application/vnd.ms-powerpoint, */*&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;referer:http://localhost:8081/axis/&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;accept-language:zh-cn&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;user-agent:Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;accept-encoding:gzip, deflate&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;host:localhost:8081&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;connection:Keep-Alive&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;cookie:JSESSIONID=779605AD1DE45CECC0873007DC1914FD&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>  &lt;/listReturn&gt;</div>\r\n</div>\r\n</div>\r\n<div>  &lt;/listResponse&gt;</div>\r\n</div>\r\n</div>\r\n<div>  &lt;/soapenv:Body&gt;</div>\r\n</div>\r\n</div>\r\n<div>  &lt;/soapenv:Envelope&gt;</div>\r\n</div>\r\n</div>\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;','JAX-RPC开发Web服务之(Apache axis 1.4) -1','','publish','open','open','','jax-rpc%e5%bc%80%e5%8f%91web%e6%9c%8d%e5%8a%a1%e4%b9%8bapache-axis-1-4-1','','','2013-08-23 13:44:04','2013-08-23 05:44:04','',0,'http://localhost/wordpress-new/?p=41',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (42,1,'2013-08-23 13:44:04','2013-08-23 05:44:04','JAX-RPC 1.0 是 Java 方面的 Web 服务的原始标准。虽然 JAX-RPC 的设计思想是可以为实际 Web 服务实现使用不同的协议实现，但在实践中，仅将其用于 SOAP 服务。已经开发了多个不同的 JAX-RPC 实现，其中使用最广泛的可能就是 Apache(axis)框架了，其次是 Sun Microsystems 作为 Java Web Services Developer Pack 的一部分分发的 Reference Implementation。这里就来讲讲如何使用 axis JAX-RPC 构建 RPC 服务和客户机\r\n\r\n<strong>JAX-RPC 把 API 与实现分隔开</strong>\r\n\r\nJAX-RPC 的设计者定义了一个规范，然后编写了许多接口。这些接口定义类名和行为，但是它们没有实现 这些行为。生产商可以编写自己的 API 来实现 JAX-RPC 的标准接口。\r\n\r\n您必须明白一点：JAX-RPC 本身没什么用。它有许多方法和接口，但是没有支持和实现它们的代码。因此，实际上 “安装 JAX-RPC” 是没有意义的。安装 JAX-RPC 实际上是指安装 JAX-RPC 的一种实现。为了方便，所有 JAX-RPC 接口都附带有可用的实现，而且经过适当的打包。所以尽管可以下载 JAX-RPC 规范文档（参见 参考资料），但是不需要安装 JAX-RPC，只需安装这个 API 的某种实现。\r\n\r\n<strong>安装 Apache Axis</strong>\r\n\r\n本教程使用的 JAX-RPC 实现是 Apache Axis。Axis 是免费的、开放源码且得到良好的支持。本教程使用 Apache Axis 1.4 而不是 Axis 2.0，因为后者不太适合 RPC 应用程序。Axis 1.4 仍然是当前支持的版本。 选择最新版本；本教程使用 1.4 版。选择一个版本之后，可以选择一个镜像站点。最后，选择适合自己平台的二进制下载文件。Windows® 用户应该选择以 .zip 结尾的文件。Mac OS X 或 Linux® 用户应该选择 .tar.gz 版本。所以对于 Mac OS X 平台，选择 axis-bi-1_4.tar.gz；Windows 用户选择 axis-bin-1_4.zip。\r\n\r\n<strong>安装 Apache Axis Web 应用程序</strong>\r\n\r\nApache Axis 附带一个示例 Web 应用程序，这个程序可以部署在任何 servlet 容器中。只需把这个 Axis Web 应用程序复制到 servlet 容器中驻留 Web 应用程序的地方，然后测试 Axis。\r\n\r\n现在，把 Axis 安装中的 webapps/ 目录中的 Axis 目录复制到 servlet 引擎的 webapps/ 目录  找到刚才安装的 Axis Web 应用程序。通常，只需输入 servlet 引擎的 URL、前向斜杠（/）和 Web 应用程序的名称：axis。因此，如果 servlet 引擎驻留在 http://localhost:8080，Axis 完整的 URL 就是 http://localhost:8080/axis/。 Axis Web 应用程序已经安装好了\r\n\r\naxis提供了一些可选的组件如 mail.jar xmlsec.jar 由于不需要考虑邮件和安全性 可以不用加载这2个包\r\n\r\n访问axis web主页 点击call连接 可以看到一个测试的 web服务的wsdl\r\n<div>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</div>\r\n<div>\r\n<div><a onclick=\"return false\" href=\"#\" onfocus=\"h()\">-</a> &lt;soapenv:Envelope xmlns:soapenv=\"<strong>http://schemas.xmlsoap.org/soap/envelope/</strong>\" xmlns:xsd=\"<strong>http://www.w3.org/2001/XMLSchema</strong>\" xmlns:xsi=\"<strong>http://www.w3.org/2001/XMLSchema-instance</strong>\"&gt;</div>\r\n<div>\r\n<div>\r\n<div><a onclick=\"return false\" href=\"#\" onfocus=\"h()\">-</a> &lt;soapenv:Body&gt;</div>\r\n<div>\r\n<div>\r\n<div><a onclick=\"return false\" href=\"#\" onfocus=\"h()\">-</a> &lt;listResponse soapenv:encodingStyle=\"<strong>http://schemas.xmlsoap.org/soap/encoding/</strong>\"&gt;</div>\r\n<div>\r\n<div>\r\n<div><a onclick=\"return false\" href=\"#\" onfocus=\"h()\">-</a> &lt;listReturn soapenc:arrayType=\"<strong>xsd:string[8]</strong>\" xsi:type=\"<strong>soapenc:Array</strong>\" xmlns:soapenc=\"<strong>http://schemas.xmlsoap.org/soap/encoding/</strong>\"&gt;</div>\r\n<div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;accept:image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/msword, application/vnd.ms-excel, application/vnd.ms-powerpoint, */*&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;referer:http://localhost:8081/axis/&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;accept-language:zh-cn&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;user-agent:Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;accept-encoding:gzip, deflate&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;host:localhost:8081&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;connection:Keep-Alive&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>\r\n<div>  &lt;listReturn xsi:type=\"<strong>xsd:string</strong>\"&gt;cookie:JSESSIONID=779605AD1DE45CECC0873007DC1914FD&lt;/listReturn&gt;</div>\r\n</div>\r\n<div>  &lt;/listReturn&gt;</div>\r\n</div>\r\n</div>\r\n<div>  &lt;/listResponse&gt;</div>\r\n</div>\r\n</div>\r\n<div>  &lt;/soapenv:Body&gt;</div>\r\n</div>\r\n</div>\r\n<div>  &lt;/soapenv:Envelope&gt;</div>\r\n</div>\r\n</div>\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;','JAX-RPC开发Web服务之(Apache axis 1.4) -1','','inherit','open','open','','41-revision-v1','','','2013-08-23 13:44:04','2013-08-23 05:44:04','',41,'http://localhost/wordpress-new/?p=42',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (44,1,'2013-08-23 13:44:50','2013-08-23 05:44:50','这里以weblogic8.1_sp6为EJB服务器为平台来初步讲解下如何开发EJB组建 以及客户端如何调用EJB对象。这里我们使用myeclipse8.5作为开发工具具体的开发步骤不会详细记录 这里只记录必要的步骤.\r\n\r\n1.创建EJB工程。在包com.hm.ejb 下创建一个会话Bean  MyBean(由于会采用工具来生成相关的Remote,Home接口等等最好在名字后加上Bean)IDE环境在创建该类的时候会附加一些用于生成接口的元数据请不要修改它们\r\n\r\npackage com.hm.ejb;\r\nimport java.rmi.RemoteException;\r\nimport javax.ejb.EJBException;\r\nimport javax.ejb.SessionBean;\r\nimport javax.ejb.SessionContext;\r\nimport javax.ejb.CreateException;\r\n\r\npublic class MyBean implements SessionBean {\r\nprivate SessionContext context;\r\npublic MyBean() {}\r\npublic void ejbActivate() throws EJBException, RemoteException {}\r\npublic void ejbPassivate() throws EJBException, RemoteException {}\r\npublic void ejbRemove() throws EJBException, RemoteException {}\r\npublic void setSessionContext(SessionContext newContext)\r\nthrows EJBException {\r\ncontext = newContext;\r\n}\r\npublic void ejbCreate() throws CreateException {}\r\n/**\r\n* An example business method\r\n*\r\n* @ejb.interface-method view-type = \"remote\"\r\n*\r\n* @throws EJBException Thrown if method fails due to system-level\r\nerror.\r\n*/\r\npublic String hello() throws EJBException {\r\nreturn new String(\"你好！的测试EJB！\");\r\n}\r\n}\r\n\r\n使用XDoclet自动生成 META-INF/ejb-jar.xml\r\n\r\n&lt;ejb-jar &gt;\r\n&lt;enterprise-beans&gt;\r\n&lt;session &gt;\r\n&lt;description&gt;&lt;![CDATA[Description for My]]&gt;&lt;/description&gt;\r\n&lt;display-name&gt;Name for My&lt;/display-name&gt;\r\n&lt;ejb-name&gt;My&lt;/ejb-name&gt;\r\n&lt;home&gt;com.hm.interfaces.MyHome&lt;/home&gt;\r\n&lt;remote&gt;com.hm.interfaces.My&lt;/remote&gt;\r\n&lt;ejb-class&gt;com.hm.ejb.MySession&lt;/ejb-class&gt;\r\n&lt;session-type&gt;Stateless&lt;/session-type&gt;\r\n&lt;transaction-type&gt;Container&lt;/transaction-type&gt;\r\n&lt;/session&gt;&lt;/enterprise-beans&gt;\r\n&lt;assembly-descriptor &gt;\r\n&lt;/assembly-descriptor&gt;\r\n&lt;/ejb-jar&gt;\r\n\r\nMETA-INF/weblogic-ejb-jar.xml\r\n\r\n&lt;weblogic-ejb-jar&gt;\r\n&lt;description&gt;&lt;![CDATA[Generated by XDoclet]]&gt;&lt;/description&gt;\r\n&lt;weblogic-enterprise-bean&gt;\r\n&lt;ejb-name&gt;My&lt;/ejb-name&gt;----ebj名对应ejb-jar下的ejb-name\r\n&lt;stateless-session-descriptor&gt;\r\n&lt;/stateless-session-descriptor&gt;\r\n&lt;reference-descriptor&gt;\r\n&lt;/reference-descriptor&gt;\r\n&lt;jndi-name&gt;ejb/My&lt;/jndi-name&gt; ---weblogic设置的jndi名 客户端用这个jndi查找ejb对象\r\n&lt;/weblogic-enterprise-bean&gt;\r\n&lt;/weblogic-ejb-jar&gt;\r\n\r\n由于命名与目录服务是由容器提供的所以这里由weblogic的配置文件weblogic-ejb-jar.xml提供jndi名\r\n\r\n以及Remote接口\r\n\r\npublic interface My\r\nextends javax.ejb.EJBObject\r\n{\r\npublic void replaceWithRealBusinessMethod( )\r\nthrows java.rmi.RemoteException;\r\npublic java.lang.String hello( )\r\nthrows java.rmi.RemoteException;\r\n}\r\n\r\nHome接口\r\n\r\npublic interface MyHome\r\nextends javax.ejb.EJBHome\r\n{\r\npublic static final String COMP_NAME=\"java:comp/env/ejb/My\";\r\npublic static final String JNDI_NAME=\"ejb/My\";\r\npublic com.hm.interfaces.My create()\r\nthrows javax.ejb.CreateException,java.rmi.RemoteException;\r\n}\r\n\r\n然后就可以发布到weblogic服务器(对于安装和部署weblogic就不再赘述) 下面来说一下不同客户端调用时的区别.\r\n\r\n1.使用main方法调用代码如下\r\n\r\nProperties properties = new Properties();\r\nproperties.setProperty(Context.INITIAL_CONTEXT_FACTORY,\r\n\"weblogic.jndi.WLInitialContextFactory\");\r\nproperties.setProperty(Context.PROVIDER_URL, \"t3://localhost:7001\");//设置上下文环境\r\nContext context;\r\ntry {\r\ncontext = new InitialContext(properties);\r\nObject objRef = context.lookup(\"ejb/My\");//查找weblogic下注册的jndi名\r\nif (java.rmi.Remote.class.isAssignableFrom(com.hm.interfaces.MyHome.class)){\r\nobjRef = javax.rmi.PortableRemoteObject.narrow(objRef, com.hm.interfaces.MyHome.class);}\r\nMyHome hwh = (MyHome)objRef;\r\n\r\n//客户端获取了对象的Home接口后调用Home对象的create方法创建EJB对象，容器会根据这个接口生成的My实现类创建一个My对象 这个My对象（hw）就是EJB对象，然后My对象里的业务方法就可以调用了 hw.hello()\r\nMy hw = hwh.create();\r\nString s = hw.hello();\r\n} catch (Exception e) {\r\ne.printStackTrace();\r\n}\r\n\r\n运行成功可以得到如下结果 “你好！测试EJB！\" 备注在控制台调用 java 运行命令时请注意添加 CLASSPATH路径 加载weblogic的jndi工厂类 你可以在weblogic的安装路径如\r\n\r\nE:\\bea\\weblogic81\\server\\lib 找到 weblogic.jar 你可以创建一个 批处理文件 如\r\n\r\nexe.bat\r\n\r\nset classpath=e:\\bea\\WEBLOG~1\\server\\lib\\weblogic.jar;\r\njava com.hm.interfaces.EJBTest\r\n\r\n来运行.\r\n\r\n2.通过servlet来调用。在servlet里可以直接使用上面写到的main方法 只是注意一点tomcat在运行时会自动加载其本身安装文件下的包 Tomcat 6.0\\lib  servlet-api.jar jsp-api.jar其javax/servlet与weblogic.jar下的 javax/servlet冲突因此不能加载weblogic.jar 可以用压缩软件删除weblogic.jar下的javax/servlet 可以解决由于冲突无法加载weblogic.jar的问题.通过servlet调用时可以使用   context.lookup(\"java:comp/env/ejb/My\");这种方式查找jndi需要在web.xml里进行配置具体方法 可查看相关文档.','EJB2 初探','','publish','open','open','','ejb2-%e5%88%9d%e6%8e%a2','','','2013-08-23 13:44:50','2013-08-23 05:44:50','',0,'http://localhost/wordpress-new/?p=44',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (45,1,'2013-08-23 13:44:50','2013-08-23 05:44:50','这里以weblogic8.1_sp6为EJB服务器为平台来初步讲解下如何开发EJB组建 以及客户端如何调用EJB对象。这里我们使用myeclipse8.5作为开发工具具体的开发步骤不会详细记录 这里只记录必要的步骤.\r\n\r\n1.创建EJB工程。在包com.hm.ejb 下创建一个会话Bean  MyBean(由于会采用工具来生成相关的Remote,Home接口等等最好在名字后加上Bean)IDE环境在创建该类的时候会附加一些用于生成接口的元数据请不要修改它们\r\n\r\npackage com.hm.ejb;\r\nimport java.rmi.RemoteException;\r\nimport javax.ejb.EJBException;\r\nimport javax.ejb.SessionBean;\r\nimport javax.ejb.SessionContext;\r\nimport javax.ejb.CreateException;\r\n\r\npublic class MyBean implements SessionBean {\r\nprivate SessionContext context;\r\npublic MyBean() {}\r\npublic void ejbActivate() throws EJBException, RemoteException {}\r\npublic void ejbPassivate() throws EJBException, RemoteException {}\r\npublic void ejbRemove() throws EJBException, RemoteException {}\r\npublic void setSessionContext(SessionContext newContext)\r\nthrows EJBException {\r\ncontext = newContext;\r\n}\r\npublic void ejbCreate() throws CreateException {}\r\n/**\r\n* An example business method\r\n*\r\n* @ejb.interface-method view-type = \"remote\"\r\n*\r\n* @throws EJBException Thrown if method fails due to system-level\r\nerror.\r\n*/\r\npublic String hello() throws EJBException {\r\nreturn new String(\"你好！的测试EJB！\");\r\n}\r\n}\r\n\r\n使用XDoclet自动生成 META-INF/ejb-jar.xml\r\n\r\n&lt;ejb-jar &gt;\r\n&lt;enterprise-beans&gt;\r\n&lt;session &gt;\r\n&lt;description&gt;&lt;![CDATA[Description for My]]&gt;&lt;/description&gt;\r\n&lt;display-name&gt;Name for My&lt;/display-name&gt;\r\n&lt;ejb-name&gt;My&lt;/ejb-name&gt;\r\n&lt;home&gt;com.hm.interfaces.MyHome&lt;/home&gt;\r\n&lt;remote&gt;com.hm.interfaces.My&lt;/remote&gt;\r\n&lt;ejb-class&gt;com.hm.ejb.MySession&lt;/ejb-class&gt;\r\n&lt;session-type&gt;Stateless&lt;/session-type&gt;\r\n&lt;transaction-type&gt;Container&lt;/transaction-type&gt;\r\n&lt;/session&gt;&lt;/enterprise-beans&gt;\r\n&lt;assembly-descriptor &gt;\r\n&lt;/assembly-descriptor&gt;\r\n&lt;/ejb-jar&gt;\r\n\r\nMETA-INF/weblogic-ejb-jar.xml\r\n\r\n&lt;weblogic-ejb-jar&gt;\r\n&lt;description&gt;&lt;![CDATA[Generated by XDoclet]]&gt;&lt;/description&gt;\r\n&lt;weblogic-enterprise-bean&gt;\r\n&lt;ejb-name&gt;My&lt;/ejb-name&gt;----ebj名对应ejb-jar下的ejb-name\r\n&lt;stateless-session-descriptor&gt;\r\n&lt;/stateless-session-descriptor&gt;\r\n&lt;reference-descriptor&gt;\r\n&lt;/reference-descriptor&gt;\r\n&lt;jndi-name&gt;ejb/My&lt;/jndi-name&gt; ---weblogic设置的jndi名 客户端用这个jndi查找ejb对象\r\n&lt;/weblogic-enterprise-bean&gt;\r\n&lt;/weblogic-ejb-jar&gt;\r\n\r\n由于命名与目录服务是由容器提供的所以这里由weblogic的配置文件weblogic-ejb-jar.xml提供jndi名\r\n\r\n以及Remote接口\r\n\r\npublic interface My\r\nextends javax.ejb.EJBObject\r\n{\r\npublic void replaceWithRealBusinessMethod( )\r\nthrows java.rmi.RemoteException;\r\npublic java.lang.String hello( )\r\nthrows java.rmi.RemoteException;\r\n}\r\n\r\nHome接口\r\n\r\npublic interface MyHome\r\nextends javax.ejb.EJBHome\r\n{\r\npublic static final String COMP_NAME=\"java:comp/env/ejb/My\";\r\npublic static final String JNDI_NAME=\"ejb/My\";\r\npublic com.hm.interfaces.My create()\r\nthrows javax.ejb.CreateException,java.rmi.RemoteException;\r\n}\r\n\r\n然后就可以发布到weblogic服务器(对于安装和部署weblogic就不再赘述) 下面来说一下不同客户端调用时的区别.\r\n\r\n1.使用main方法调用代码如下\r\n\r\nProperties properties = new Properties();\r\nproperties.setProperty(Context.INITIAL_CONTEXT_FACTORY,\r\n\"weblogic.jndi.WLInitialContextFactory\");\r\nproperties.setProperty(Context.PROVIDER_URL, \"t3://localhost:7001\");//设置上下文环境\r\nContext context;\r\ntry {\r\ncontext = new InitialContext(properties);\r\nObject objRef = context.lookup(\"ejb/My\");//查找weblogic下注册的jndi名\r\nif (java.rmi.Remote.class.isAssignableFrom(com.hm.interfaces.MyHome.class)){\r\nobjRef = javax.rmi.PortableRemoteObject.narrow(objRef, com.hm.interfaces.MyHome.class);}\r\nMyHome hwh = (MyHome)objRef;\r\n\r\n//客户端获取了对象的Home接口后调用Home对象的create方法创建EJB对象，容器会根据这个接口生成的My实现类创建一个My对象 这个My对象（hw）就是EJB对象，然后My对象里的业务方法就可以调用了 hw.hello()\r\nMy hw = hwh.create();\r\nString s = hw.hello();\r\n} catch (Exception e) {\r\ne.printStackTrace();\r\n}\r\n\r\n运行成功可以得到如下结果 “你好！测试EJB！\" 备注在控制台调用 java 运行命令时请注意添加 CLASSPATH路径 加载weblogic的jndi工厂类 你可以在weblogic的安装路径如\r\n\r\nE:\\bea\\weblogic81\\server\\lib 找到 weblogic.jar 你可以创建一个 批处理文件 如\r\n\r\nexe.bat\r\n\r\nset classpath=e:\\bea\\WEBLOG~1\\server\\lib\\weblogic.jar;\r\njava com.hm.interfaces.EJBTest\r\n\r\n来运行.\r\n\r\n2.通过servlet来调用。在servlet里可以直接使用上面写到的main方法 只是注意一点tomcat在运行时会自动加载其本身安装文件下的包 Tomcat 6.0\\lib  servlet-api.jar jsp-api.jar其javax/servlet与weblogic.jar下的 javax/servlet冲突因此不能加载weblogic.jar 可以用压缩软件删除weblogic.jar下的javax/servlet 可以解决由于冲突无法加载weblogic.jar的问题.通过servlet调用时可以使用   context.lookup(\"java:comp/env/ejb/My\");这种方式查找jndi需要在web.xml里进行配置具体方法 可查看相关文档.','EJB2 初探','','inherit','open','open','','44-revision-v1','','','2013-08-23 13:44:50','2013-08-23 05:44:50','',44,'http://localhost/wordpress-new/?p=45',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (46,1,'2013-08-23 13:45:11','2013-08-23 05:45:11','1．将感情埋藏得太深有时是件坏事。如果一个女人掩饰了对自己所爱的男子的感情，她也许就失去了得到他的机会。 (《傲慢与偏见》)\r\n\r\n2．认识自己的无知是认识世界的最可靠的方法。 (《随笔集》)\r\n\r\n3．生存还是毁灭，这是一个值得思考的问题。 (《哈姆霄特》)\r\n\r\n4． 神要是公然去跟人作对，那是任何人都难以对付的。 (《荷马史诗》)\r\n\r\n5．你以为我贫穷、相貌平平就没有感情吗?我向你发誓，如果上帝赋予我财富和美貌，我会让你无法离开我，就像我现在无法离开你一样。虽然上帝没有这么做，可我们在精神上依然是平等的。(《简.爱》)\r\n\r\n6．大人都学坏了，上帝正考验他们呢，你还没有受考验，你应当照着孩子的想法生活。 (《童年》)\r\n\r\n7，你越没有心肝，就越高升得快，你毫不留情地打击人家，人家就怕你。只能把男男女女当作驿马，把它们骑得筋疲力尽，到了站上丢下来，这样你就能达到欲望的最高峰。 (《高老头》)\r\n\r\n8．我只想证明一件事，就是，那时魔鬼引诱我，后来又告诉我，说我没有权利走那条路，因为我不过是个虱子，和所有其余的人一样。 (《罪与罚》)\r\n\r\n9．你瞧，桑丘.潘沙朋友，那边出现了三十多个大得出奇的巨人。 (《堂.吉诃德》)\r\n\r\n10．我并不愿意你受的苦比我受的还大，希斯克利夫。我只愿我们永远不分离：如果我有一句话使你今后难过，想想我在地下也感到一样的难过，看在我自己的份上，饶恕我吧! (《呼啸山庄》)\r\n\r\n11．幸福的家庭是相同的，不幸的家庭各有各的不同。 (《安娜.卡列尼娜》)\r\n\r\n12．唉，奴隶般的意大利，你哀痛之逆旅，你这暴风雨中没有舵手的孤舟，你不再是各省的主妇，而是妓院! (《神曲》)\r\n\r\n13．善良人在追求中纵然迷惘，却终将意识到有一条正途。(《浮士德》)\r\n\r\n14．钟声又鸣响了……一声又一声，静谧而安详，即使在女人做新娘的那个好月份里，钟声里也总带有秋天的味道。 (《喧嚣与骚动》)\r\n\r\n15．一个人并不是生来要被打败的，你尽可以把他消灭掉，可就是打不败他。 (《老人与海》)\r\n\r\n16．当然，行是行的，这固然很好，可是千万别闹出什么乱子来啊。 (《套中人》)\r\n\r\n17．面包!面包!我们要面包! (《萌芽》)\r\n\r\n18．我从没有爱过这世界，它对我也一样。 (《拜伦诗选》)\r\n\r\n19．爱情应该给人一种自由感，而不是囚禁感。 (《儿子与情人》)\r\n\r\n20．暴风雨将要在那一天，甚至把一些槲树吹倒，一些教堂的高塔要倒塌，一些宫殿也将要动摇! (《海涅诗选》)\r\n\r\n21．自己的行为最惹人耻笑的人，却永远是最先去说别人坏话的人。 (《伪君子》)\r\n\r\n22．这时一种精神上的感慨油然而生，认为人生是由啜泣、抽噎和微笑组成的，而抽噎占了其中绝大部分。(《欧.亨利短篇小说选》)\r\n\r\n23．历史喜爱英勇豪迈的事迹，同时也谴责这种事迹所造成的后果。 (《神秘岛》)\r\n\r\n24．整个下半天，人都听凭羊脂球去思索。不过本来一直称呼她作“夫人”，现在却简单地称呼她作 “小姐”了，谁也不很知道这是为着什么，仿佛她从前在评价当中爬到了某种地位，现在呢，人都想把她从那种地位拉下一级似的，使她明白自己的地位是尚叩摹? (《莫泊桑短篇小说选》)\r\n\r\n25．如果冬天来了，春天还会远吗? 　(《雪莱诗选》)\r\n\r\n26．我明白了，我已经找到了存在的答案，我恶心的答案，我整个生命的答案。其实，我所理解的一切事物都可以归结为荒诞这个根本的东西。(《恶心》)\r\n\r\n27．世界上有这样一些幸福的人，他们把自己的痛苦化作他人的幸福，他们挥泪埋葬了自己在尘世间的希望，它却变成了种子，长出鲜花和香膏，为孤苦伶仃的苦命人医治创伤。(《汤姆叔叔的小屋》)\r\n\r\n28．当格里高.萨姆莎从烦躁不安的梦中醒来时，发现他在床上变成了一个巨大的跳蚤。(《变形记》)\r\n\r\n29．当现实折过来严丝合缝地贴在我们长期的梦想上时，它盖住了梦想，与它混为一体，如同两个同样的图形重叠起来合而为一一样。(《追忆似水年华》)\r\n\r\n30．人与人之间，最可痛心的事莫过于在你认为理应获得善意和友谊的地方，却遭受了烦扰和损害。(《巨人传》)\r\n\r\n31．现在我说的您要特别注意听：在别人心中存在的人，就是这个人的灵魂。这才是您本身，才是您的意识在一生当中赖以呼吸、营养以至陶醉的东西，这也就是您的灵魂、您的不朽和存在于别人身上的您的生命。(《日瓦戈医生》)\r\n\r\n32．美德犹如名香，经燃烧或压榨而其香愈烈，盖幸运最能显露恶德而厄运最能显露美德。(《培根论说文集》)\r\n\r\n33．亲爱的艾妮斯，我出国，为了爱你，我留在国外，为了爱你，我回国，也是为了爱你!(《大卫.科波菲尔》)\r\n\r\n34．强迫经常使热恋的人更加铁心，而从来不能叫他们回心转意。(《阴谋与爱情》)\r\n\r\n35．在各种事物的常理中，爱情是无法改变和阻挡的，因为就本性而言，爱只会自行消亡，任何计谋都难以使它逆转。(《十日谈》)\r\n\r\n36．只要你是天鹅蛋，就是生在养鸡场里也没有什么关系。(《安徒生童话》)\r\n\r\n37．就投机钻营来说，世故的价值永远是无可比拟的。(《死魂灵》)\r\n\r\n38. 谁都可能出个错儿，你在一件事情上越琢磨得多就越容易出错。(《好兵帅克历险记》)\r\n\r\n39．我们经历着生活中突然降临的一切，毫无防备，就像演员进入初排。如果生活中的第一次彩排便是生活本身，那生活有什么价值呢?(《生命中不能承受之轻》)\r\n\r\n40．他发现了人类行为的一大法则，自己还不知道——那就是，为了要使一个大人或小孩极想干某样事情，只需要设法把那件事情弄得不易到手就行了。(《汤姆.索亚历险记》)\r\n\r\n41．对有信仰的人，死是永生之门。(《失乐园》)\r\n\r\n42．有一个传说，说的是有那么一只鸟儿，它一生只唱一次，那歌声比世上所有一切生灵的歌声都更加优美动听。(《荆棘鸟》)\r\n\r\n43．离开一辈子后，他又回到了自己出生的那片土地上。从小到大，他一直是那个地方的目击者。(《尤利西斯》)\r\n\r\n44．同上帝保持联系是一码事，他们都赞同这一点，但让上帝一天二十四小时都待在身边就是另一码事了。(《第二十二条军规》)\r\n\r\n45．在甜蜜的梦乡里，人人都是平等的，但是当太阳升起，生存的斗争重新开始时，人与人之间又是多么的不平等。(《总统先生》)\r\n\r\n46．开发人类智力的矿藏是少不了要由患难来促成的。(《基度山伯爵》)\r\n\r\n47．离你越近的地方，路途越远；最简单的音调，需要最艰苦的练习。(《泰戈尔诗选》)\r\n\r\n48．悲伤使人格外敏锐。(《约翰.克里斯朵夫》\r\n\r\n49．我在女人跟前经常失败，就是由于我太爱她们了。(《忏悔录》)\r\n\r\n50．她睁大一双绝望的眼睛，观看她生活的寂寞。她像沉了船的水手一样，在雾蒙蒙的天边，遥遥寻找白帆的踪影。(《包法利夫人》)\r\n\r\n51．我听见美洲在歌唱，我听见各种不同的颂歌。(《草叶集》) 美文,经典美文\r\n\r\n52．倘若你能使你的心时常赞叹日常生活的神妙，你的苦痛的神妙必不减少于你的欢乐，你要承受你心天的季候，如同你常常承受从田野上度过的四时。(《先知》)\r\n\r\n53．现在我住在波勒兹别墅，这里找不到一点儿灰尘，也没有一件东西摆得不是地方，除了我们，这里再没有别人，我们死了。(《北回归线》)\r\n\r\n54．艳阳高升，原野上的朝露很快便了无痕迹。源氏痛感人生如梦，像朝露一般，愈加万念俱灰。(《源氏物语》)\r\n\r\n55．那些普普通通而毫无特色的罪行才真正令人迷惑，就像—个相貌平凡的人最难以让人辨认—样。(《福尔摩斯探案集》)\r\n\r\n56．你有一处建在房子里面的小池塘吗?在那个小池塘里，你可以随时观察水中生物生活的每一个片断。(《昆虫记》)\r\n\r\n57．不要向井里吐痰，也许你还会来喝井里的水。(《静静的顿河》)\r\n\r\n58．我看到了各个民族彼此敌视，而且默默地，无知地、愚蠢地、甘心地、无辜地在互相残杀。我看到了世界上最聪明的头脑还在发明武器和撰写文章，使这种种敌视和残杀更为巧妙，更为经久。(《西线无战事》)\r\n\r\n59．这张脸同早晨雪天映在镜子中的那张脸一样，红扑扑的。在岛村看来，这又是介于梦幻同现实之间的另一种颜色。(《雪国》)\r\n\r\n60．一个人只要有意志力，就能超越他的环境。(《马丁. 伊登》)\r\n\r\n61．站在痛苦之外规劝受苦的人，是件很容易的事。(《被缚的普罗米修斯》)\r\n\r\n62．感情有理智根本无法理解的理由。(《月亮和六便士》)\r\n\r\n63．世界上一切好东西对于我们，除了加以使用外，实在没有别的好处。　(《鲁滨逊漂流记》)\r\n\r\n64．每当太阳西沉，我坐在河边破旧的码头上，遥望新泽西上方辽阔的天空，我感到似乎有未经开垦的土地，所有的道路，所有的人都在不可思议地走向西部海岸。直到现在我才知道，在衣阿华，小伙子们总是不停地骚动喧闹，因为是那片土地使他们如此无法平静。(《在路上》)\r\n\r\n65。在与法律之前，合乎“自然的”只有狮子的力量，或者动物饥寒时的需要，更简单地用一个字表示，便是“欲”。(《红与黑》)\r\n\r\n66。上天让我们习惯各种事物，就是用它来代替幸福。(《叶甫盖尼.奥涅金》)\r\n\r\n67．一个人哪怕只生活过一天，也可以毫无困难地在监狱里过上一百年。(《局外人》)\r\n\r\n68．往上爬吧，多捞钱吧，进入上层社会，那里准备好了一切。(《美国的悲剧》)\r\n\r\n69．念书不能增添智慧。(《痛症楼》)\r\n\r\n70．不管我活着，还是我死去，我都是一只牛虻，快乐地飞来飞去。　(《牛虻》)\r\n\r\n71．一个人把他整个的一生都押在“女人的爱”那一张牌上头赌博，那张牌输了，他就那样地灰心丧气，弄得自己什么事都不能做，这种人不算一个男人，不过是一个雄性生物。(《父与于》)\r\n\r\n72．这个家庭的历史是一架周而复始无法停息的机器，是一个转动着的轮子，这只齿轮，要不是轴会逐渐不可避免地磨损的话，会永远旋转下去。(《百年孤独》)\r\n\r\n73．现在我只信，首先我是一个人，跟你一样的一个——至少我要学做一个人。(《玩偶之家》)\r\n\r\n74．天才和我们相距仅仅一步。同时代者往往不理解这一步就是千里，后代又盲目相信这千里就是一步。同时代为此而杀了天才，后代又为此而在天才面前焚香。(《侏儒的话》)\r\n\r\n75．遭受苦难的人在承受痛楚时并不能觉察到其剧烈的程度，反倒是过后延绵的折磨最能使其撕心裂肺。　(《红字》)\r\n\r\n76．人最宝贵的是生命，生命属于人只有一次。人的一生应当这样度过：当他回首往事时，不会因虚度年华而悔恨，也不会因碌碌无为而羞耻。这样，临终前他就可以自豪地说：“我已经把自己整个生命和全部精力都献给了世界上最壮丽的事业——为人类的解放而奋斗。”(《钢铁是怎样炼成的》)\r\n\r\n77．凡是有甜美的鸟歌唱的地方，也都有毒蛇嘶嘶地叫。(《德伯家的苔丝》)\r\n\r\n78．凡是想依正路达到这深密境界的人应从幼年起，就倾心向往美的形体。(《文艺对话录》)\r\n\r\n79．友谊就是一切。友谊比才能更重要，比政府更重要，它和家庭几乎是可划等号的。千万别忘记这一点。({教父》)\r\n\r\n80．已经活了七十二岁，依然像是昨天的事：居民点的林阴小路，在歇晌的时间，白人居住区，道旁开满金风花的大街，阗无行人。(《物质生活》)\r\n\r\n81．我明天回塔拉再去想吧。巳那时我就经受得住一切了。明天，我会想出一个办法把他弄回来。毕竟，明天又是另外的一天呢。(《飘》)\r\n\r\n82．盲目可以增加你的勇气，因为你无法看到危险．(《格列佛游记》)\r\n\r\n83．本人系疗养与护理院的居住者。我的护理员在观察我，他几乎每时每刻都监视着我：因为门上有个窥视孔，我的护理员的眼睛是那种棕色的，它不可能看透蓝眼睛的我。(《铁皮鼓》)\r\n\r\n84．每当我追溯自己的青春年华时，那些日子就像是暴风雪之晨的白色雪花一样，被疾风吹得离我而去。(《洛莉塔》)\r\n\r\n85．宽宏大量，是惟一能够照亮伟大灵魂的光芒。(《巴黎圣母院》)\r\n\r\n86．很多年以前，那时我的钱包瘪瘪的，陆地上看来没什么好混的了，干脆下海吧，去在我们这个世界上占绝对面积的大海里逛逛吧! 　(《白鲸》)\r\n\r\n87．我一贯追求的是：在人的肉体与幻想允许的范围内，获得最大限度的真诚和信任，以及对所有的一切尽可能长久的保证。(《镜中微瑕》)\r\n\r\n88．这里有一种无处投诉的罪行。这里有一种眼泪不足以象征的悲哀。这里有一种绝大的失败，足以使我们的一切成功都垮台。(《愤怒的葡萄》)\r\n\r\n89．起来，饥寒交迫的奴隶!起来，全世界受苦的人! 　(《国际歌》)\r\n\r\n90．我是说孩子们都在狂奔，也不知道自己是在往哪儿跑，我得从什么地方出来，把他们捉住。我整天就干这样的事。我只想当个麦田的守望者。我知道这有点异想天开，可我真正喜欢干的就是这个。(《麦田的守望者》)\r\n\r\n91．获取一颗没有被人进攻的经验的心，也就像夺取一座没有守卫的城池一样。(《茶花女》)\r\n\r\n92．他不知道那个梦已经丢在他背后了，丢在这个城市那边那一片无垠的混沌之中不知什么地方了，那里合众国的黑黝黝的田野在夜色中向前伸展。(《了不起的盖茨比》)\r\n\r\n93．四月最残忍，从死了的土地滋生丁香，混杂着回忆和欲望，让春雨挑动着呆钝的根。(《荒原》)\r\n\r\n94．世间的一切虚伪，正像过眼云烟，只有真理才是处世接物的根据。虚伪的黑暗，必为真理的光辉所消灭。(《一千零一夜》)\r\n\r\n95．下面玩什么花样呢?(《发条橙》)\r\n\r\n96．昨晚，我梦见自己又回到了曼陀丽庄园。(《蝴蝶梦》)\r\n\r\n97．我不能想像这样一个人，他认为开棋的时候先走马而不是先走卒对他来说是英勇的壮举，而在象棋指南的某个犄角里占上一席可怜的位置就意味着声名不朽，我不能想像，一个聪明人竟然能够在 10年、20年、30年、40年之中一而再、再而三地把他全部的思维能力都献给一种荒诞的事情——想尽一切办法把木头棋子王赶到木板棋盘的角落里，而自己却没有发狂成为疯子。(《象棋的故事》)\r\n\r\n98．咱家是猫。名字嘛……还没有。(《我是猫》)\r\n\r\n99．挺起英勇的胸脯前进!\r\n\r\n看，无数的旗帜满天飞舞!\r\n\r\n谁在那里向右转?\r\n\r\n向左!\r\n\r\n向左!\r\n\r\n向左!(《马雅可夫斯基诗选》)\r\n\r\n100．水里照出的是自己的脸，内心反映的是自己的为人。(《圣经.旧约》)','100本世界名著浓缩成了100句话','','publish','open','open','','100%e6%9c%ac%e4%b8%96%e7%95%8c%e5%90%8d%e8%91%97%e6%b5%93%e7%bc%a9%e6%88%90%e4%ba%86100%e5%8f%a5%e8%af%9d','','','2013-08-23 13:45:11','2013-08-23 05:45:11','',0,'http://localhost/wordpress-new/?p=46',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (47,1,'2013-08-23 13:45:11','2013-08-23 05:45:11','1．将感情埋藏得太深有时是件坏事。如果一个女人掩饰了对自己所爱的男子的感情，她也许就失去了得到他的机会。 (《傲慢与偏见》)\r\n\r\n2．认识自己的无知是认识世界的最可靠的方法。 (《随笔集》)\r\n\r\n3．生存还是毁灭，这是一个值得思考的问题。 (《哈姆霄特》)\r\n\r\n4． 神要是公然去跟人作对，那是任何人都难以对付的。 (《荷马史诗》)\r\n\r\n5．你以为我贫穷、相貌平平就没有感情吗?我向你发誓，如果上帝赋予我财富和美貌，我会让你无法离开我，就像我现在无法离开你一样。虽然上帝没有这么做，可我们在精神上依然是平等的。(《简.爱》)\r\n\r\n6．大人都学坏了，上帝正考验他们呢，你还没有受考验，你应当照着孩子的想法生活。 (《童年》)\r\n\r\n7，你越没有心肝，就越高升得快，你毫不留情地打击人家，人家就怕你。只能把男男女女当作驿马，把它们骑得筋疲力尽，到了站上丢下来，这样你就能达到欲望的最高峰。 (《高老头》)\r\n\r\n8．我只想证明一件事，就是，那时魔鬼引诱我，后来又告诉我，说我没有权利走那条路，因为我不过是个虱子，和所有其余的人一样。 (《罪与罚》)\r\n\r\n9．你瞧，桑丘.潘沙朋友，那边出现了三十多个大得出奇的巨人。 (《堂.吉诃德》)\r\n\r\n10．我并不愿意你受的苦比我受的还大，希斯克利夫。我只愿我们永远不分离：如果我有一句话使你今后难过，想想我在地下也感到一样的难过，看在我自己的份上，饶恕我吧! (《呼啸山庄》)\r\n\r\n11．幸福的家庭是相同的，不幸的家庭各有各的不同。 (《安娜.卡列尼娜》)\r\n\r\n12．唉，奴隶般的意大利，你哀痛之逆旅，你这暴风雨中没有舵手的孤舟，你不再是各省的主妇，而是妓院! (《神曲》)\r\n\r\n13．善良人在追求中纵然迷惘，却终将意识到有一条正途。(《浮士德》)\r\n\r\n14．钟声又鸣响了……一声又一声，静谧而安详，即使在女人做新娘的那个好月份里，钟声里也总带有秋天的味道。 (《喧嚣与骚动》)\r\n\r\n15．一个人并不是生来要被打败的，你尽可以把他消灭掉，可就是打不败他。 (《老人与海》)\r\n\r\n16．当然，行是行的，这固然很好，可是千万别闹出什么乱子来啊。 (《套中人》)\r\n\r\n17．面包!面包!我们要面包! (《萌芽》)\r\n\r\n18．我从没有爱过这世界，它对我也一样。 (《拜伦诗选》)\r\n\r\n19．爱情应该给人一种自由感，而不是囚禁感。 (《儿子与情人》)\r\n\r\n20．暴风雨将要在那一天，甚至把一些槲树吹倒，一些教堂的高塔要倒塌，一些宫殿也将要动摇! (《海涅诗选》)\r\n\r\n21．自己的行为最惹人耻笑的人，却永远是最先去说别人坏话的人。 (《伪君子》)\r\n\r\n22．这时一种精神上的感慨油然而生，认为人生是由啜泣、抽噎和微笑组成的，而抽噎占了其中绝大部分。(《欧.亨利短篇小说选》)\r\n\r\n23．历史喜爱英勇豪迈的事迹，同时也谴责这种事迹所造成的后果。 (《神秘岛》)\r\n\r\n24．整个下半天，人都听凭羊脂球去思索。不过本来一直称呼她作“夫人”，现在却简单地称呼她作 “小姐”了，谁也不很知道这是为着什么，仿佛她从前在评价当中爬到了某种地位，现在呢，人都想把她从那种地位拉下一级似的，使她明白自己的地位是尚叩摹? (《莫泊桑短篇小说选》)\r\n\r\n25．如果冬天来了，春天还会远吗? 　(《雪莱诗选》)\r\n\r\n26．我明白了，我已经找到了存在的答案，我恶心的答案，我整个生命的答案。其实，我所理解的一切事物都可以归结为荒诞这个根本的东西。(《恶心》)\r\n\r\n27．世界上有这样一些幸福的人，他们把自己的痛苦化作他人的幸福，他们挥泪埋葬了自己在尘世间的希望，它却变成了种子，长出鲜花和香膏，为孤苦伶仃的苦命人医治创伤。(《汤姆叔叔的小屋》)\r\n\r\n28．当格里高.萨姆莎从烦躁不安的梦中醒来时，发现他在床上变成了一个巨大的跳蚤。(《变形记》)\r\n\r\n29．当现实折过来严丝合缝地贴在我们长期的梦想上时，它盖住了梦想，与它混为一体，如同两个同样的图形重叠起来合而为一一样。(《追忆似水年华》)\r\n\r\n30．人与人之间，最可痛心的事莫过于在你认为理应获得善意和友谊的地方，却遭受了烦扰和损害。(《巨人传》)\r\n\r\n31．现在我说的您要特别注意听：在别人心中存在的人，就是这个人的灵魂。这才是您本身，才是您的意识在一生当中赖以呼吸、营养以至陶醉的东西，这也就是您的灵魂、您的不朽和存在于别人身上的您的生命。(《日瓦戈医生》)\r\n\r\n32．美德犹如名香，经燃烧或压榨而其香愈烈，盖幸运最能显露恶德而厄运最能显露美德。(《培根论说文集》)\r\n\r\n33．亲爱的艾妮斯，我出国，为了爱你，我留在国外，为了爱你，我回国，也是为了爱你!(《大卫.科波菲尔》)\r\n\r\n34．强迫经常使热恋的人更加铁心，而从来不能叫他们回心转意。(《阴谋与爱情》)\r\n\r\n35．在各种事物的常理中，爱情是无法改变和阻挡的，因为就本性而言，爱只会自行消亡，任何计谋都难以使它逆转。(《十日谈》)\r\n\r\n36．只要你是天鹅蛋，就是生在养鸡场里也没有什么关系。(《安徒生童话》)\r\n\r\n37．就投机钻营来说，世故的价值永远是无可比拟的。(《死魂灵》)\r\n\r\n38. 谁都可能出个错儿，你在一件事情上越琢磨得多就越容易出错。(《好兵帅克历险记》)\r\n\r\n39．我们经历着生活中突然降临的一切，毫无防备，就像演员进入初排。如果生活中的第一次彩排便是生活本身，那生活有什么价值呢?(《生命中不能承受之轻》)\r\n\r\n40．他发现了人类行为的一大法则，自己还不知道——那就是，为了要使一个大人或小孩极想干某样事情，只需要设法把那件事情弄得不易到手就行了。(《汤姆.索亚历险记》)\r\n\r\n41．对有信仰的人，死是永生之门。(《失乐园》)\r\n\r\n42．有一个传说，说的是有那么一只鸟儿，它一生只唱一次，那歌声比世上所有一切生灵的歌声都更加优美动听。(《荆棘鸟》)\r\n\r\n43．离开一辈子后，他又回到了自己出生的那片土地上。从小到大，他一直是那个地方的目击者。(《尤利西斯》)\r\n\r\n44．同上帝保持联系是一码事，他们都赞同这一点，但让上帝一天二十四小时都待在身边就是另一码事了。(《第二十二条军规》)\r\n\r\n45．在甜蜜的梦乡里，人人都是平等的，但是当太阳升起，生存的斗争重新开始时，人与人之间又是多么的不平等。(《总统先生》)\r\n\r\n46．开发人类智力的矿藏是少不了要由患难来促成的。(《基度山伯爵》)\r\n\r\n47．离你越近的地方，路途越远；最简单的音调，需要最艰苦的练习。(《泰戈尔诗选》)\r\n\r\n48．悲伤使人格外敏锐。(《约翰.克里斯朵夫》\r\n\r\n49．我在女人跟前经常失败，就是由于我太爱她们了。(《忏悔录》)\r\n\r\n50．她睁大一双绝望的眼睛，观看她生活的寂寞。她像沉了船的水手一样，在雾蒙蒙的天边，遥遥寻找白帆的踪影。(《包法利夫人》)\r\n\r\n51．我听见美洲在歌唱，我听见各种不同的颂歌。(《草叶集》) 美文,经典美文\r\n\r\n52．倘若你能使你的心时常赞叹日常生活的神妙，你的苦痛的神妙必不减少于你的欢乐，你要承受你心天的季候，如同你常常承受从田野上度过的四时。(《先知》)\r\n\r\n53．现在我住在波勒兹别墅，这里找不到一点儿灰尘，也没有一件东西摆得不是地方，除了我们，这里再没有别人，我们死了。(《北回归线》)\r\n\r\n54．艳阳高升，原野上的朝露很快便了无痕迹。源氏痛感人生如梦，像朝露一般，愈加万念俱灰。(《源氏物语》)\r\n\r\n55．那些普普通通而毫无特色的罪行才真正令人迷惑，就像—个相貌平凡的人最难以让人辨认—样。(《福尔摩斯探案集》)\r\n\r\n56．你有一处建在房子里面的小池塘吗?在那个小池塘里，你可以随时观察水中生物生活的每一个片断。(《昆虫记》)\r\n\r\n57．不要向井里吐痰，也许你还会来喝井里的水。(《静静的顿河》)\r\n\r\n58．我看到了各个民族彼此敌视，而且默默地，无知地、愚蠢地、甘心地、无辜地在互相残杀。我看到了世界上最聪明的头脑还在发明武器和撰写文章，使这种种敌视和残杀更为巧妙，更为经久。(《西线无战事》)\r\n\r\n59．这张脸同早晨雪天映在镜子中的那张脸一样，红扑扑的。在岛村看来，这又是介于梦幻同现实之间的另一种颜色。(《雪国》)\r\n\r\n60．一个人只要有意志力，就能超越他的环境。(《马丁. 伊登》)\r\n\r\n61．站在痛苦之外规劝受苦的人，是件很容易的事。(《被缚的普罗米修斯》)\r\n\r\n62．感情有理智根本无法理解的理由。(《月亮和六便士》)\r\n\r\n63．世界上一切好东西对于我们，除了加以使用外，实在没有别的好处。　(《鲁滨逊漂流记》)\r\n\r\n64．每当太阳西沉，我坐在河边破旧的码头上，遥望新泽西上方辽阔的天空，我感到似乎有未经开垦的土地，所有的道路，所有的人都在不可思议地走向西部海岸。直到现在我才知道，在衣阿华，小伙子们总是不停地骚动喧闹，因为是那片土地使他们如此无法平静。(《在路上》)\r\n\r\n65。在与法律之前，合乎“自然的”只有狮子的力量，或者动物饥寒时的需要，更简单地用一个字表示，便是“欲”。(《红与黑》)\r\n\r\n66。上天让我们习惯各种事物，就是用它来代替幸福。(《叶甫盖尼.奥涅金》)\r\n\r\n67．一个人哪怕只生活过一天，也可以毫无困难地在监狱里过上一百年。(《局外人》)\r\n\r\n68．往上爬吧，多捞钱吧，进入上层社会，那里准备好了一切。(《美国的悲剧》)\r\n\r\n69．念书不能增添智慧。(《痛症楼》)\r\n\r\n70．不管我活着，还是我死去，我都是一只牛虻，快乐地飞来飞去。　(《牛虻》)\r\n\r\n71．一个人把他整个的一生都押在“女人的爱”那一张牌上头赌博，那张牌输了，他就那样地灰心丧气，弄得自己什么事都不能做，这种人不算一个男人，不过是一个雄性生物。(《父与于》)\r\n\r\n72．这个家庭的历史是一架周而复始无法停息的机器，是一个转动着的轮子，这只齿轮，要不是轴会逐渐不可避免地磨损的话，会永远旋转下去。(《百年孤独》)\r\n\r\n73．现在我只信，首先我是一个人，跟你一样的一个——至少我要学做一个人。(《玩偶之家》)\r\n\r\n74．天才和我们相距仅仅一步。同时代者往往不理解这一步就是千里，后代又盲目相信这千里就是一步。同时代为此而杀了天才，后代又为此而在天才面前焚香。(《侏儒的话》)\r\n\r\n75．遭受苦难的人在承受痛楚时并不能觉察到其剧烈的程度，反倒是过后延绵的折磨最能使其撕心裂肺。　(《红字》)\r\n\r\n76．人最宝贵的是生命，生命属于人只有一次。人的一生应当这样度过：当他回首往事时，不会因虚度年华而悔恨，也不会因碌碌无为而羞耻。这样，临终前他就可以自豪地说：“我已经把自己整个生命和全部精力都献给了世界上最壮丽的事业——为人类的解放而奋斗。”(《钢铁是怎样炼成的》)\r\n\r\n77．凡是有甜美的鸟歌唱的地方，也都有毒蛇嘶嘶地叫。(《德伯家的苔丝》)\r\n\r\n78．凡是想依正路达到这深密境界的人应从幼年起，就倾心向往美的形体。(《文艺对话录》)\r\n\r\n79．友谊就是一切。友谊比才能更重要，比政府更重要，它和家庭几乎是可划等号的。千万别忘记这一点。({教父》)\r\n\r\n80．已经活了七十二岁，依然像是昨天的事：居民点的林阴小路，在歇晌的时间，白人居住区，道旁开满金风花的大街，阗无行人。(《物质生活》)\r\n\r\n81．我明天回塔拉再去想吧。巳那时我就经受得住一切了。明天，我会想出一个办法把他弄回来。毕竟，明天又是另外的一天呢。(《飘》)\r\n\r\n82．盲目可以增加你的勇气，因为你无法看到危险．(《格列佛游记》)\r\n\r\n83．本人系疗养与护理院的居住者。我的护理员在观察我，他几乎每时每刻都监视着我：因为门上有个窥视孔，我的护理员的眼睛是那种棕色的，它不可能看透蓝眼睛的我。(《铁皮鼓》)\r\n\r\n84．每当我追溯自己的青春年华时，那些日子就像是暴风雪之晨的白色雪花一样，被疾风吹得离我而去。(《洛莉塔》)\r\n\r\n85．宽宏大量，是惟一能够照亮伟大灵魂的光芒。(《巴黎圣母院》)\r\n\r\n86．很多年以前，那时我的钱包瘪瘪的，陆地上看来没什么好混的了，干脆下海吧，去在我们这个世界上占绝对面积的大海里逛逛吧! 　(《白鲸》)\r\n\r\n87．我一贯追求的是：在人的肉体与幻想允许的范围内，获得最大限度的真诚和信任，以及对所有的一切尽可能长久的保证。(《镜中微瑕》)\r\n\r\n88．这里有一种无处投诉的罪行。这里有一种眼泪不足以象征的悲哀。这里有一种绝大的失败，足以使我们的一切成功都垮台。(《愤怒的葡萄》)\r\n\r\n89．起来，饥寒交迫的奴隶!起来，全世界受苦的人! 　(《国际歌》)\r\n\r\n90．我是说孩子们都在狂奔，也不知道自己是在往哪儿跑，我得从什么地方出来，把他们捉住。我整天就干这样的事。我只想当个麦田的守望者。我知道这有点异想天开，可我真正喜欢干的就是这个。(《麦田的守望者》)\r\n\r\n91．获取一颗没有被人进攻的经验的心，也就像夺取一座没有守卫的城池一样。(《茶花女》)\r\n\r\n92．他不知道那个梦已经丢在他背后了，丢在这个城市那边那一片无垠的混沌之中不知什么地方了，那里合众国的黑黝黝的田野在夜色中向前伸展。(《了不起的盖茨比》)\r\n\r\n93．四月最残忍，从死了的土地滋生丁香，混杂着回忆和欲望，让春雨挑动着呆钝的根。(《荒原》)\r\n\r\n94．世间的一切虚伪，正像过眼云烟，只有真理才是处世接物的根据。虚伪的黑暗，必为真理的光辉所消灭。(《一千零一夜》)\r\n\r\n95．下面玩什么花样呢?(《发条橙》)\r\n\r\n96．昨晚，我梦见自己又回到了曼陀丽庄园。(《蝴蝶梦》)\r\n\r\n97．我不能想像这样一个人，他认为开棋的时候先走马而不是先走卒对他来说是英勇的壮举，而在象棋指南的某个犄角里占上一席可怜的位置就意味着声名不朽，我不能想像，一个聪明人竟然能够在 10年、20年、30年、40年之中一而再、再而三地把他全部的思维能力都献给一种荒诞的事情——想尽一切办法把木头棋子王赶到木板棋盘的角落里，而自己却没有发狂成为疯子。(《象棋的故事》)\r\n\r\n98．咱家是猫。名字嘛……还没有。(《我是猫》)\r\n\r\n99．挺起英勇的胸脯前进!\r\n\r\n看，无数的旗帜满天飞舞!\r\n\r\n谁在那里向右转?\r\n\r\n向左!\r\n\r\n向左!\r\n\r\n向左!(《马雅可夫斯基诗选》)\r\n\r\n100．水里照出的是自己的脸，内心反映的是自己的为人。(《圣经.旧约》)','100本世界名著浓缩成了100句话','','inherit','open','open','','46-revision-v1','','','2013-08-23 13:45:11','2013-08-23 05:45:11','',46,'http://localhost/wordpress-new/?p=47',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (48,1,'2013-08-23 13:45:35','2013-08-23 05:45:35','1.EJB有三类Bean 会话Bean 实体Bean 消息Bean\r\n\r\n2.会话Bean 分为 无状态和有状态Bean 区别在于有状态Bean可以带属性 如用户的id 用户的名称username。有状态Bean会保持其属性值并由容器钝化和激活。配置有无状态Bean是由配置文件 ejb-jar.xml里配置 &lt;session-type&gt;Stateless | Stateful&lt;/session-type&gt;\r\n\r\n3.实体Bean可以表示成数据库中一行记录的对象类他 不参与具体的业务逻辑 具体的业务逻辑又会话Bean来控制.\r\n\r\n4.对于有状态Bean是很耗资源的 对于长时间不使用的有状态会话Bean容器会对其进行钝化并存储在外存里.等待客户端重新对其进行访问 然后重新激活.\r\n\r\n5.对于无状态Bean 容器会为其创建一个Bean池 客户端访问时 容器会从里随机获取已经实例化的无状态Bean提供给客户端调用。因此无状态Bean可以提供几百的用户使用，当然如果池中的对象不够时，容器会自动扩大池的大小创建新的Bean\r\n\r\n6.事务的管理。实体Bean是通过容器来管理事务的 且只能由容器来管理 CMT。对于会话和消息Bean可以通过容器或者Bean来管理事务。Bean管理事务也就是自身来决定事务的处理，也就是通过JTA（Java Transaction API Java事务接口）以编程的方式来控制事务的ACID准则。因此使用CMT来管理的Bean无法使用 JTA (任何地方)\r\n\r\n总结：当前对于ejb2来说已经很少采用了 一般来说都是采用第3方ORM组件来实现如hibernate而EJB真正的价值是在于通过RMI-IIOP技术实现分布式。也就是说 实体Bean由ORM框架来实现 客户端通过无状态会话Bean直接操作简单的POJO与ORM实现持久化。当前现在也有很多框架提供分布式的远程服务如Hessian等','EJB 摘要','','publish','open','open','','ejb-%e6%91%98%e8%a6%81','','','2013-08-23 13:45:35','2013-08-23 05:45:35','',0,'http://localhost/wordpress-new/?p=48',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (49,1,'2013-08-23 13:45:35','2013-08-23 05:45:35','1.EJB有三类Bean 会话Bean 实体Bean 消息Bean\r\n\r\n2.会话Bean 分为 无状态和有状态Bean 区别在于有状态Bean可以带属性 如用户的id 用户的名称username。有状态Bean会保持其属性值并由容器钝化和激活。配置有无状态Bean是由配置文件 ejb-jar.xml里配置 &lt;session-type&gt;Stateless | Stateful&lt;/session-type&gt;\r\n\r\n3.实体Bean可以表示成数据库中一行记录的对象类他 不参与具体的业务逻辑 具体的业务逻辑又会话Bean来控制.\r\n\r\n4.对于有状态Bean是很耗资源的 对于长时间不使用的有状态会话Bean容器会对其进行钝化并存储在外存里.等待客户端重新对其进行访问 然后重新激活.\r\n\r\n5.对于无状态Bean 容器会为其创建一个Bean池 客户端访问时 容器会从里随机获取已经实例化的无状态Bean提供给客户端调用。因此无状态Bean可以提供几百的用户使用，当然如果池中的对象不够时，容器会自动扩大池的大小创建新的Bean\r\n\r\n6.事务的管理。实体Bean是通过容器来管理事务的 且只能由容器来管理 CMT。对于会话和消息Bean可以通过容器或者Bean来管理事务。Bean管理事务也就是自身来决定事务的处理，也就是通过JTA（Java Transaction API Java事务接口）以编程的方式来控制事务的ACID准则。因此使用CMT来管理的Bean无法使用 JTA (任何地方)\r\n\r\n总结：当前对于ejb2来说已经很少采用了 一般来说都是采用第3方ORM组件来实现如hibernate而EJB真正的价值是在于通过RMI-IIOP技术实现分布式。也就是说 实体Bean由ORM框架来实现 客户端通过无状态会话Bean直接操作简单的POJO与ORM实现持久化。当前现在也有很多框架提供分布式的远程服务如Hessian等','EJB 摘要','','inherit','open','open','','48-revision-v1','','','2013-08-23 13:45:35','2013-08-23 05:45:35','',48,'http://localhost/wordpress-new/?p=49',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (50,1,'2013-08-23 13:46:10','2013-08-23 05:46:10','BLob 与CLob做为大数据类型用于存放比较大的数据如 用户的图片 ，文档等等。BLOB用于存储二进制流 而CLOB则是用于存储大字符的 因此在处理这两种大数据类型时 如BLOB不能实例化 而是需要从流里读取 如oracle里 读取一张图片时 需要通过流读取BLOB对象里的数据 而不是直接获取它 对于在远程的情况下 如 2个JVM时 需要将读取的Stream流转换成字节数组byte[]并传递到客户端\r\n\r\n如从运行在tomcat环境下的servlet读取运行在weblogic环境下的BLOB对象(两者不是同一个JVM)在EJB服务器端需要将 流 转换成byte\r\n\r\nbyte[] data = blobStream.read(); 并传递data给web端\r\n\r\n读取BLOB数据很简单 而如果要插入一条二进制的数据\r\n\r\n则需要优先插入一条空的BLOB数据列 从文件或者网络读取一段二进制流数据 写入该条数据列 而不是直接创建BLOB实例(也无法创建实例)只能从流里获取 并更新这条数据 当然如果 你是使用ORM框架来处理 插入二进制数据的话 如hibernate 那会更加方便','oracle 大数据 Blob Clob','','publish','open','open','','oracle-%e5%a4%a7%e6%95%b0%e6%8d%ae-blob-clob','','','2013-08-23 13:46:10','2013-08-23 05:46:10','',0,'http://localhost/wordpress-new/?p=50',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (51,1,'2013-08-23 13:46:10','2013-08-23 05:46:10','BLob 与CLob做为大数据类型用于存放比较大的数据如 用户的图片 ，文档等等。BLOB用于存储二进制流 而CLOB则是用于存储大字符的 因此在处理这两种大数据类型时 如BLOB不能实例化 而是需要从流里读取 如oracle里 读取一张图片时 需要通过流读取BLOB对象里的数据 而不是直接获取它 对于在远程的情况下 如 2个JVM时 需要将读取的Stream流转换成字节数组byte[]并传递到客户端\r\n\r\n如从运行在tomcat环境下的servlet读取运行在weblogic环境下的BLOB对象(两者不是同一个JVM)在EJB服务器端需要将 流 转换成byte\r\n\r\nbyte[] data = blobStream.read(); 并传递data给web端\r\n\r\n读取BLOB数据很简单 而如果要插入一条二进制的数据\r\n\r\n则需要优先插入一条空的BLOB数据列 从文件或者网络读取一段二进制流数据 写入该条数据列 而不是直接创建BLOB实例(也无法创建实例)只能从流里获取 并更新这条数据 当然如果 你是使用ORM框架来处理 插入二进制数据的话 如hibernate 那会更加方便','oracle 大数据 Blob Clob','','inherit','open','open','','50-revision-v1','','','2013-08-23 13:46:10','2013-08-23 05:46:10','',50,'http://localhost/wordpress-new/?p=51',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (52,1,'2013-08-23 13:46:53','2013-08-23 05:46:53','这篇文档记录了如何在Weblogic下使用JMS 首先你可以根据一些文档如官方的BEA文档查看如何使用weblogic 设置JMS服务 当前有很多种JMS消息中间件 如\r\n\r\nApache ActiveMQ ，OpenJMS，Weblogic JMS Server ,IBM MQ 由于大多数J2ee应用程序采用Weblogic作为服务器因此这里以weblogic作为例子来简介如何实现JMS 。\r\n\r\n由于JMS基本上由各大厂商提供  而作为开发人员则需要实现如何使用中间件发送和接收消息。当然发送和接收都是采用j2ee提供的统一规范API JMS（API）来与各中间件进行通信。以weblogic作为例子如下。\r\n\r\n1.首先你需要创建一个域如myserver 并启动weblogic服务 你可以在左侧的菜单栏下找到services一栏 这一栏提供了很多服务如 JNDI jdbc datasource pool jms 创建jms跟创建jdbc一样简单如果有不清楚的地方你可以查看BEA的官方文档\r\n\r\nservices/jms/connection factories 在这一栏创建 JMS工厂 以及他的JNDI名字 如 JMSConnectionFactory 并选择你当前创建的域myserver作为该JMS的管理器\r\n\r\nservices/jms/stores 这一栏可以设置JMS的持久性 即管理的消息存储在文件中或是数据库里\r\n\r\nservices/jms/servers 这一栏创建JMS的服务器 如 JMSServer\r\n\r\nservices/jms/servers/JMSServer 在创建的服务器下JMSServer  创建名字与JNDI名 JMSQueue\r\n\r\n至此JMS服务器就创建完毕 JMS服务器由weblogic服务器自行管理你可以查看官方文档对JMS的性能以及属性进行配置及调整。当前创建的是一个JMS中间件服务器由它负责管理消息 当前JMS支持 PTP点对点以及 订阅的消息传递方式.这里以PTP点对点异步发送和接收消息为例来看看JMS的如何工作的。\r\n\r\n1.消息发送端\r\n\r\npublic class JMSSend {\r\npublic final static String JNDI_FACTORY=\"weblogic.jndi.WLInitialContextFactory\"; //jndi上下文环境\r\npublic final static String PROVIDER_URL=\" t3://localhost:7001\";//jndi查找的上下文地址\r\npublic final static String JMS_FACTORY=\"JMSConnectionFactory\";//设置的JMS连接工厂JNDI名对应weblogic实现的JMS\r\npublic final static String QUEUE=\"JMSQueue\";//设置的JMS队列的JNDI名\r\nprivate QueueConnectionFactory qconFactory;\r\nprivate QueueConnection qcon;\r\nprivate QueueSession qsession;\r\nprivate QueueSender qsender;\r\nprivate Queue queue;\r\nprivate TextMessage msg;\r\n\r\npublic void init(Context ctx, String queueName)\r\nthrows NamingException, JMSException\r\n{//初始化\r\nqconFactory = (QueueConnectionFactory) ctx.lookup(JMS_FACTORY);//根据jndi查找服务器对应实现的工厂类\r\nqcon = qconFactory.createQueueConnection();//创建连接\r\nqsession = qcon.createQueueSession(false, QueueSession.AUTO_ACKNOWLEDGE);//设置事务\r\nqueue = (Queue) ctx.lookup(queueName);//根据jndi名查找创建的队列名字\r\nqsender = qsession.createSender(queue);//创建发起端\r\nmsg = qsession.createTextMessage();//创建文本消息器\r\nqcon.start();//启动连接\r\nSystem.out.println(\"yes the queue is ready\");\r\n}\r\n\r\npublic void send(String message) throws JMSException {\r\nmsg.setText(message);//这里设置发送的信息\r\nqsender.send(msg);//发送 发送给JMS服务器 由weblogic服务器管理 处于队列中 等待接收方接收\r\n}\r\n\r\npublic void close() throws JMSException {\r\nqsender.close();\r\nqsession.close();\r\nqcon.close();//关闭资源\r\n}\r\n\r\npublic static void main(String[] args) throws Exception {\r\nInitialContext ic = getInitialContext(); //运行程序初始化\r\nJMSSend qs = new JMSSend();\r\nqs.init(ic, QUEUE);//初始化\r\nreadAndSend(qs);\r\nqs.close();//关闭\r\n}\r\n\r\nprivate static void readAndSend(JMSSend qs)\r\nthrows IOException, JMSException\r\n{\r\nBufferedReader msgStream = new BufferedReader(new InputStreamReader(System.in));\r\nString line=null;\r\nboolean quitNow = false;\r\ndo {\r\nSystem.out.print(\"Enter message (\\\"quit\\\" to quit): \");\r\nline = msgStream.readLine();\r\nif (line != null &amp;&amp; line.trim().length() != 0) {\r\nqs.send(line);\r\nSystem.out.println(\"JMS Message Sent: \"+line+\"\\n\");\r\nquitNow = line.equalsIgnoreCase(\"quit\");\r\n}\r\n} while (! quitNow);\r\n\r\n}\r\n\r\nprivate static InitialContext getInitialContext()\r\nthrows NamingException\r\n{\r\nHashtable env = new Hashtable();\r\nenv.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);\r\nenv.put(Context.PROVIDER_URL, PROVIDER_URL);\r\nreturn new InitialContext(env);//设置到查找上下文的环境\r\n}\r\n}\r\n\r\n2.消息接收端 接收方的初始化代码与发起方基本上是一致的 如果是异步的需要实现MessageListener接口的方法\r\n\r\npublic class QueueReceive implements MessageListener {\r\npublic final static String JNDI_FACTORY = \"weblogic.jndi.WLInitialContextFactory\";\r\npublic final static String PROVIDER_URL = \" t3://localhost:7001\";\r\npublic final static String JMS_FACTORY = \"JMSConnectionFactory\";\r\npublic final static String QUEUE = \"JMSQueue\";\r\nprivate QueueConnectionFactory qconFactory;\r\nprivate QueueConnection qcon;\r\nprivate QueueSession qsession;\r\nprivate QueueReceiver qreceiver;\r\nprivate Queue queue;\r\nprivate boolean quit = false;\r\n\r\npublic void onMessage(Message msg) {//接口实现的方法\r\ntry {\r\nString msgText;\r\nif (msg instanceof TextMessage) {\r\nmsgText = ((TextMessage) msg).getText();\r\n} else {msgText = msg.toString();}\r\nSystem.out.println(\"Message Received: \" + msgText);\r\nif (msgText.equalsIgnoreCase(\"quit\")) {\r\nsynchronized (this) {\r\nquit = true;\r\nthis.notifyAll();}}\r\n} catch (JMSException jmse) {jmse.printStackTrace();}\r\n}\r\n\r\npublic void init(Context ctx, String queueName) throws NamingException,\r\nJMSException {\r\nqconFactory = (QueueConnectionFactory) ctx.lookup(JMS_FACTORY);\r\nqcon = qconFactory.createQueueConnection();\r\nqsession = qcon.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\r\nqueue = (Queue) ctx.lookup(queueName);\r\nqreceiver = qsession.createReceiver(queue);//这里是接收不是 发送\r\nqreceiver.setMessageListener(this);//设置获取消息的处理方法\r\nqcon.start();\r\n}\r\n\r\npublic void close() throws JMSException {\r\nqreceiver.close();\r\nqsession.close();\r\nqcon.close();\r\n}\r\n\r\npublic static void main(String[] args) throws Exception {\r\nInitialContext ic = getInitialContext();\r\nQueueReceive qr = new QueueReceive();\r\nqr.init(ic, QUEUE);\r\nSystem.out.println(\"JMS Ready To Receive Messages (To quit, send a \\\"quit\\\" message).\");\r\nsynchronized (qr) {\r\nwhile (!qr.quit) {\r\ntry {qr.wait();\r\n} catch (InterruptedException ie) {}}}\r\nqr.close();\r\n}\r\n\r\nprivate static InitialContext getInitialContext() throws NamingException {\r\nHashtable env = new Hashtable();\r\nenv.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);\r\nenv.put(Context.PROVIDER_URL, PROVIDER_URL);\r\nreturn new InitialContext(env);\r\n}\r\n}\r\n\r\n备注由于queue队列是线程的因此 在接收消息的时候 需要考虑 线程是否安全的问题因此需要采用同步synchronized 当前的例子由于采用boolean quit标记 判断是否退出接收消息。因此对quit的访问需要进行同步 即对 qr对象进行同步 如果不同步则会多次运行  while (!qr.quit) 造成线程不安全','JMS 简介','','publish','open','open','','jms-%e7%ae%80%e4%bb%8b','','','2013-08-23 13:46:53','2013-08-23 05:46:53','',0,'http://localhost/wordpress-new/?p=52',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (53,1,'2013-08-23 13:46:53','2013-08-23 05:46:53','这篇文档记录了如何在Weblogic下使用JMS 首先你可以根据一些文档如官方的BEA文档查看如何使用weblogic 设置JMS服务 当前有很多种JMS消息中间件 如\r\n\r\nApache ActiveMQ ，OpenJMS，Weblogic JMS Server ,IBM MQ 由于大多数J2ee应用程序采用Weblogic作为服务器因此这里以weblogic作为例子来简介如何实现JMS 。\r\n\r\n由于JMS基本上由各大厂商提供  而作为开发人员则需要实现如何使用中间件发送和接收消息。当然发送和接收都是采用j2ee提供的统一规范API JMS（API）来与各中间件进行通信。以weblogic作为例子如下。\r\n\r\n1.首先你需要创建一个域如myserver 并启动weblogic服务 你可以在左侧的菜单栏下找到services一栏 这一栏提供了很多服务如 JNDI jdbc datasource pool jms 创建jms跟创建jdbc一样简单如果有不清楚的地方你可以查看BEA的官方文档\r\n\r\nservices/jms/connection factories 在这一栏创建 JMS工厂 以及他的JNDI名字 如 JMSConnectionFactory 并选择你当前创建的域myserver作为该JMS的管理器\r\n\r\nservices/jms/stores 这一栏可以设置JMS的持久性 即管理的消息存储在文件中或是数据库里\r\n\r\nservices/jms/servers 这一栏创建JMS的服务器 如 JMSServer\r\n\r\nservices/jms/servers/JMSServer 在创建的服务器下JMSServer  创建名字与JNDI名 JMSQueue\r\n\r\n至此JMS服务器就创建完毕 JMS服务器由weblogic服务器自行管理你可以查看官方文档对JMS的性能以及属性进行配置及调整。当前创建的是一个JMS中间件服务器由它负责管理消息 当前JMS支持 PTP点对点以及 订阅的消息传递方式.这里以PTP点对点异步发送和接收消息为例来看看JMS的如何工作的。\r\n\r\n1.消息发送端\r\n\r\npublic class JMSSend {\r\npublic final static String JNDI_FACTORY=\"weblogic.jndi.WLInitialContextFactory\"; //jndi上下文环境\r\npublic final static String PROVIDER_URL=\" t3://localhost:7001\";//jndi查找的上下文地址\r\npublic final static String JMS_FACTORY=\"JMSConnectionFactory\";//设置的JMS连接工厂JNDI名对应weblogic实现的JMS\r\npublic final static String QUEUE=\"JMSQueue\";//设置的JMS队列的JNDI名\r\nprivate QueueConnectionFactory qconFactory;\r\nprivate QueueConnection qcon;\r\nprivate QueueSession qsession;\r\nprivate QueueSender qsender;\r\nprivate Queue queue;\r\nprivate TextMessage msg;\r\n\r\npublic void init(Context ctx, String queueName)\r\nthrows NamingException, JMSException\r\n{//初始化\r\nqconFactory = (QueueConnectionFactory) ctx.lookup(JMS_FACTORY);//根据jndi查找服务器对应实现的工厂类\r\nqcon = qconFactory.createQueueConnection();//创建连接\r\nqsession = qcon.createQueueSession(false, QueueSession.AUTO_ACKNOWLEDGE);//设置事务\r\nqueue = (Queue) ctx.lookup(queueName);//根据jndi名查找创建的队列名字\r\nqsender = qsession.createSender(queue);//创建发起端\r\nmsg = qsession.createTextMessage();//创建文本消息器\r\nqcon.start();//启动连接\r\nSystem.out.println(\"yes the queue is ready\");\r\n}\r\n\r\npublic void send(String message) throws JMSException {\r\nmsg.setText(message);//这里设置发送的信息\r\nqsender.send(msg);//发送 发送给JMS服务器 由weblogic服务器管理 处于队列中 等待接收方接收\r\n}\r\n\r\npublic void close() throws JMSException {\r\nqsender.close();\r\nqsession.close();\r\nqcon.close();//关闭资源\r\n}\r\n\r\npublic static void main(String[] args) throws Exception {\r\nInitialContext ic = getInitialContext(); //运行程序初始化\r\nJMSSend qs = new JMSSend();\r\nqs.init(ic, QUEUE);//初始化\r\nreadAndSend(qs);\r\nqs.close();//关闭\r\n}\r\n\r\nprivate static void readAndSend(JMSSend qs)\r\nthrows IOException, JMSException\r\n{\r\nBufferedReader msgStream = new BufferedReader(new InputStreamReader(System.in));\r\nString line=null;\r\nboolean quitNow = false;\r\ndo {\r\nSystem.out.print(\"Enter message (\\\"quit\\\" to quit): \");\r\nline = msgStream.readLine();\r\nif (line != null &amp;&amp; line.trim().length() != 0) {\r\nqs.send(line);\r\nSystem.out.println(\"JMS Message Sent: \"+line+\"\\n\");\r\nquitNow = line.equalsIgnoreCase(\"quit\");\r\n}\r\n} while (! quitNow);\r\n\r\n}\r\n\r\nprivate static InitialContext getInitialContext()\r\nthrows NamingException\r\n{\r\nHashtable env = new Hashtable();\r\nenv.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);\r\nenv.put(Context.PROVIDER_URL, PROVIDER_URL);\r\nreturn new InitialContext(env);//设置到查找上下文的环境\r\n}\r\n}\r\n\r\n2.消息接收端 接收方的初始化代码与发起方基本上是一致的 如果是异步的需要实现MessageListener接口的方法\r\n\r\npublic class QueueReceive implements MessageListener {\r\npublic final static String JNDI_FACTORY = \"weblogic.jndi.WLInitialContextFactory\";\r\npublic final static String PROVIDER_URL = \" t3://localhost:7001\";\r\npublic final static String JMS_FACTORY = \"JMSConnectionFactory\";\r\npublic final static String QUEUE = \"JMSQueue\";\r\nprivate QueueConnectionFactory qconFactory;\r\nprivate QueueConnection qcon;\r\nprivate QueueSession qsession;\r\nprivate QueueReceiver qreceiver;\r\nprivate Queue queue;\r\nprivate boolean quit = false;\r\n\r\npublic void onMessage(Message msg) {//接口实现的方法\r\ntry {\r\nString msgText;\r\nif (msg instanceof TextMessage) {\r\nmsgText = ((TextMessage) msg).getText();\r\n} else {msgText = msg.toString();}\r\nSystem.out.println(\"Message Received: \" + msgText);\r\nif (msgText.equalsIgnoreCase(\"quit\")) {\r\nsynchronized (this) {\r\nquit = true;\r\nthis.notifyAll();}}\r\n} catch (JMSException jmse) {jmse.printStackTrace();}\r\n}\r\n\r\npublic void init(Context ctx, String queueName) throws NamingException,\r\nJMSException {\r\nqconFactory = (QueueConnectionFactory) ctx.lookup(JMS_FACTORY);\r\nqcon = qconFactory.createQueueConnection();\r\nqsession = qcon.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\r\nqueue = (Queue) ctx.lookup(queueName);\r\nqreceiver = qsession.createReceiver(queue);//这里是接收不是 发送\r\nqreceiver.setMessageListener(this);//设置获取消息的处理方法\r\nqcon.start();\r\n}\r\n\r\npublic void close() throws JMSException {\r\nqreceiver.close();\r\nqsession.close();\r\nqcon.close();\r\n}\r\n\r\npublic static void main(String[] args) throws Exception {\r\nInitialContext ic = getInitialContext();\r\nQueueReceive qr = new QueueReceive();\r\nqr.init(ic, QUEUE);\r\nSystem.out.println(\"JMS Ready To Receive Messages (To quit, send a \\\"quit\\\" message).\");\r\nsynchronized (qr) {\r\nwhile (!qr.quit) {\r\ntry {qr.wait();\r\n} catch (InterruptedException ie) {}}}\r\nqr.close();\r\n}\r\n\r\nprivate static InitialContext getInitialContext() throws NamingException {\r\nHashtable env = new Hashtable();\r\nenv.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);\r\nenv.put(Context.PROVIDER_URL, PROVIDER_URL);\r\nreturn new InitialContext(env);\r\n}\r\n}\r\n\r\n备注由于queue队列是线程的因此 在接收消息的时候 需要考虑 线程是否安全的问题因此需要采用同步synchronized 当前的例子由于采用boolean quit标记 判断是否退出接收消息。因此对quit的访问需要进行同步 即对 qr对象进行同步 如果不同步则会多次运行  while (!qr.quit) 造成线程不安全','JMS 简介','','inherit','open','open','','52-revision-v1','','','2013-08-23 13:46:53','2013-08-23 05:46:53','',52,'http://localhost/wordpress-new/?p=53',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (54,1,'2013-08-23 13:47:26','2013-08-23 05:47:26','XFire 概述\r\n\r\nXFire 是 codeHaus 组织提供的一个开源框架，它构建了 POJO 和 SOA 之间的桥梁，主要特性就是支持将 POJO 通过非常简单的方式发布成 Web 服务，这种处理方式不仅充分发挥了 POJO 的作用，简化了 Java 应用转化为 Web 服务的步骤和过程，也直接降低了 SOA 的实现难度，为企业转向 SOA 架构提供了一种简单可行的方式。\r\n\r\nXFire 目前最新的版本是 1.2.2，目前支持的特性主要包括：\r\n支持将 Web 服务绑定到 POJO、XMLBeans、JAXB1.1、JAXB2.0 和 Castor；\r\n支持基于 HTTP、JMS、XMPP 等多种协议访问 Web 服务；\r\n支持多种 Web 服务业界重要标准如 SOAP、WSDL、Web 服务寻址（WS-Addressing）、Web 服务安全（WS-Security）等；\r\n支持 JSR181，可以通过 JDK5 配置 Web 服务；\r\n高性能的 SOAP 实现；\r\n服务器端、客户端代码辅助生成；\r\n对 Spring、Pico、Plexus 等项目的支持等\r\n\r\n以tomcat服务器为例web服务文件结构为\r\n\r\nweb.xml\r\n\r\n&lt;servlet&gt;\r\n&lt;servlet-name&gt;XFireServlet&lt;/servlet-name&gt;\r\n&lt;servlet-class&gt;org.codehaus.xfire.transport.http.XFireConfigurableServlet&lt;/servlet-class&gt;\r\n&lt;load-on-startup&gt;0&lt;/load-on-startup&gt;\r\n&lt;/servlet&gt;\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;XFireServlet&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n\r\n在你的web程序下 如 webapps\\sumMethod\\WEB-INF\\classes\\META-INF\\xfire\r\n\r\n放置配置web服务文件 services.xml\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;beans xmlns=\"http://xfire.codehaus.org/config/1.0\"&gt;\r\n\r\n&lt;service&gt;\r\n&lt;name&gt;GetListService&lt;/name&gt;\r\n&lt;serviceClass&gt;org.hm.service.IGetListService&lt;/serviceClass&gt;\r\n&lt;implementationClass&gt;\r\norg.hm.service.GetListServiceImpl\r\n&lt;/implementationClass&gt;\r\n&lt;style&gt;wrapped&lt;/style&gt;\r\n&lt;use&gt;literal&lt;/use&gt;\r\n&lt;scope&gt;application&lt;/scope&gt;\r\n&lt;/service&gt;&lt;/beans&gt;\r\n\r\n你的接口org.hm.service.IGetListService\r\n\r\npublic interface IGetListService {\r\npublic List&lt;Book&gt; getBook(String name);\r\n}\r\n\r\n你的实现类  org.hm.service.GetListServiceImpl\r\n\r\npublic class GetListServiceImpl implements IGetListService {\r\npublic List&lt;Book&gt; getBook(String name) {\r\nList&lt;Book&gt; arr = new ArrayList&lt;Book&gt;();\r\nBook bk = new Book();//只能使用默认的构造函数 采用set方法赋值\r\nbk.setName(name);\r\narr.add(bk);\r\nreturn arr;\r\n}\r\n}\r\n\r\nxfire支持返回List,map自定义JavaBean返回数据必须可以序列化和反序列化\r\n如果返回的数据类型是自定义的javaBean，则需要声明webservice的数据返回类型 方法  getBook 返回集合对象Book 如果定义的接口中方法的返回值是自定义的JavaBean则需要声明webservice服务的返回值。例如返回值是User则需要在webservice接口同目录下新建一个xml文件名称为：\r\n“接口名.aegis.xml”，内容如下 IGetListService.aegis.xml\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;mappings&gt;\r\n&lt;mapping&gt;\r\n&lt;method name=\"getBook\"&gt;\r\n&lt;return-type componentType=\"org.hm.service.Book\"/&gt;\r\n&lt;/method&gt;\r\n&lt;/mapping&gt;\r\n&lt;/mappings&gt;\r\n\r\n接下来就可以发布该web服务了\r\n\r\n下面是测试的客户端\r\n\r\npublic static void main(String[] args) throws Exception {\r\nService srvcModel = new ObjectServiceFactory().create(IGetListService.class);\r\nXFireProxyFactory factory = new XFireProxyFactory(XFireFactory.newInstance().getXFire());\r\nString url = \"http://localhost:8081/sumMethod/services/GetListService\";//注意没有后缀?wsdl\r\ntry {\r\nIGetListService srvc = (IGetListService) factory.create(srvcModel,url);\r\nList&lt;Book&gt; li = srvc.getBook(\"yellow\");\r\nSystem.out.println(li.get(0).getName());\r\n} catch (MalformedURLException e) {\r\ne.printStackTrace();\r\n}\r\n}\r\n\r\n控制台会显示: yellow\r\n\r\n这里只是xfire的简单入门介绍  xfire还提供客户端验证用户密码等安全措施 对于更复杂的返回对象都需要进行配置 如果需要了解更详细的信息可以查看官方文档\r\n\r\n备注  Apache CXF = Celtix + XFire，Apache CXF 的前身叫 Apache CeltiXfire，现在已经正式更名为 Apache CXF 了，以下简称为 CXF。CXF 继承了 Celtix 和 XFire 两大开源项目的精华，提供了对 JAX-WS 全面的支持，并且提供了多种 Binding 、DataBinding、Transport 以及各种 Format 的支持，并且可以根据实际项目的需要，采用代码优先（Code First）或者 WSDL 优先（WSDL First）来轻松地实现 Web Services 的发布和使用。目前它仍只是 Apache 的一个孵化项目。\r\n\r\nApache CXF 是一个开源的 Services 框架，CXF 帮助您利用 Frontend 编程 API 来构建和开发 Services ，像 JAX-WS 。这些 Services 可以支持多种协议，比如：SOAP、XML/HTTP、RESTful HTTP 或者 CORBA ，并且可以在多种传输协议上运行，比如：HTTP、JMS 或者 JBI，CXF 大大简化了 Services 的创建，同时它继承了 XFire 传统，一样可以天然地和 Spring 进行无缝集成。','Xfire 简介','','publish','open','open','','xfire-%e7%ae%80%e4%bb%8b','','','2013-08-23 13:47:26','2013-08-23 05:47:26','',0,'http://localhost/wordpress-new/?p=54',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (55,1,'2013-08-23 13:47:26','2013-08-23 05:47:26','XFire 概述\r\n\r\nXFire 是 codeHaus 组织提供的一个开源框架，它构建了 POJO 和 SOA 之间的桥梁，主要特性就是支持将 POJO 通过非常简单的方式发布成 Web 服务，这种处理方式不仅充分发挥了 POJO 的作用，简化了 Java 应用转化为 Web 服务的步骤和过程，也直接降低了 SOA 的实现难度，为企业转向 SOA 架构提供了一种简单可行的方式。\r\n\r\nXFire 目前最新的版本是 1.2.2，目前支持的特性主要包括：\r\n支持将 Web 服务绑定到 POJO、XMLBeans、JAXB1.1、JAXB2.0 和 Castor；\r\n支持基于 HTTP、JMS、XMPP 等多种协议访问 Web 服务；\r\n支持多种 Web 服务业界重要标准如 SOAP、WSDL、Web 服务寻址（WS-Addressing）、Web 服务安全（WS-Security）等；\r\n支持 JSR181，可以通过 JDK5 配置 Web 服务；\r\n高性能的 SOAP 实现；\r\n服务器端、客户端代码辅助生成；\r\n对 Spring、Pico、Plexus 等项目的支持等\r\n\r\n以tomcat服务器为例web服务文件结构为\r\n\r\nweb.xml\r\n\r\n&lt;servlet&gt;\r\n&lt;servlet-name&gt;XFireServlet&lt;/servlet-name&gt;\r\n&lt;servlet-class&gt;org.codehaus.xfire.transport.http.XFireConfigurableServlet&lt;/servlet-class&gt;\r\n&lt;load-on-startup&gt;0&lt;/load-on-startup&gt;\r\n&lt;/servlet&gt;\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;XFireServlet&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n\r\n在你的web程序下 如 webapps\\sumMethod\\WEB-INF\\classes\\META-INF\\xfire\r\n\r\n放置配置web服务文件 services.xml\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;beans xmlns=\"http://xfire.codehaus.org/config/1.0\"&gt;\r\n\r\n&lt;service&gt;\r\n&lt;name&gt;GetListService&lt;/name&gt;\r\n&lt;serviceClass&gt;org.hm.service.IGetListService&lt;/serviceClass&gt;\r\n&lt;implementationClass&gt;\r\norg.hm.service.GetListServiceImpl\r\n&lt;/implementationClass&gt;\r\n&lt;style&gt;wrapped&lt;/style&gt;\r\n&lt;use&gt;literal&lt;/use&gt;\r\n&lt;scope&gt;application&lt;/scope&gt;\r\n&lt;/service&gt;&lt;/beans&gt;\r\n\r\n你的接口org.hm.service.IGetListService\r\n\r\npublic interface IGetListService {\r\npublic List&lt;Book&gt; getBook(String name);\r\n}\r\n\r\n你的实现类  org.hm.service.GetListServiceImpl\r\n\r\npublic class GetListServiceImpl implements IGetListService {\r\npublic List&lt;Book&gt; getBook(String name) {\r\nList&lt;Book&gt; arr = new ArrayList&lt;Book&gt;();\r\nBook bk = new Book();//只能使用默认的构造函数 采用set方法赋值\r\nbk.setName(name);\r\narr.add(bk);\r\nreturn arr;\r\n}\r\n}\r\n\r\nxfire支持返回List,map自定义JavaBean返回数据必须可以序列化和反序列化\r\n如果返回的数据类型是自定义的javaBean，则需要声明webservice的数据返回类型 方法  getBook 返回集合对象Book 如果定义的接口中方法的返回值是自定义的JavaBean则需要声明webservice服务的返回值。例如返回值是User则需要在webservice接口同目录下新建一个xml文件名称为：\r\n“接口名.aegis.xml”，内容如下 IGetListService.aegis.xml\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;mappings&gt;\r\n&lt;mapping&gt;\r\n&lt;method name=\"getBook\"&gt;\r\n&lt;return-type componentType=\"org.hm.service.Book\"/&gt;\r\n&lt;/method&gt;\r\n&lt;/mapping&gt;\r\n&lt;/mappings&gt;\r\n\r\n接下来就可以发布该web服务了\r\n\r\n下面是测试的客户端\r\n\r\npublic static void main(String[] args) throws Exception {\r\nService srvcModel = new ObjectServiceFactory().create(IGetListService.class);\r\nXFireProxyFactory factory = new XFireProxyFactory(XFireFactory.newInstance().getXFire());\r\nString url = \"http://localhost:8081/sumMethod/services/GetListService\";//注意没有后缀?wsdl\r\ntry {\r\nIGetListService srvc = (IGetListService) factory.create(srvcModel,url);\r\nList&lt;Book&gt; li = srvc.getBook(\"yellow\");\r\nSystem.out.println(li.get(0).getName());\r\n} catch (MalformedURLException e) {\r\ne.printStackTrace();\r\n}\r\n}\r\n\r\n控制台会显示: yellow\r\n\r\n这里只是xfire的简单入门介绍  xfire还提供客户端验证用户密码等安全措施 对于更复杂的返回对象都需要进行配置 如果需要了解更详细的信息可以查看官方文档\r\n\r\n备注  Apache CXF = Celtix + XFire，Apache CXF 的前身叫 Apache CeltiXfire，现在已经正式更名为 Apache CXF 了，以下简称为 CXF。CXF 继承了 Celtix 和 XFire 两大开源项目的精华，提供了对 JAX-WS 全面的支持，并且提供了多种 Binding 、DataBinding、Transport 以及各种 Format 的支持，并且可以根据实际项目的需要，采用代码优先（Code First）或者 WSDL 优先（WSDL First）来轻松地实现 Web Services 的发布和使用。目前它仍只是 Apache 的一个孵化项目。\r\n\r\nApache CXF 是一个开源的 Services 框架，CXF 帮助您利用 Frontend 编程 API 来构建和开发 Services ，像 JAX-WS 。这些 Services 可以支持多种协议，比如：SOAP、XML/HTTP、RESTful HTTP 或者 CORBA ，并且可以在多种传输协议上运行，比如：HTTP、JMS 或者 JBI，CXF 大大简化了 Services 的创建，同时它继承了 XFire 传统，一样可以天然地和 Spring 进行无缝集成。','Xfire 简介','','inherit','open','open','','54-revision-v1','','','2013-08-23 13:47:26','2013-08-23 05:47:26','',54,'http://localhost/wordpress-new/?p=55',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (56,1,'2013-08-23 13:47:58','2013-08-23 05:47:58','<strong>引言JAX-WS 2.0 是 JAX-RPC 1.1 的后续版本，通过使用 JAXB (Java Architecture for XML Binding)，一种 JCP 定义的技术，它对数据映射方法进行了改进</strong>\r\n\r\nWeb 服务已经出现很久了。首先是 SOAP，但 SOAP 仅描述消息的情况，然后是 WSDL，WSDL 并不会告诉您如何使用 Java™ 编写 Web 服务。在这种情况下，JAX-RPC 1.0 应运而生。经过数月使用之后，编写此规范的 Java Community Process (JCP) 人员认识到需要对其进行一些调整，调整的结果就是 JAX-RPC 1.1。该规范使用大约一年之后，JCP 人员希望构建一个更好的版本：JAX-RPC 2.0。其主要目标是与行业方向保持一致，但行业中不仅只使用 RPC Web 服务，还使用面向消息的 Web 服务。因此从名称中去掉了“RPC”，取而代之的是“WS”（当然表示的是 Web 服务）。因此 JAX-RPC 1.1 的后续版本是 JAX-WS 2.0——Java API for XML-based Web services。\r\n\r\n哪些内容保持不变？\r\n\r\n在列出 JAX-RPC 1.1 和 JAX-WS 2.0 的差异前，我们应该首先讨论一下二者的相同之处。\r\nJAX-WS 仍然支持 SOAP 1.1 over HTTP 1.1，因此互操作性将不会受到影响，仍然可以在网上传递相同的消息。\r\nJAX-WS 仍然支持 WSDL 1.1，因此您所学到的有关该规范的知识仍然有用。WSDL 2.0 规范已经接近完成，但在 JAX-WS 2.0 相关工作结束时其工作仍在进行中。\r\n\r\n区别何在？\r\nSOAP 1.2\r\n\r\nJAX-RPC 和 JAX-WS 都支持 SOAP 1.1。JAX-WS 还支持 SOAP 1.2。\r\nXML/HTTP\r\n\r\nWSDL 1.1 规范在 HTTP 绑定中定义，这意味着利用此规范可以在不使用 SOAP 的情况下通过 HTTP 发送 XML 消息。JAX-RPC 忽略了 HTTP 绑定。而 JAX-WS 添加了对其的支持。\r\nWS-I Basic Profile\r\n\r\nJAX-RPC 支持 WS-I Basic Profile (BP) V1.0。JAX-WS 支持 BP 1.1。（WS-I 即 Web 服务互操作性组织。）\r\n新 Java 功能\r\nJAX-RPC 映射到 Java 1.4。JAX-WS 映射到 Java 5.0。JAX-WS 依赖于 Java 5.0 中的很多新功能。\r\nJava EE 5 是 J2EE 1.4 的后续版本，添加了对 JAX-WS 的支持，但仍然支持 JAX-RPC，这可能会对 Web 服务新手造成混淆。\r\n数据映射模型\r\nJAX-RPC 具有自己的映射模型，此模型大约涵盖了所有模式类型中的 90%。它没有涵盖的部分映射到了 javax.xml.soap.SOAPElement。\r\nJAX-WS 的数据映射模型是 JAXB。JAXB 可保证所有 XML 模式的映射。\r\n接口映射模型\r\n\r\nJAX-WS 的基本接口映射模型与 JAX-RPC 的区别并不大，不过二者之间存在以下差异：\r\nJAX-WS 的模型使用新的 Java 5.0 功能。\r\nJAX-WS 的模型引入了异步功能。\r\n动态编程模型\r\nJAX-WS 的动态客户机模型与 JAX-RPC 的对应模型差别很大。很多更改都是为了认可行业需求：\r\n引入了面向消息的功能。\r\n引入了动态异步功能。\r\nJAX-WS 还添加了动态服务器模型，而 JAX-RPC 则没有此模型。\r\n消息传输优化机制（Message Transmission Optimization Mechanism，MTOM）\r\n\r\nJAX-WS 通过 JAXB 添加了对新附件规范 MTOM 的支持。Microsoft 从来没有给 SOAP 添加附件规范；但似乎大家都支持 MTOM，因此应该能够实现附件互操作性。\r\n处理程序模型\r\n从 JAX-RPC 到 JAX-WS 的过程中，处理程序模型发生了很大的变化。\r\nJAX-RPC 处理程序依赖于 SAAJ 1.2。JAX-WS 处理程序依赖于新的 SAAJ 1.3 规范。\r\n\r\n<strong> SOAP 1.2</strong>\r\n\r\n从编程模型的角度而言，SOAP 1.1 和 SOAP 1.2 之间并没有太多的差异。作为 Java 程序员，您只会在使用处理程序时遇到这些差异，我们将在以后的技巧文章中对如何处理这种情况进行讨论。SAAJ 1.3 已更新以支持 SOAP 1.2。\r\n\r\nXML/HTTP\r\n\r\n与 SOAP 1.2 的更改类似，从编程模型的角度而言，SOAP/HTTP 和 XML/HTTP 消息之间并没有太多的差异。作为 Java 程序员，您只会在使用处理程序时遇到这些差异，我们将在以后的技巧文章中对如何处理这种情况进行讨论。HTTP 绑定具有自己的处理程序链和自己的一组消息上下文属性。\r\n\r\nWS-I Basic Profiles\r\n\r\nJAX-RPC 1.1 支持 WS-I Basic Profile (BP) 1.0。从那时起，WS-I 人员就完成了 BP 1.1（以及关联的 AP 1.0 和 SSBP 1.0）的开发。这些新概要阐明了一些小要点，更明确地定义了附件。JAX-WS 2.0 支持这些较新的概要。在大部分情况下，其间的差异并不会影响 Java 编程模型。不过附件除外。WS-I 不仅处理了有关附件的一些问题，而且还定义了自己的 XML 附件类型：wsi:swaRef。\r\n\r\n很多人都被这些概要搞糊涂了。为了弄清楚其间的问题，将需要了解一下其相关历史。\r\n\r\nWS-I 的第一个基本概要 (BP 1.0) 在阐明各个规范方面做得非常不错，但它并不完美。尤其对 SOAP with Attachments (Sw/A) 的支持仍然相当不明确。在第二个工作循环中，WS-I 人员将附件从基本概要 (BP 1.1) 中分离出来，并对第一版中一些没有讨论的内容进行了补充。当时他们还添加了两个互不包括的基本概要补充文档：AP 1.0 和 SSBP 1.0。AP 1.0 是附件概要 (Attachment Profile)，描述如何使用 Sw/A。SSBP 1.0 是简单 SOAP 绑定概要 (Simple SOAP Binding Profile)，描述并不支持 Sw/A 的 Web 服务引擎（如 Microsoft 的 .NET）。WS-I 所提供的其他概要文件都是以这些基本概要文件为基础构建的。\r\n\r\nJava 5\r\n\r\n对 Java 语言进行了一系列更改。JAX-WS 依赖于：Annotation、通用函数和执行程序。\r\n\r\n<strong>总结</strong>\r\n\r\nJAX-WS 2.0 是 JAX-RPC 1.1 的后续版本。其中有些内容保持不变，但大部分编程模型都或多或少有些不同。本技巧文章中介绍的主题将在一系列技巧文章中展开讨论，这个系列的文章对 JAX-WS 和 JAX-RPC 间的区别进行了详细的讨论，我们将在随后的数月中陆续发布。大致看来，可能会因为以下这些原因而决定从 JAX-RPC 迁移到 JAX-WS，或保持不变。\r\n\r\n希望继续使用 JAX-RPC 1.1 的原因：\r\n如果您希望继续使用现有的东西，JAX-RPC 将在今后一段时间内继续得到支持。\r\n如果您不希望升级到 Java 5。\r\n如果您希望发送采用 SOAP 编码的消息或创建 RPC/encoded 样式的 WSDL。\r\n\r\n升级到 JAX-WS 2.0 的原因：\r\n如果您希望使用新的面向消息的 API。\r\n如果您希望使用 MTOM 发送附件数据。\r\n如果您希望通过 JAXB 更好地支持 XML 模式。\r\n如果您希望在 Web 服务客户机中采用异步编程模型。\r\n如果您需要使用能够处理 SOAP 1.2 消息的客户机或服务。\r\n如果您希望在 Web 服务中消除对 SOAP 的需求，而直接使用 XML/HTTP 绑定。\r\n如果您喜欢使用领先的尖端技术。\r\n\r\n&nbsp;','Web 服务提示与技巧: JAX-RPC 与 JAX-WS 的比较','','publish','open','open','','web-%e6%9c%8d%e5%8a%a1%e6%8f%90%e7%a4%ba%e4%b8%8e%e6%8a%80%e5%b7%a7-jax-rpc-%e4%b8%8e-jax-ws-%e7%9a%84%e6%af%94%e8%be%83','','','2013-08-23 13:47:58','2013-08-23 05:47:58','',0,'http://localhost/wordpress-new/?p=56',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (57,1,'2013-08-23 13:47:58','2013-08-23 05:47:58','<strong>引言JAX-WS 2.0 是 JAX-RPC 1.1 的后续版本，通过使用 JAXB (Java Architecture for XML Binding)，一种 JCP 定义的技术，它对数据映射方法进行了改进</strong>\r\n\r\nWeb 服务已经出现很久了。首先是 SOAP，但 SOAP 仅描述消息的情况，然后是 WSDL，WSDL 并不会告诉您如何使用 Java™ 编写 Web 服务。在这种情况下，JAX-RPC 1.0 应运而生。经过数月使用之后，编写此规范的 Java Community Process (JCP) 人员认识到需要对其进行一些调整，调整的结果就是 JAX-RPC 1.1。该规范使用大约一年之后，JCP 人员希望构建一个更好的版本：JAX-RPC 2.0。其主要目标是与行业方向保持一致，但行业中不仅只使用 RPC Web 服务，还使用面向消息的 Web 服务。因此从名称中去掉了“RPC”，取而代之的是“WS”（当然表示的是 Web 服务）。因此 JAX-RPC 1.1 的后续版本是 JAX-WS 2.0——Java API for XML-based Web services。\r\n\r\n哪些内容保持不变？\r\n\r\n在列出 JAX-RPC 1.1 和 JAX-WS 2.0 的差异前，我们应该首先讨论一下二者的相同之处。\r\nJAX-WS 仍然支持 SOAP 1.1 over HTTP 1.1，因此互操作性将不会受到影响，仍然可以在网上传递相同的消息。\r\nJAX-WS 仍然支持 WSDL 1.1，因此您所学到的有关该规范的知识仍然有用。WSDL 2.0 规范已经接近完成，但在 JAX-WS 2.0 相关工作结束时其工作仍在进行中。\r\n\r\n区别何在？\r\nSOAP 1.2\r\n\r\nJAX-RPC 和 JAX-WS 都支持 SOAP 1.1。JAX-WS 还支持 SOAP 1.2。\r\nXML/HTTP\r\n\r\nWSDL 1.1 规范在 HTTP 绑定中定义，这意味着利用此规范可以在不使用 SOAP 的情况下通过 HTTP 发送 XML 消息。JAX-RPC 忽略了 HTTP 绑定。而 JAX-WS 添加了对其的支持。\r\nWS-I Basic Profile\r\n\r\nJAX-RPC 支持 WS-I Basic Profile (BP) V1.0。JAX-WS 支持 BP 1.1。（WS-I 即 Web 服务互操作性组织。）\r\n新 Java 功能\r\nJAX-RPC 映射到 Java 1.4。JAX-WS 映射到 Java 5.0。JAX-WS 依赖于 Java 5.0 中的很多新功能。\r\nJava EE 5 是 J2EE 1.4 的后续版本，添加了对 JAX-WS 的支持，但仍然支持 JAX-RPC，这可能会对 Web 服务新手造成混淆。\r\n数据映射模型\r\nJAX-RPC 具有自己的映射模型，此模型大约涵盖了所有模式类型中的 90%。它没有涵盖的部分映射到了 javax.xml.soap.SOAPElement。\r\nJAX-WS 的数据映射模型是 JAXB。JAXB 可保证所有 XML 模式的映射。\r\n接口映射模型\r\n\r\nJAX-WS 的基本接口映射模型与 JAX-RPC 的区别并不大，不过二者之间存在以下差异：\r\nJAX-WS 的模型使用新的 Java 5.0 功能。\r\nJAX-WS 的模型引入了异步功能。\r\n动态编程模型\r\nJAX-WS 的动态客户机模型与 JAX-RPC 的对应模型差别很大。很多更改都是为了认可行业需求：\r\n引入了面向消息的功能。\r\n引入了动态异步功能。\r\nJAX-WS 还添加了动态服务器模型，而 JAX-RPC 则没有此模型。\r\n消息传输优化机制（Message Transmission Optimization Mechanism，MTOM）\r\n\r\nJAX-WS 通过 JAXB 添加了对新附件规范 MTOM 的支持。Microsoft 从来没有给 SOAP 添加附件规范；但似乎大家都支持 MTOM，因此应该能够实现附件互操作性。\r\n处理程序模型\r\n从 JAX-RPC 到 JAX-WS 的过程中，处理程序模型发生了很大的变化。\r\nJAX-RPC 处理程序依赖于 SAAJ 1.2。JAX-WS 处理程序依赖于新的 SAAJ 1.3 规范。\r\n\r\n<strong> SOAP 1.2</strong>\r\n\r\n从编程模型的角度而言，SOAP 1.1 和 SOAP 1.2 之间并没有太多的差异。作为 Java 程序员，您只会在使用处理程序时遇到这些差异，我们将在以后的技巧文章中对如何处理这种情况进行讨论。SAAJ 1.3 已更新以支持 SOAP 1.2。\r\n\r\nXML/HTTP\r\n\r\n与 SOAP 1.2 的更改类似，从编程模型的角度而言，SOAP/HTTP 和 XML/HTTP 消息之间并没有太多的差异。作为 Java 程序员，您只会在使用处理程序时遇到这些差异，我们将在以后的技巧文章中对如何处理这种情况进行讨论。HTTP 绑定具有自己的处理程序链和自己的一组消息上下文属性。\r\n\r\nWS-I Basic Profiles\r\n\r\nJAX-RPC 1.1 支持 WS-I Basic Profile (BP) 1.0。从那时起，WS-I 人员就完成了 BP 1.1（以及关联的 AP 1.0 和 SSBP 1.0）的开发。这些新概要阐明了一些小要点，更明确地定义了附件。JAX-WS 2.0 支持这些较新的概要。在大部分情况下，其间的差异并不会影响 Java 编程模型。不过附件除外。WS-I 不仅处理了有关附件的一些问题，而且还定义了自己的 XML 附件类型：wsi:swaRef。\r\n\r\n很多人都被这些概要搞糊涂了。为了弄清楚其间的问题，将需要了解一下其相关历史。\r\n\r\nWS-I 的第一个基本概要 (BP 1.0) 在阐明各个规范方面做得非常不错，但它并不完美。尤其对 SOAP with Attachments (Sw/A) 的支持仍然相当不明确。在第二个工作循环中，WS-I 人员将附件从基本概要 (BP 1.1) 中分离出来，并对第一版中一些没有讨论的内容进行了补充。当时他们还添加了两个互不包括的基本概要补充文档：AP 1.0 和 SSBP 1.0。AP 1.0 是附件概要 (Attachment Profile)，描述如何使用 Sw/A。SSBP 1.0 是简单 SOAP 绑定概要 (Simple SOAP Binding Profile)，描述并不支持 Sw/A 的 Web 服务引擎（如 Microsoft 的 .NET）。WS-I 所提供的其他概要文件都是以这些基本概要文件为基础构建的。\r\n\r\nJava 5\r\n\r\n对 Java 语言进行了一系列更改。JAX-WS 依赖于：Annotation、通用函数和执行程序。\r\n\r\n<strong>总结</strong>\r\n\r\nJAX-WS 2.0 是 JAX-RPC 1.1 的后续版本。其中有些内容保持不变，但大部分编程模型都或多或少有些不同。本技巧文章中介绍的主题将在一系列技巧文章中展开讨论，这个系列的文章对 JAX-WS 和 JAX-RPC 间的区别进行了详细的讨论，我们将在随后的数月中陆续发布。大致看来，可能会因为以下这些原因而决定从 JAX-RPC 迁移到 JAX-WS，或保持不变。\r\n\r\n希望继续使用 JAX-RPC 1.1 的原因：\r\n如果您希望继续使用现有的东西，JAX-RPC 将在今后一段时间内继续得到支持。\r\n如果您不希望升级到 Java 5。\r\n如果您希望发送采用 SOAP 编码的消息或创建 RPC/encoded 样式的 WSDL。\r\n\r\n升级到 JAX-WS 2.0 的原因：\r\n如果您希望使用新的面向消息的 API。\r\n如果您希望使用 MTOM 发送附件数据。\r\n如果您希望通过 JAXB 更好地支持 XML 模式。\r\n如果您希望在 Web 服务客户机中采用异步编程模型。\r\n如果您需要使用能够处理 SOAP 1.2 消息的客户机或服务。\r\n如果您希望在 Web 服务中消除对 SOAP 的需求，而直接使用 XML/HTTP 绑定。\r\n如果您喜欢使用领先的尖端技术。\r\n\r\n&nbsp;','Web 服务提示与技巧: JAX-RPC 与 JAX-WS 的比较','','inherit','open','open','','56-revision-v1','','','2013-08-23 13:47:58','2013-08-23 05:47:58','',56,'http://localhost/wordpress-new/?p=57',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (58,1,'2013-08-23 13:48:27','2013-08-23 05:48:27','<strong> 接JAX-RPC开发Web服务之(Apache axis 1.4) -1</strong> 一节 这里讲解如何通过axis构建web服务\r\n<p align=\"left\">Axis 支持三种web service开发方式或2种方式，分别为:</p>\r\n<p align=\"left\">1 、Dynamic Invocation Interface ( DII) 即使发布 不支持包</p>\r\n<p align=\"left\">2 、Dynamic Proxy方式 即使发布 不支持包</p>\r\n<p align=\"left\">3 、Stubs方式 定制发布</p>\r\n<p align=\"left\"><strong>实例1（DII）编写代码 </strong></p>\r\n<p align=\"left\"><strong>1.HelloWorld.java</strong></p>\r\n<p align=\"left\">public class HelloWorld {\r\npublic String getName(String name) {\r\nreturn \"Hello \" + name;}}</p>\r\n<p align=\"left\">2.修改HelloWorld.java 为 HelloWorld.jws 放入Tomcat/webapps/axis 目录下 运行Tomcat 访问http://localhost:8081/axis/HelloWorld.jws?wsdl如果正确你可以查看到HelloWorld的wsdl</p>\r\n<p align=\"left\">3 TestClient.java 下面是main方法</p>\r\n<p align=\"left\">import javax.xml.namespace.QName;\r\nimport javax.xml.rpc.ServiceException;\r\nimport org.apache.axis.client.Call;\r\nimport org.apache.axis.client.Service;</p>\r\n<p align=\"left\">String endpoint = \"http://localhost:8081/axis/HelloWorld.jws\";\r\nService service = new Service();\r\nCall call = (Call) service.createCall();\r\ncall.setOperationName(new QName(\"http://localhost:8081/axis/HelloWorld.jws\", \"getName\"));\r\ncall.setTargetEndpointAddress(new java.net.URL(endpoint));\r\ncall.invoke(new Object[] { \"wRitchie\" });</p>\r\n<p align=\"left\">///运行时别忘了相关包的导入</p>\r\n<p align=\"left\">4.可以通过axis的 org.apache.axis.wsdl.WSDL2Java工具来创建该wsdl的客户端来代替上面的客户端访问</p>\r\n<p align=\"left\">在运行中的tomcat在命令行下 进入Tomcat 6.0\\webapps\\axis\\WEB-INF 运行</p>\r\n<p align=\"left\"><strong>Java -Djava.ext.dirs=lib org.apache.axis.wsdl.WSDL2Java http://localhost:8081/axis/HelloWorld.jws ?wsdl </strong></p>\r\n<p align=\"left\">生成代理类 接口类等等如下</p>\r\n<p align=\"left\">HelloWorldServiceLocator.java HelloWorld.java HelloWorldSoapBindingStub.java HelloWorldService.java</p>\r\n<p align=\"left\">在客户端导入这些类修改TestClient.java main方法通过如下代码访问web服务</p>\r\n<p align=\"left\">import localhost.axis.HelloWorld_jws.HelloWorld;\r\nimport localhost.axis.HelloWorld_jws.HelloWorldService;\r\nimport localhost.axis.HelloWorld_jws.HelloWorldServiceLocator;</p>\r\n<p align=\"left\">HelloWorldService service = new HelloWorldServiceLocator();\r\nHelloWorld hello = service.getHelloWorld();\r\nhello.getName(\"yes it is work \");</p>\r\n<p align=\"left\">备注采用 DII方式 开发web服务时axis不支持 带包的类 也就是说在自己的工程下HelloWorld.java不能 有package 且确保 web.xml 有如下信息 &lt;servlet&gt;\r\n&lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;\r\n&lt;display-name&gt;Apache-Axis Servlet&lt;/display-name&gt;\r\n&lt;servlet-class&gt;\r\norg.apache.axis.transport.http.AxisServlet\r\n&lt;/servlet-class&gt;\r\n&lt;/servlet&gt;\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;*.jws&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n&lt;mime-mapping&gt;\r\n&lt;extension&gt;wsdl&lt;/extension&gt;\r\n&lt;mime-type&gt;text/xml&lt;/mime-type&gt;\r\n&lt;/mime-mapping&gt;\r\n&lt;mime-mapping&gt;\r\n&lt;extension&gt;xsd&lt;/extension&gt;\r\n&lt;mime-type&gt;text/xml&lt;/mime-type&gt;\r\n&lt;/mime-mapping&gt;</p>\r\n&nbsp;','JAX-RPC开发Web服务之(Apache axis 1.4) -2','','publish','open','open','','jax-rpc%e5%bc%80%e5%8f%91web%e6%9c%8d%e5%8a%a1%e4%b9%8bapache-axis-1-4-2','','','2013-08-23 13:48:27','2013-08-23 05:48:27','',0,'http://localhost/wordpress-new/?p=58',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (59,1,'2013-08-23 13:48:27','2013-08-23 05:48:27','<strong> 接JAX-RPC开发Web服务之(Apache axis 1.4) -1</strong> 一节 这里讲解如何通过axis构建web服务\r\n<p align=\"left\">Axis 支持三种web service开发方式或2种方式，分别为:</p>\r\n<p align=\"left\">1 、Dynamic Invocation Interface ( DII) 即使发布 不支持包</p>\r\n<p align=\"left\">2 、Dynamic Proxy方式 即使发布 不支持包</p>\r\n<p align=\"left\">3 、Stubs方式 定制发布</p>\r\n<p align=\"left\"><strong>实例1（DII）编写代码 </strong></p>\r\n<p align=\"left\"><strong>1.HelloWorld.java</strong></p>\r\n<p align=\"left\">public class HelloWorld {\r\npublic String getName(String name) {\r\nreturn \"Hello \" + name;}}</p>\r\n<p align=\"left\">2.修改HelloWorld.java 为 HelloWorld.jws 放入Tomcat/webapps/axis 目录下 运行Tomcat 访问http://localhost:8081/axis/HelloWorld.jws?wsdl如果正确你可以查看到HelloWorld的wsdl</p>\r\n<p align=\"left\">3 TestClient.java 下面是main方法</p>\r\n<p align=\"left\">import javax.xml.namespace.QName;\r\nimport javax.xml.rpc.ServiceException;\r\nimport org.apache.axis.client.Call;\r\nimport org.apache.axis.client.Service;</p>\r\n<p align=\"left\">String endpoint = \"http://localhost:8081/axis/HelloWorld.jws\";\r\nService service = new Service();\r\nCall call = (Call) service.createCall();\r\ncall.setOperationName(new QName(\"http://localhost:8081/axis/HelloWorld.jws\", \"getName\"));\r\ncall.setTargetEndpointAddress(new java.net.URL(endpoint));\r\ncall.invoke(new Object[] { \"wRitchie\" });</p>\r\n<p align=\"left\">///运行时别忘了相关包的导入</p>\r\n<p align=\"left\">4.可以通过axis的 org.apache.axis.wsdl.WSDL2Java工具来创建该wsdl的客户端来代替上面的客户端访问</p>\r\n<p align=\"left\">在运行中的tomcat在命令行下 进入Tomcat 6.0\\webapps\\axis\\WEB-INF 运行</p>\r\n<p align=\"left\"><strong>Java -Djava.ext.dirs=lib org.apache.axis.wsdl.WSDL2Java http://localhost:8081/axis/HelloWorld.jws ?wsdl </strong></p>\r\n<p align=\"left\">生成代理类 接口类等等如下</p>\r\n<p align=\"left\">HelloWorldServiceLocator.java HelloWorld.java HelloWorldSoapBindingStub.java HelloWorldService.java</p>\r\n<p align=\"left\">在客户端导入这些类修改TestClient.java main方法通过如下代码访问web服务</p>\r\n<p align=\"left\">import localhost.axis.HelloWorld_jws.HelloWorld;\r\nimport localhost.axis.HelloWorld_jws.HelloWorldService;\r\nimport localhost.axis.HelloWorld_jws.HelloWorldServiceLocator;</p>\r\n<p align=\"left\">HelloWorldService service = new HelloWorldServiceLocator();\r\nHelloWorld hello = service.getHelloWorld();\r\nhello.getName(\"yes it is work \");</p>\r\n<p align=\"left\">备注采用 DII方式 开发web服务时axis不支持 带包的类 也就是说在自己的工程下HelloWorld.java不能 有package 且确保 web.xml 有如下信息 &lt;servlet&gt;\r\n&lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;\r\n&lt;display-name&gt;Apache-Axis Servlet&lt;/display-name&gt;\r\n&lt;servlet-class&gt;\r\norg.apache.axis.transport.http.AxisServlet\r\n&lt;/servlet-class&gt;\r\n&lt;/servlet&gt;\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;*.jws&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n&lt;mime-mapping&gt;\r\n&lt;extension&gt;wsdl&lt;/extension&gt;\r\n&lt;mime-type&gt;text/xml&lt;/mime-type&gt;\r\n&lt;/mime-mapping&gt;\r\n&lt;mime-mapping&gt;\r\n&lt;extension&gt;xsd&lt;/extension&gt;\r\n&lt;mime-type&gt;text/xml&lt;/mime-type&gt;\r\n&lt;/mime-mapping&gt;</p>\r\n&nbsp;','JAX-RPC开发Web服务之(Apache axis 1.4) -2','','inherit','open','open','','58-revision-v1','','','2013-08-23 13:48:27','2013-08-23 05:48:27','',58,'http://localhost/wordpress-new/?p=59',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (60,1,'2013-08-23 13:48:51','2013-08-23 05:48:51','接JAX-RPC开发Web服务之(Apache axis 1.4) -2 一节 这里讲解如何通过axis构建web服务\r\n\r\nDynamic Proxy方式 与上一节讲到的 DII 其实是一样 都是属于即时发布 并且都不支持包   Dynamic Proxy方式 要求 创建一个远程的接口  而我们的类 HelloWorld 则需要去实现它 如果客户端是java编写的话 客户端只需要该HelloWorld的接口就可以访问该Web服务了。有了接口客户端的调用更直观 。程序如下：\r\n\r\n<strong>IHelloWorld.java</strong>\r\n\r\npublic interface IHelloWorld extends Remote {\r\npublic String getName(String name);}\r\n\r\n<strong>HelloWorld.java</strong>\r\n\r\npublic class HelloWorld implements IHelloWorld {\r\npublic String getName(String name){return name;}\r\n}\r\n\r\n<strong> 客户端</strong>\r\n\r\nString wsdlUrl = \"http://localhost:8081/axis/HelloWorld.jws?wsdl\";  //<strong>wsdl地址</strong>\r\nString nameSpaceUri = \"http://localhost:8081/axis/HelloWorld.jws\";  //<strong>wsdl定义中的命名空间</strong>\r\nString serviceName = \"HelloWorldService\";//<strong>wsdl定义中的  Service Name</strong>\r\nServiceFactory serviceFactory = ServiceFactory.newInstance();\r\njavax.xml.rpc.Service service = serviceFactory.createService(new URL(wsdlUrl), new QName(nameSpaceUri, serviceName));\r\n\r\n//IHelloWorld 客户端需要的接口\r\n<strong>IHelloWorld</strong> proxy = (IHelloWorld)service.getPort(IHelloWorld.class);\r\n\r\n当然你也可以使用其他方式来访问该web服务\r\n\r\n其他的与DII方式 一样 发布HelloWorld.jws到web根目录.当你访问Axis部署的服务时 会自动去编译该<strong>jws</strong>','JAX-RPC开发Web服务之(Apache axis 1.4) -3','','publish','open','open','','jax-rpc%e5%bc%80%e5%8f%91web%e6%9c%8d%e5%8a%a1%e4%b9%8bapache-axis-1-4-3','','','2013-08-23 13:48:51','2013-08-23 05:48:51','',0,'http://localhost/wordpress-new/?p=60',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (61,1,'2013-08-23 13:48:51','2013-08-23 05:48:51','接JAX-RPC开发Web服务之(Apache axis 1.4) -2 一节 这里讲解如何通过axis构建web服务\r\n\r\nDynamic Proxy方式 与上一节讲到的 DII 其实是一样 都是属于即时发布 并且都不支持包   Dynamic Proxy方式 要求 创建一个远程的接口  而我们的类 HelloWorld 则需要去实现它 如果客户端是java编写的话 客户端只需要该HelloWorld的接口就可以访问该Web服务了。有了接口客户端的调用更直观 。程序如下：\r\n\r\n<strong>IHelloWorld.java</strong>\r\n\r\npublic interface IHelloWorld extends Remote {\r\npublic String getName(String name);}\r\n\r\n<strong>HelloWorld.java</strong>\r\n\r\npublic class HelloWorld implements IHelloWorld {\r\npublic String getName(String name){return name;}\r\n}\r\n\r\n<strong> 客户端</strong>\r\n\r\nString wsdlUrl = \"http://localhost:8081/axis/HelloWorld.jws?wsdl\";  //<strong>wsdl地址</strong>\r\nString nameSpaceUri = \"http://localhost:8081/axis/HelloWorld.jws\";  //<strong>wsdl定义中的命名空间</strong>\r\nString serviceName = \"HelloWorldService\";//<strong>wsdl定义中的  Service Name</strong>\r\nServiceFactory serviceFactory = ServiceFactory.newInstance();\r\njavax.xml.rpc.Service service = serviceFactory.createService(new URL(wsdlUrl), new QName(nameSpaceUri, serviceName));\r\n\r\n//IHelloWorld 客户端需要的接口\r\n<strong>IHelloWorld</strong> proxy = (IHelloWorld)service.getPort(IHelloWorld.class);\r\n\r\n当然你也可以使用其他方式来访问该web服务\r\n\r\n其他的与DII方式 一样 发布HelloWorld.jws到web根目录.当你访问Axis部署的服务时 会自动去编译该<strong>jws</strong>','JAX-RPC开发Web服务之(Apache axis 1.4) -3','','inherit','open','open','','60-revision-v1','','','2013-08-23 13:48:51','2013-08-23 05:48:51','',60,'http://localhost/wordpress-new/?p=61',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (62,1,'2013-08-23 13:49:17','2013-08-23 05:49:17','接JAX-RPC开发Web服务之(Apache axis 1.4) -3 一节 这节介绍如何定制发布 定制发布 比即时发布要灵活得多 支持包但是 需要通过 WSDD（web 服务部署描述文件）来定义web访问的方式\r\n\r\npackage com.sev;\r\n\r\npublic class HelloWorld {\r\npublic String getName(String x){return x;};\r\n}\r\n\r\n发布wsdd的文件 deploy.wsdd\r\n\r\n&lt;deployment xmlns=\"http://xml.apache.org/axis/wsdd/\" xmlns:java=\"http://xml.apache.org/axis/wsdd/providers/java\"&gt;\r\n&lt;service name=\"HelloWorld\" provider=\"java:RPC\"&gt;//服务名\r\n&lt;parameter name=\"className\" value=\"com.sev.HelloWorld\"/&gt;//具体的类\r\n&lt;parameter name=\"allowedMethods\" value=\"*\"/&gt;//公开类中所有的方法\r\n&lt;/service&gt;\r\n&lt;/deployment&gt;\r\n\r\n取消服务的文件 undeploy.wsdd\r\n\r\n&lt;undeployment xmlns=\"http://xml.apache.org/axis/wsdd/\" &gt;\r\n&lt;service name=\"HelloWorld\" /&gt;//服务名\r\n&lt;/undeployment&gt;\r\n\r\n定义上面两个文件后 确保服务器 是启动状态拷贝2个文件到 web程序下比如\r\n\r\nE:\\Apache Software Foundation\\Tomcat 6.0\\webapps\\axis\\WEB-INF 如果你需要发布web服务 打开命令行 cmd 输入如下命令就是用如下命令\r\n\r\nE:\\Apache Software Foundation\\Tomcat 6.0\\webapps\\axis\\WEB-INF&gt;<strong>java -Djava.ext.di</strong>\r\n<strong>rs=lib org.apache.axis.client.AdminClient -lhttp://localhost:8081/axis/servlet/A</strong>\r\n<strong>xisServlet deploy.wsdd </strong>\r\n\r\n取消就是\r\n\r\nE:\\Apache Software Foundation\\Tomcat 6.0\\webapps\\axis\\WEB-INF&gt;<strong>java -Djava.ext.di</strong>\r\n<strong>rs=lib org.apache.axis.client.AdminClient -lhttp://localhost:8081/axis/servlet/A</strong>\r\n<strong>xisServlet undeploy.wsdd </strong>\r\n\r\n对于wsdd 方式发布 请确保你的web.xml的文件含有如下信息\r\n\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;/servlet/AxisServlet&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n\r\n客户端的访问方式 这里就不再给出 与即时发布是一样的\r\n\r\n<strong>复杂对象的处理 </strong>\r\n\r\n下面以一个User例子来说明\r\n\r\n定义User类 并添加 set/get方法\r\n\r\npublic class User implements Serializable {\r\nprivate static final long serialVersionUID = 677484458789332877L;\r\nprivate int id;\r\nprivate String name;\r\nprivate String email;\r\nprivate String address;\r\n}\r\n\r\n定义业务类ManagerUser\r\n\r\npublic class ManagerUser {\r\n\r\npublic User getUserByName(String name) {\r\nUser user = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(name);\r\nuser.setAddress(\"china\");\r\nuser.setEmail(name + \"@hoo.com\");\r\nreturn user;\r\n}\r\n\r\npublic void setUser(User user) {\r\nSystem.out.println(user);\r\n}\r\n\r\npublic List&lt;User&gt; getUsers(int i) {\r\nList&lt;User&gt; users = new ArrayList&lt;User&gt;();\r\nfor (int j = 0; j &lt;= i; j++) {\r\nUser user = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(\"jack#\" + j);\r\nuser.setAddress(\"china\");\r\nuser.setEmail(\"jack\" + j + \"@hoo.com\");\r\nusers.add(user);\r\n}\r\nreturn users;\r\n}\r\n\r\npublic void setUserMap(Map&lt;String, User&gt; maps) {\r\nSystem.out.println(maps);\r\n}\r\n\r\npublic User[] getUserArray(int i) {\r\nUser[] users = new User[i];\r\nfor (int j = 0; j &lt; i; j++) {\r\nUser user = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(\"jack#\" + j);\r\nuser.setAddress(\"china\");\r\nuser.setEmail(\"jack\" + j + \"@hoo.com\");\r\nusers[j] = user;\r\n}\r\nreturn users;\r\n}\r\n\r\npublic void setUserArray(User[] users) {\r\nfor (User u : users) {\r\nSystem.out.println(u);\r\n}\r\n}\r\n\r\npublic Map&lt;String, User&gt; getUserMap() {\r\nMap&lt;String, User&gt; users = new HashMap&lt;String, User&gt;();\r\nUser user = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(\"jack#\");\r\nuser.setAddress(\"china\");\r\nuser.setEmail(\"jack@hoo.com\");\r\nusers.put(\"A\", user);\r\n\r\nuser = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(\"tom\");\r\nuser.setAddress(\"china\");\r\nuser.setEmail(\"tom@hoo.com\");\r\nusers.put(\"B\", user);\r\nreturn users;\r\n}\r\n\r\npublic void setUsers(List&lt;User&gt; users) {\r\nfor (User u : users) {\r\nSystem.out.println(u);\r\n}\r\n}\r\n}\r\n\r\n业务类和自定义类都是简单的一些类和方法axis对于复杂对象的处理关键是对WSDD的定义下面是 该WSDD\r\n\r\n&lt;deployment xmlns=\"http://xml.apache.org/axis/wsdd/\"\r\nxmlns:java=\"http://xml.apache.org/axis/wsdd/providers/java\"&gt;\r\n&lt;service name=\"ManagerUser\" provider=\"java:RPC\"&gt;\r\n&lt;parameter name=\"className\" value=\"com.sev.ManagerUser\" /&gt;\r\n&lt;parameter name=\"allowedMethods\" value=\"*\" /&gt;\r\n&lt;parameter name=\"scope\" value=\"request\" /&gt;\r\n&lt;!-- 这里的urn:User和new QName(\"urn:User\", \"User\")这里是对应的 --&gt;\r\n&lt;beanMapping qname=\"myNSD:User\" xmlns:myNSD=\"urn:User\" languageSpecificType=\"java:com.sev.User\"/&gt;\r\n&lt;/service&gt;\r\n&lt;/deployment&gt;\r\n\r\n这里关键的是 beanMapping 设置 很容易理解这里的设置 详细的不再赘述  可以查看官方文档获取更详细的说明。对于复杂对象客户端的访问会有所不同需要指明访问参数的对象类型以及返回类型等等 如采用非生成客户端来访问的话需要如下设置\r\n\r\nCall call = (Call) service.createCall();\r\ncall.setTargetEndpointAddress(\"http://localhost:8081/axis/services/ManagerUser\");\r\n//这里的QName的ns和wsdd文件中的对应\r\nQName qn = new QName(\"urn:User\", \"User\");\r\n//这里是将对象序列化和反序列化的配置\r\ncall.registerTypeMapping(User.class, qn, new BeanSerializerFactory(User.class, qn), new BeanDeserializerFactory(User.class, qn));\r\ncall.setOperationName(\"setUser\");\r\n//设置参数类型\r\ncall.addParameter(\"user\", qn, ParameterMode.IN);\r\n\r\n//如果返回类型是User需要如下设置call.setReturnClass(User.class);\r\ncall.invoke(new Object[] { user });\r\n\r\n&nbsp;','JAX-RPC开发Web服务之(Apache axis 1.4) -4','','publish','open','open','','jax-rpc%e5%bc%80%e5%8f%91web%e6%9c%8d%e5%8a%a1%e4%b9%8bapache-axis-1-4-4','','','2013-08-23 13:49:17','2013-08-23 05:49:17','',0,'http://localhost/wordpress-new/?p=62',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (63,1,'2013-08-23 13:49:17','2013-08-23 05:49:17','接JAX-RPC开发Web服务之(Apache axis 1.4) -3 一节 这节介绍如何定制发布 定制发布 比即时发布要灵活得多 支持包但是 需要通过 WSDD（web 服务部署描述文件）来定义web访问的方式\r\n\r\npackage com.sev;\r\n\r\npublic class HelloWorld {\r\npublic String getName(String x){return x;};\r\n}\r\n\r\n发布wsdd的文件 deploy.wsdd\r\n\r\n&lt;deployment xmlns=\"http://xml.apache.org/axis/wsdd/\" xmlns:java=\"http://xml.apache.org/axis/wsdd/providers/java\"&gt;\r\n&lt;service name=\"HelloWorld\" provider=\"java:RPC\"&gt;//服务名\r\n&lt;parameter name=\"className\" value=\"com.sev.HelloWorld\"/&gt;//具体的类\r\n&lt;parameter name=\"allowedMethods\" value=\"*\"/&gt;//公开类中所有的方法\r\n&lt;/service&gt;\r\n&lt;/deployment&gt;\r\n\r\n取消服务的文件 undeploy.wsdd\r\n\r\n&lt;undeployment xmlns=\"http://xml.apache.org/axis/wsdd/\" &gt;\r\n&lt;service name=\"HelloWorld\" /&gt;//服务名\r\n&lt;/undeployment&gt;\r\n\r\n定义上面两个文件后 确保服务器 是启动状态拷贝2个文件到 web程序下比如\r\n\r\nE:\\Apache Software Foundation\\Tomcat 6.0\\webapps\\axis\\WEB-INF 如果你需要发布web服务 打开命令行 cmd 输入如下命令就是用如下命令\r\n\r\nE:\\Apache Software Foundation\\Tomcat 6.0\\webapps\\axis\\WEB-INF&gt;<strong>java -Djava.ext.di</strong>\r\n<strong>rs=lib org.apache.axis.client.AdminClient -lhttp://localhost:8081/axis/servlet/A</strong>\r\n<strong>xisServlet deploy.wsdd </strong>\r\n\r\n取消就是\r\n\r\nE:\\Apache Software Foundation\\Tomcat 6.0\\webapps\\axis\\WEB-INF&gt;<strong>java -Djava.ext.di</strong>\r\n<strong>rs=lib org.apache.axis.client.AdminClient -lhttp://localhost:8081/axis/servlet/A</strong>\r\n<strong>xisServlet undeploy.wsdd </strong>\r\n\r\n对于wsdd 方式发布 请确保你的web.xml的文件含有如下信息\r\n\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;/servlet/AxisServlet&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n\r\n客户端的访问方式 这里就不再给出 与即时发布是一样的\r\n\r\n<strong>复杂对象的处理 </strong>\r\n\r\n下面以一个User例子来说明\r\n\r\n定义User类 并添加 set/get方法\r\n\r\npublic class User implements Serializable {\r\nprivate static final long serialVersionUID = 677484458789332877L;\r\nprivate int id;\r\nprivate String name;\r\nprivate String email;\r\nprivate String address;\r\n}\r\n\r\n定义业务类ManagerUser\r\n\r\npublic class ManagerUser {\r\n\r\npublic User getUserByName(String name) {\r\nUser user = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(name);\r\nuser.setAddress(\"china\");\r\nuser.setEmail(name + \"@hoo.com\");\r\nreturn user;\r\n}\r\n\r\npublic void setUser(User user) {\r\nSystem.out.println(user);\r\n}\r\n\r\npublic List&lt;User&gt; getUsers(int i) {\r\nList&lt;User&gt; users = new ArrayList&lt;User&gt;();\r\nfor (int j = 0; j &lt;= i; j++) {\r\nUser user = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(\"jack#\" + j);\r\nuser.setAddress(\"china\");\r\nuser.setEmail(\"jack\" + j + \"@hoo.com\");\r\nusers.add(user);\r\n}\r\nreturn users;\r\n}\r\n\r\npublic void setUserMap(Map&lt;String, User&gt; maps) {\r\nSystem.out.println(maps);\r\n}\r\n\r\npublic User[] getUserArray(int i) {\r\nUser[] users = new User[i];\r\nfor (int j = 0; j &lt; i; j++) {\r\nUser user = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(\"jack#\" + j);\r\nuser.setAddress(\"china\");\r\nuser.setEmail(\"jack\" + j + \"@hoo.com\");\r\nusers[j] = user;\r\n}\r\nreturn users;\r\n}\r\n\r\npublic void setUserArray(User[] users) {\r\nfor (User u : users) {\r\nSystem.out.println(u);\r\n}\r\n}\r\n\r\npublic Map&lt;String, User&gt; getUserMap() {\r\nMap&lt;String, User&gt; users = new HashMap&lt;String, User&gt;();\r\nUser user = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(\"jack#\");\r\nuser.setAddress(\"china\");\r\nuser.setEmail(\"jack@hoo.com\");\r\nusers.put(\"A\", user);\r\n\r\nuser = new User();\r\nuser.setId(new Date().getSeconds());\r\nuser.setName(\"tom\");\r\nuser.setAddress(\"china\");\r\nuser.setEmail(\"tom@hoo.com\");\r\nusers.put(\"B\", user);\r\nreturn users;\r\n}\r\n\r\npublic void setUsers(List&lt;User&gt; users) {\r\nfor (User u : users) {\r\nSystem.out.println(u);\r\n}\r\n}\r\n}\r\n\r\n业务类和自定义类都是简单的一些类和方法axis对于复杂对象的处理关键是对WSDD的定义下面是 该WSDD\r\n\r\n&lt;deployment xmlns=\"http://xml.apache.org/axis/wsdd/\"\r\nxmlns:java=\"http://xml.apache.org/axis/wsdd/providers/java\"&gt;\r\n&lt;service name=\"ManagerUser\" provider=\"java:RPC\"&gt;\r\n&lt;parameter name=\"className\" value=\"com.sev.ManagerUser\" /&gt;\r\n&lt;parameter name=\"allowedMethods\" value=\"*\" /&gt;\r\n&lt;parameter name=\"scope\" value=\"request\" /&gt;\r\n&lt;!-- 这里的urn:User和new QName(\"urn:User\", \"User\")这里是对应的 --&gt;\r\n&lt;beanMapping qname=\"myNSD:User\" xmlns:myNSD=\"urn:User\" languageSpecificType=\"java:com.sev.User\"/&gt;\r\n&lt;/service&gt;\r\n&lt;/deployment&gt;\r\n\r\n这里关键的是 beanMapping 设置 很容易理解这里的设置 详细的不再赘述  可以查看官方文档获取更详细的说明。对于复杂对象客户端的访问会有所不同需要指明访问参数的对象类型以及返回类型等等 如采用非生成客户端来访问的话需要如下设置\r\n\r\nCall call = (Call) service.createCall();\r\ncall.setTargetEndpointAddress(\"http://localhost:8081/axis/services/ManagerUser\");\r\n//这里的QName的ns和wsdd文件中的对应\r\nQName qn = new QName(\"urn:User\", \"User\");\r\n//这里是将对象序列化和反序列化的配置\r\ncall.registerTypeMapping(User.class, qn, new BeanSerializerFactory(User.class, qn), new BeanDeserializerFactory(User.class, qn));\r\ncall.setOperationName(\"setUser\");\r\n//设置参数类型\r\ncall.addParameter(\"user\", qn, ParameterMode.IN);\r\n\r\n//如果返回类型是User需要如下设置call.setReturnClass(User.class);\r\ncall.invoke(new Object[] { user });\r\n\r\n&nbsp;','JAX-RPC开发Web服务之(Apache axis 1.4) -4','','inherit','open','open','','62-revision-v1','','','2013-08-23 13:49:17','2013-08-23 05:49:17','',62,'http://localhost/wordpress-new/?p=63',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (64,1,'2013-08-23 13:49:43','2013-08-23 05:49:43','什么是 REST？\r\n\r\nSOA 通常是用 SOAP 协议实现的，服务由一个 WSDL（Web Services Description Language, Web 服务描述语言）文档来描述。尽管有许多开发工具大大简化了对 SOAP 和 WSDL 的处理过程，但是我仍然把它们看作重型技术，因为如果不使用这些工具，SOAP 和 WSDL 是很难处理的。\r\n\r\n也可以通过超文本传输协议（HTTP）发送简单的消息来实现 SOA。这基本上就是 REST 式 Web 服务 (RESTful Web services) 的工作方式。Representational State Transfer（简称 REST，中文翻译“具象状态传输”。REST 这个名称是由 Roy Fielding 首创的）并不是一个协议或技术；它是一种体系结构风格。REST 是 SOAP 的轻量型替代品，它是面向资源的，而不是面向操作的。它常常被归结为远程过程使用 HTTP 调用 GET、POST、PUT 和 DELETE 语句。我认为，这只是第二个重要的步骤。\r\n\r\n第一个（也是最重要的）步骤是把所有资源建模为 URL 形式。URL 容易记忆，同时能够访问无数 Web 页面。至少，如果建模方式适当的话，很容易记住 URL（比如 http://www.ibm.com/developerworks/xml/）。如果过分重视 GET、POST、PUT 和 DELETE，就可能产生不容易记忆的 URL，比如 http://www.longfakeurl.com/pol_srdm/70612/9,3993.32?id=78688&amp;lang=cz&amp;st=idx。\r\n\r\n在实践中，使用 HTTP 的方法可以进一步限制为 GET 和 POST 两种方法，因为大多数浏览器对它们的支持很完善。可以对 http://domain.com/myresources/new 执行 POST，以替代对 http://domain.com/myresources 执行 PUT；对 http://domain.com/myresources/oldresource/delete 执行 POST，以替代对 http://domain.com/myresources/oldresource 执行 DELETE。\r\n\r\nREST 式的设计过程\r\n\r\n在设计 REST 式 Web 服务时，可以采用以下四个步骤：\r\n决定资源及其描述性 URL。\r\n为每个 URL 上的通信选择一种数据格式。\r\n指定每个资源上的方法。\r\n指定返回的数据和状态码。\r\n\r\n以下是具体的设计过程。假设您是一家航空公司的开发人员。公司有用于预订航班的软件，还有处理付款（现金和信用卡）的组件。它使用软件跟踪包裹、执行内部资源规划和执行许多其他任务。\r\n\r\n假设机场登记处的职员使用一个客户机应用程序，这个程序访问包裹跟踪服务，还使用一个服务为乘客分配座位。处理包裹的地勤人员只需要包裹跟踪服务，不需要其他服务。他们的客户机只允许他们确认已经登记的包裹是否到达了。不允许他们登记新的包裹。\r\n\r\n在这个示例中，我们将设计包裹跟踪服务。首先，决定资源：旅行者、航班和包裹（注意，在出现 {id} 的任何地方，都可以填写任意数字）： http://luggagetracking.airlinecompany.com/bags/{id}\r\nhttp://luggagetracking.airlinecompany.com/flights/{id}\r\nhttp://luggagetracking.airlinecompany.com/travellers/{id}\r\n\r\n为每个资源选择一种数据格式：\r\n\r\n包裹： &lt;bag id=\"{id}\"&gt;\r\n&lt;traveller id=\"{traveller-id}\"/&gt;\r\n&lt;flight id=\"{flight-id}\" /&gt;\r\n&lt;status&gt;{current-status: departure/plane/arrival}&lt;/status&gt;\r\n&lt;/bag&gt;\r\n\r\n航班： &lt;flight id=\"{id}\"&gt;\r\n&lt;travellers&gt;\r\n&lt;traveller id=\"{traveller-id-0}\" /&gt;\r\n&lt;traveller id=\"{traveller-id-1}\" /&gt;\r\n&lt;traveller id=\"{traveller-id-2}\" /&gt;\r\n&lt;/travellers&gt;\r\n&lt;bags&gt;\r\n&lt;bag id=\"{bag-id-0}\" /&gt;\r\n&lt;bag id=\"{bag-id-1}\" /&gt;\r\n&lt;bag id=\"{bag-id-2}\" /&gt;\r\n&lt;/bags&gt;\r\n&lt;/flight&gt;\r\n\r\n乘客： &lt;traveller id=\"{id}\"&gt;\r\n&lt;flight id=\"{flight-id}\" /&gt;\r\n&lt;bags&gt;\r\n&lt;bag id=\"{bag-id-0}\" /&gt;\r\n&lt;bag id=\"{bag-id-1}\" /&gt;\r\n&lt;bag id=\"{bag-id-2}\" /&gt;\r\n&lt;/bags&gt;\r\n&lt;/traveller&gt;\r\n\r\n显然，这个模型过于简单了。对于当前的示例，只需要支持两个方法，因此这个模型已经足够了。登记处应该能够为乘客登记新包裹。在把包裹装进飞机时，地勤人员应该能够修改包裹的状态：\r\n对 http://luggagetrackingairlinecompany.com/travellers/{id}/newbag 执行 POST，返回一个 &lt;bag&gt;XML 结构。\r\n对 http://luggagetracking.airlinecompany.com/bags/{id}/status/{newstatus} 执行 POST，返回修改后的 XML 结构。\r\n\r\n使用标准的 HTTP 状态作为状态码。成功的操作都会返回 200。如果系统无法根据资源的 ID 找到它，就会返回 404。系统故障导致的任何错误都会返回 500。\r\n\r\n代码示例：URL 映射\r\n\r\n可以使用多种方式把 URL 映射到实现方法。比较先进的方法可能更灵活，应该用在比较大的应用程序中。这个小示例使用最简单的方法：正则表达式。下面是 BagServlet 上的 post 方法示例，它把 URL 参数传递给底层 servlet。可以在本文的下载文件中找到完整的 servlet 代码。注意，这里没有实现实际的底层服务。 以下是该示例： protected void doPost(HttpServletRequest request, HttpServletResponse response)\r\nthrows ServletException, IOException {\r\n\r\nPattern pattern = Pattern.compile(\"^/?.*?/bags/(.*)/status/(.*)$\");\r\nMatcher matcher = pattern.matcher(request.getRequestURI());\r\n\r\nif(matcher.matches()) {\r\nString bagId = matcher.group(1);\r\nString newStatus = matcher.group(2);\r\nbagService.changeBagStatus(bagId, newStatus);\r\n}\r\n}\r\n\r\n在调用这个 URL 时，如果成功，就会隐式地返回状态码 200。更有意义的是，代码返回 XML 结构。这个示例使用 XStream API 把 Java™ 对象转换成 XML 结构。这个 API 需要的配置非常少，而且主要根据类中的字段名选择元素名。\r\n\r\n这个示例代码使用下面这些简单的类：\r\n\r\n航班： package eu.adraandejonge.restfulsoa;\r\n\r\npublic class Flight {\r\nString id;\r\n\r\npublic Flight(String id) {\r\nsuper();\r\nthis.id = id;\r\n}\r\n}\r\n\r\n乘客： package eu.adraandejonge.restfulsoa;\r\n\r\npublic class Traveller {\r\nprivate String id;\r\n\r\npublic Traveller(String id) {\r\nsuper();\r\nthis.id = id;\r\n}\r\n}\r\n\r\n包裹： package eu.adraandejonge.restfulsoa;\r\n\r\npublic class Bag {\r\nprivate String id;\r\nprivate Flight flight;\r\nprivate Traveller traveller;\r\nprivate String status;\r\n\r\npublic Bag(String id, Flight flight, Traveller traveller, String status) {\r\nsuper();\r\nthis.id = id;\r\nthis.flight = flight;\r\nthis.traveller = traveller;\r\nthis.status = status;\r\n}\r\n}\r\n\r\n假设底层的 BagService 返回一个包裹，包裹的航班 ID 是 1，乘客 ID 是 1，状态是 new。请考虑下面的 GET 实现： protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\nthrows ServletException, IOException {\r\n\r\nPattern pattern = Pattern.compile(\"^/?.*?/bags/(.*)$\");\r\nMatcher matcher = pattern.matcher(request.getRequestURI());\r\n\r\nif (matcher.matches()) {\r\nString bagId = matcher.group(1);\r\n\r\nBag bag = bagService.retrieveBag(bagId);\r\n\r\nXStream xstream = new XStream();\r\nxstream.alias(\"bag\", Bag.class);\r\nxstream.alias(\"traveller\", Traveller.class);\r\nxstream.alias(\"flight\", Flight.class);\r\n\r\nxstream.useAttributeFor(Bag.class, \"id\");\r\nxstream.useAttributeFor(Traveller.class, \"id\");\r\nxstream.useAttributeFor(Flight.class, \"id\");\r\n\r\nString xml = xstream.toXML(bag);\r\nresponse.getWriter().write(xml);\r\n}\r\n}\r\n\r\n在查询这个 URL 时，它会返回以下信息： &lt;bag id=\"1\"&gt;\r\n&lt;flight id=\"1\"/&gt;\r\n&lt;traveller id=\"1\"/&gt;\r\n&lt;status&gt;new&lt;/status&gt;\r\n&lt;/bag&gt;\r\n\r\n回页首\r\n\r\n还能做什么？\r\n\r\n我选择这些示例代码是为了说明，不需要很多底层通信，URL 也能够实现很多功能。对于其他服务，可能需要处理上传给 REST 服务的 XML 结构。XStream 也可以帮助完成这个任务。例如，要想对包裹的 XML 结构进行去序列化，应该调用： Bag bag = (Bag) xstream.fromXML(xml);\r\n\r\n客户机上的应用程序\r\n\r\n到目前为止，本文已经讨论了服务器端的实现。客户端上的代码非常相似。客户机可以共享数据类 Flight、Traveller 和 Bag，并使用 XStream API 对 XML 进行序列化和去序列化。客户机上惟一的新部分是连接 URL 并读取内容或发送内容。通过使用 Java 类库提供的 URL 连接，很容易完成这个任务： String xml = \"&lt;newinput&gt;input&lt;/newinput&gt;\";\r\n\r\nURL url = new URL(\"http://luggagetracking.airlinecompany.com/bags/1/newmethod\");\r\nURLConnection connection = url.openConnection();\r\n\r\n// set POST\r\nconnection.setDoOutput(true);\r\nWriter output = new OutputStreamWriter(connectiongetOutputStream());\r\noutput.write(xml);\r\noutput.close();\r\n\r\n// display result\r\nBufferedReader input = new BufferedReader(\r\nnew InputStreamReader(connection.getInputStream()));\r\n\r\nString decodedString;\r\nwhile ((decodedString = input.readLine()) != null) {\r\nSystem.out.println(decodedString);\r\n}\r\ninput.close();\r\n\r\n与 Ruby on Rails 等技术的互操作性\r\n\r\n尽管 REST 并没有明确的规范来规定如何实现它，但是对 REST 的开箱即用支持越来越多了。因此，虽然没有需要遵循的标准，但是您需要遵守一些约定。例如，Ruby on Rails 提供 ActiveResource。如果遵守 Rails 对 URL 和输出格式的约定，就很容易用最小的开销把 Rails Web 客户机连接到 Java REST 式 Web 服务。\r\n\r\n可伸缩性和向重型 SOA 的迁移\r\n\r\n随着应用程序环境的增长，很可能会对越来越多的 REST 实现细节进行抽象。当增长和抽象发展到一定程度之后，从轻量型技术迁移到重型的 SOA 技术可能会节省成本。这需要把服务背后的实际业务逻辑提取出来，并重新包装在新环境中的一个 SOAP 包中，这个过程应该不是太难。\r\n\r\n<strong>小结</strong>\r\n\r\nREST 更适合与小型的应用对于 企业来说使用SOA可能更合适 REST放弃使用WSDL等复杂的设置采用简单的XML来传递信息适合简单的运用 比如 天气，广告 其中RSS聚合新闻就比较适合REST风格的实际上很多RSS也就是采用RSS的风格来做的对于天气，广告返回一个简单的XML更方便。实际上REST采用Atom或者是RSS联合格式的XML数据','使用 XML 实现 REST 式的 SOA','','publish','open','open','','%e4%bd%bf%e7%94%a8-xml-%e5%ae%9e%e7%8e%b0-rest-%e5%bc%8f%e7%9a%84-soa','','','2013-08-23 13:49:43','2013-08-23 05:49:43','',0,'http://localhost/wordpress-new/?p=64',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (65,1,'2013-08-23 13:49:43','2013-08-23 05:49:43','什么是 REST？\r\n\r\nSOA 通常是用 SOAP 协议实现的，服务由一个 WSDL（Web Services Description Language, Web 服务描述语言）文档来描述。尽管有许多开发工具大大简化了对 SOAP 和 WSDL 的处理过程，但是我仍然把它们看作重型技术，因为如果不使用这些工具，SOAP 和 WSDL 是很难处理的。\r\n\r\n也可以通过超文本传输协议（HTTP）发送简单的消息来实现 SOA。这基本上就是 REST 式 Web 服务 (RESTful Web services) 的工作方式。Representational State Transfer（简称 REST，中文翻译“具象状态传输”。REST 这个名称是由 Roy Fielding 首创的）并不是一个协议或技术；它是一种体系结构风格。REST 是 SOAP 的轻量型替代品，它是面向资源的，而不是面向操作的。它常常被归结为远程过程使用 HTTP 调用 GET、POST、PUT 和 DELETE 语句。我认为，这只是第二个重要的步骤。\r\n\r\n第一个（也是最重要的）步骤是把所有资源建模为 URL 形式。URL 容易记忆，同时能够访问无数 Web 页面。至少，如果建模方式适当的话，很容易记住 URL（比如 http://www.ibm.com/developerworks/xml/）。如果过分重视 GET、POST、PUT 和 DELETE，就可能产生不容易记忆的 URL，比如 http://www.longfakeurl.com/pol_srdm/70612/9,3993.32?id=78688&amp;lang=cz&amp;st=idx。\r\n\r\n在实践中，使用 HTTP 的方法可以进一步限制为 GET 和 POST 两种方法，因为大多数浏览器对它们的支持很完善。可以对 http://domain.com/myresources/new 执行 POST，以替代对 http://domain.com/myresources 执行 PUT；对 http://domain.com/myresources/oldresource/delete 执行 POST，以替代对 http://domain.com/myresources/oldresource 执行 DELETE。\r\n\r\nREST 式的设计过程\r\n\r\n在设计 REST 式 Web 服务时，可以采用以下四个步骤：\r\n决定资源及其描述性 URL。\r\n为每个 URL 上的通信选择一种数据格式。\r\n指定每个资源上的方法。\r\n指定返回的数据和状态码。\r\n\r\n以下是具体的设计过程。假设您是一家航空公司的开发人员。公司有用于预订航班的软件，还有处理付款（现金和信用卡）的组件。它使用软件跟踪包裹、执行内部资源规划和执行许多其他任务。\r\n\r\n假设机场登记处的职员使用一个客户机应用程序，这个程序访问包裹跟踪服务，还使用一个服务为乘客分配座位。处理包裹的地勤人员只需要包裹跟踪服务，不需要其他服务。他们的客户机只允许他们确认已经登记的包裹是否到达了。不允许他们登记新的包裹。\r\n\r\n在这个示例中，我们将设计包裹跟踪服务。首先，决定资源：旅行者、航班和包裹（注意，在出现 {id} 的任何地方，都可以填写任意数字）： http://luggagetracking.airlinecompany.com/bags/{id}\r\nhttp://luggagetracking.airlinecompany.com/flights/{id}\r\nhttp://luggagetracking.airlinecompany.com/travellers/{id}\r\n\r\n为每个资源选择一种数据格式：\r\n\r\n包裹： &lt;bag id=\"{id}\"&gt;\r\n&lt;traveller id=\"{traveller-id}\"/&gt;\r\n&lt;flight id=\"{flight-id}\" /&gt;\r\n&lt;status&gt;{current-status: departure/plane/arrival}&lt;/status&gt;\r\n&lt;/bag&gt;\r\n\r\n航班： &lt;flight id=\"{id}\"&gt;\r\n&lt;travellers&gt;\r\n&lt;traveller id=\"{traveller-id-0}\" /&gt;\r\n&lt;traveller id=\"{traveller-id-1}\" /&gt;\r\n&lt;traveller id=\"{traveller-id-2}\" /&gt;\r\n&lt;/travellers&gt;\r\n&lt;bags&gt;\r\n&lt;bag id=\"{bag-id-0}\" /&gt;\r\n&lt;bag id=\"{bag-id-1}\" /&gt;\r\n&lt;bag id=\"{bag-id-2}\" /&gt;\r\n&lt;/bags&gt;\r\n&lt;/flight&gt;\r\n\r\n乘客： &lt;traveller id=\"{id}\"&gt;\r\n&lt;flight id=\"{flight-id}\" /&gt;\r\n&lt;bags&gt;\r\n&lt;bag id=\"{bag-id-0}\" /&gt;\r\n&lt;bag id=\"{bag-id-1}\" /&gt;\r\n&lt;bag id=\"{bag-id-2}\" /&gt;\r\n&lt;/bags&gt;\r\n&lt;/traveller&gt;\r\n\r\n显然，这个模型过于简单了。对于当前的示例，只需要支持两个方法，因此这个模型已经足够了。登记处应该能够为乘客登记新包裹。在把包裹装进飞机时，地勤人员应该能够修改包裹的状态：\r\n对 http://luggagetrackingairlinecompany.com/travellers/{id}/newbag 执行 POST，返回一个 &lt;bag&gt;XML 结构。\r\n对 http://luggagetracking.airlinecompany.com/bags/{id}/status/{newstatus} 执行 POST，返回修改后的 XML 结构。\r\n\r\n使用标准的 HTTP 状态作为状态码。成功的操作都会返回 200。如果系统无法根据资源的 ID 找到它，就会返回 404。系统故障导致的任何错误都会返回 500。\r\n\r\n代码示例：URL 映射\r\n\r\n可以使用多种方式把 URL 映射到实现方法。比较先进的方法可能更灵活，应该用在比较大的应用程序中。这个小示例使用最简单的方法：正则表达式。下面是 BagServlet 上的 post 方法示例，它把 URL 参数传递给底层 servlet。可以在本文的下载文件中找到完整的 servlet 代码。注意，这里没有实现实际的底层服务。 以下是该示例： protected void doPost(HttpServletRequest request, HttpServletResponse response)\r\nthrows ServletException, IOException {\r\n\r\nPattern pattern = Pattern.compile(\"^/?.*?/bags/(.*)/status/(.*)$\");\r\nMatcher matcher = pattern.matcher(request.getRequestURI());\r\n\r\nif(matcher.matches()) {\r\nString bagId = matcher.group(1);\r\nString newStatus = matcher.group(2);\r\nbagService.changeBagStatus(bagId, newStatus);\r\n}\r\n}\r\n\r\n在调用这个 URL 时，如果成功，就会隐式地返回状态码 200。更有意义的是，代码返回 XML 结构。这个示例使用 XStream API 把 Java™ 对象转换成 XML 结构。这个 API 需要的配置非常少，而且主要根据类中的字段名选择元素名。\r\n\r\n这个示例代码使用下面这些简单的类：\r\n\r\n航班： package eu.adraandejonge.restfulsoa;\r\n\r\npublic class Flight {\r\nString id;\r\n\r\npublic Flight(String id) {\r\nsuper();\r\nthis.id = id;\r\n}\r\n}\r\n\r\n乘客： package eu.adraandejonge.restfulsoa;\r\n\r\npublic class Traveller {\r\nprivate String id;\r\n\r\npublic Traveller(String id) {\r\nsuper();\r\nthis.id = id;\r\n}\r\n}\r\n\r\n包裹： package eu.adraandejonge.restfulsoa;\r\n\r\npublic class Bag {\r\nprivate String id;\r\nprivate Flight flight;\r\nprivate Traveller traveller;\r\nprivate String status;\r\n\r\npublic Bag(String id, Flight flight, Traveller traveller, String status) {\r\nsuper();\r\nthis.id = id;\r\nthis.flight = flight;\r\nthis.traveller = traveller;\r\nthis.status = status;\r\n}\r\n}\r\n\r\n假设底层的 BagService 返回一个包裹，包裹的航班 ID 是 1，乘客 ID 是 1，状态是 new。请考虑下面的 GET 实现： protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\nthrows ServletException, IOException {\r\n\r\nPattern pattern = Pattern.compile(\"^/?.*?/bags/(.*)$\");\r\nMatcher matcher = pattern.matcher(request.getRequestURI());\r\n\r\nif (matcher.matches()) {\r\nString bagId = matcher.group(1);\r\n\r\nBag bag = bagService.retrieveBag(bagId);\r\n\r\nXStream xstream = new XStream();\r\nxstream.alias(\"bag\", Bag.class);\r\nxstream.alias(\"traveller\", Traveller.class);\r\nxstream.alias(\"flight\", Flight.class);\r\n\r\nxstream.useAttributeFor(Bag.class, \"id\");\r\nxstream.useAttributeFor(Traveller.class, \"id\");\r\nxstream.useAttributeFor(Flight.class, \"id\");\r\n\r\nString xml = xstream.toXML(bag);\r\nresponse.getWriter().write(xml);\r\n}\r\n}\r\n\r\n在查询这个 URL 时，它会返回以下信息： &lt;bag id=\"1\"&gt;\r\n&lt;flight id=\"1\"/&gt;\r\n&lt;traveller id=\"1\"/&gt;\r\n&lt;status&gt;new&lt;/status&gt;\r\n&lt;/bag&gt;\r\n\r\n回页首\r\n\r\n还能做什么？\r\n\r\n我选择这些示例代码是为了说明，不需要很多底层通信，URL 也能够实现很多功能。对于其他服务，可能需要处理上传给 REST 服务的 XML 结构。XStream 也可以帮助完成这个任务。例如，要想对包裹的 XML 结构进行去序列化，应该调用： Bag bag = (Bag) xstream.fromXML(xml);\r\n\r\n客户机上的应用程序\r\n\r\n到目前为止，本文已经讨论了服务器端的实现。客户端上的代码非常相似。客户机可以共享数据类 Flight、Traveller 和 Bag，并使用 XStream API 对 XML 进行序列化和去序列化。客户机上惟一的新部分是连接 URL 并读取内容或发送内容。通过使用 Java 类库提供的 URL 连接，很容易完成这个任务： String xml = \"&lt;newinput&gt;input&lt;/newinput&gt;\";\r\n\r\nURL url = new URL(\"http://luggagetracking.airlinecompany.com/bags/1/newmethod\");\r\nURLConnection connection = url.openConnection();\r\n\r\n// set POST\r\nconnection.setDoOutput(true);\r\nWriter output = new OutputStreamWriter(connectiongetOutputStream());\r\noutput.write(xml);\r\noutput.close();\r\n\r\n// display result\r\nBufferedReader input = new BufferedReader(\r\nnew InputStreamReader(connection.getInputStream()));\r\n\r\nString decodedString;\r\nwhile ((decodedString = input.readLine()) != null) {\r\nSystem.out.println(decodedString);\r\n}\r\ninput.close();\r\n\r\n与 Ruby on Rails 等技术的互操作性\r\n\r\n尽管 REST 并没有明确的规范来规定如何实现它，但是对 REST 的开箱即用支持越来越多了。因此，虽然没有需要遵循的标准，但是您需要遵守一些约定。例如，Ruby on Rails 提供 ActiveResource。如果遵守 Rails 对 URL 和输出格式的约定，就很容易用最小的开销把 Rails Web 客户机连接到 Java REST 式 Web 服务。\r\n\r\n可伸缩性和向重型 SOA 的迁移\r\n\r\n随着应用程序环境的增长，很可能会对越来越多的 REST 实现细节进行抽象。当增长和抽象发展到一定程度之后，从轻量型技术迁移到重型的 SOA 技术可能会节省成本。这需要把服务背后的实际业务逻辑提取出来，并重新包装在新环境中的一个 SOAP 包中，这个过程应该不是太难。\r\n\r\n<strong>小结</strong>\r\n\r\nREST 更适合与小型的应用对于 企业来说使用SOA可能更合适 REST放弃使用WSDL等复杂的设置采用简单的XML来传递信息适合简单的运用 比如 天气，广告 其中RSS聚合新闻就比较适合REST风格的实际上很多RSS也就是采用RSS的风格来做的对于天气，广告返回一个简单的XML更方便。实际上REST采用Atom或者是RSS联合格式的XML数据','使用 XML 实现 REST 式的 SOA','','inherit','open','open','','64-revision-v1','','','2013-08-23 13:49:43','2013-08-23 05:49:43','',64,'http://localhost/wordpress-new/?p=65',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (66,1,'2013-08-23 13:50:13','2013-08-23 05:50:13','数据绑定风靡一时\r\n\r\n在 XML 新闻组、邮件列表和网站的讨论论坛中（在 参考资料 中可以找到这些内容的链接），最常见的一个主题就是数据绑定。Java 和 XML 开发人员正在寻求一种在 Java 对象与 XML 文档之间来回转换的简单方法。\r\n\r\nSun 借助其 JAXB，即 Java Architecture for XML Binding（如果您在其他地方看到缩写词 JAXB，那也是正常的；Sun 似乎每年都会更改 JAXB 所代表的含义）， 在数据绑定领域占据了主导地位。然而，JAXB API（如果您喜欢，也可以称为架构）存在着一些不足，并且更新速度较慢。它也不能处理到关系数据库的映射，而这种映射是一种很常见的请求。\r\n\r\nCastor 的诞生\r\n\r\n正是在这种情形下，Castor 出现了。Castor 是一种开源框架，它可用于无法使用 JAXB 的领域。Castor 一直在发展之中，并且早于 JAXB 代码库和 SUN 数据绑定规范。实际上，Castor 已经实现了更新，可结合 JAXB 方法实现数据绑定，因此使用 JAXB 的编程人员可以很容易地移动代码。\r\n\r\nCastor 的优势\r\n\r\n在讨论安装和使用 Castor 的细节之前，有必要指出尝试 Castor 以及从 JAXB 转变到 Castor 的理由。\r\n首先，Castor 几乎是 JAXB 的替代品。换句话说，可以轻易地将所有 JAXB 代码转变为 Castor（并不是完全取代，但是足以使刚刚接触 Castor 的程序员轻松完成任务）。\r\n其次，Castor 在数据绑定领域提供了许多的功能，无需使用模式便可在 Java 和 XML 之间进行转换，提供一种比 JAXB 更易于使用的绑定模式，以及能够对关系数据库和 XML 文档进行编组（marshal）和解组（unmarshal）。\r\nCastor 还提供了 JDO 功能。JDO 也就是 Java Data Objects，是驱动 Java-to-RDBMS 编组和解组的底层技术。尽管不再像前几年那么流行，JDO 仍然是一个不错的功能。此外，由于 JDO 也是一种 Sun 规范，因此不用编写模糊的 API。\r\n\r\n下面来看个例子如何实现java对象与xml文档之间的转换\r\n\r\n<strong>CD </strong>\r\n\r\npublic class CD implements java.io.Serializable {\r\nprivate String name = null;\r\nprivate String artist = null;\r\nprivate List tracks = null;\r\n}\r\n\r\n<strong>MarshalTester //编组</strong>\r\n\r\nimport java.io.FileWriter;\r\nimport org.exolab.castor.xml.Marshaller;\r\nCD sessions = new CD(\"Sessions for Robert J\", \"Eric Clapton\");\r\nsessions.addTrack(\"Little Queen of Spades\");\r\nsessions.addTrack(\"Terraplane Blues\");\r\nFileWriter writer = new FileWriter(\"cds.xml\");\r\nMarshaller.marshal(sessions, writer);\r\n\r\n<strong>UnmarshalTester </strong>//解组\r\n\r\nimport java.io.FileReader;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport org.exolab.castor.xml.Unmarshaller;\r\nFileReader reader = new FileReader(\"cds.xml\");\r\nCD cd = (CD)Unmarshaller.unmarshal(CD.class, reader);\r\nSystem.out.println(\"CD title: \" + cd.getName());\r\nSystem.out.println(\"CD artist: \" + cd.getArtist());\r\nList tracks = cd.getTracks();\r\nif (tracks == null) {\r\nSystem.out.println(\"No tracks.\");\r\n} else {\r\nfor (Iterator i = tracks.iterator(); i.hasNext(); ) {\r\nSystem.out.println(\"Track: \" + i.next());\r\n}\r\n}\r\n\r\n<strong>cds.xml  的内容应该如下</strong>\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;CD&gt;\r\n&lt;artist&gt;Eric Clapton&lt;/artist&gt;\r\n&lt;name&gt;Sessions for Robert J&lt;/name&gt;\r\n&lt;tracks xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\nxsi:type=\"java:java.lang.String\"&gt;Little Queen of Spades&lt;/tracks&gt;\r\n&lt;tracks xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\nxsi:type=\"java:java.lang.String\"&gt;Terraplane Blues&lt;/tracks&gt;\r\n&lt;/CD&gt;\r\n\r\n<strong>小结由此可见使用castor转换很方便但也有需要注意的地方</strong>\r\n\r\n<strong>Castor 要求使用无参数的构造器</strong>\r\n\r\n<strong>Castor 主要通过反射和调用 Class.forName(类名).newInstance() 这样的方法进行解组，因而 Castor 不需要了解很多就能实例化类。但是，它还要求类必须能通过不带参数的构造器实例化。 当前是在castor-1.1.2.1 版本下测试的 对于后续版本是否会解决这些问题请查看官方网站</strong>\r\n\r\n注意当前  <strong>castor-1.1.2.1版本除了castor提供的核心包以外还需要如下的包在运行代码的时候请把它们添加到classpath</strong>\r\n\r\nxerces-J_1.4.0.jar//解析xml  commons-logging-1.0.4.jar//日志包\r\n\r\n有的时候我们的环境不是很理想比如java类的属性与我们需要转换的xml在名称以及格式上有冲突或者不理想我们可以采用映射文件mapping的方式来指定如何编组和解组java类或xml文件例子如下\r\n\r\n<strong>Book </strong>\r\npublic class Book {\r\nprivate String isbn;\r\nprivate String title;\r\nprivate List&lt;Author&gt; authors ;\r\npublic Book() { }\r\n\r\npublic Book(String isbn, String title, List&lt;Author&gt; authors) {\r\nthis.isbn = isbn;\r\nthis.title = title;\r\nthis.authors = authors;\r\n}\r\n\r\npublic Book(String isbn, String title, Author author) {\r\nthis.isbn = isbn;\r\nthis.title = title;\r\nthis.authors = new LinkedList&lt;Author&gt;();\r\nauthors.add(author);\r\n}\r\n\r\npublic void setIsbn(String isbn) {\r\nthis.isbn = isbn;\r\n}\r\n\r\npublic String getIsbn() {\r\nreturn isbn;\r\n}\r\n\r\npublic void setTitle(String title) {\r\nthis.title = title;\r\n}\r\n\r\npublic String getTitle() {\r\nreturn title;\r\n}\r\n\r\npublic void setAuthors(List&lt;Author&gt; authors) {\r\nthis.authors = authors;\r\n}\r\n\r\npublic List&lt;Author&gt; getAuthors() {\r\nreturn authors;\r\n}\r\n\r\npublic void addAuthor(Author author) {\r\nauthors.add(author);\r\n}\r\n}\r\n\r\n<strong>Author </strong>\r\npublic class Author {\r\n\r\nprivate String firstName, lastName;\r\n\r\npublic Author() { }\r\n\r\npublic Author(String firstName, String lastName) {\r\nthis.firstName = firstName;\r\nthis.lastName = lastName;\r\n}\r\n\r\npublic void setFirstName(String firstName) {\r\nthis.firstName = firstName;\r\n}\r\n\r\npublic void setLastName(String lastName) {\r\nthis.lastName = lastName;\r\n}\r\n\r\npublic String getFirstName() {\r\nreturn firstName;\r\n}\r\n\r\npublic String getLastName() {\r\nreturn lastName;\r\n}\r\n}\r\n<strong>main方法</strong>\r\n\r\nMapping mapping = new Mapping();\r\nmapping.loadMapping(\"d:\\\\book-mapping.xml\");\r\nFileReader reader = new FileReader(\"d:\\\\book.xml\");\r\nUnmarshaller unmarshaller = new Unmarshaller(Book.class);\r\nunmarshaller.setMapping(mapping);\r\nBook book = (Book)unmarshaller.unmarshal(reader);\r\nSystem.out.println(\"Book ISBN: \" + book.getIsbn());\r\nSystem.out.println(\"Book Title: \" + book.getTitle());\r\nList authors = book.getAuthors();\r\nfor (Iterator i = authors.iterator(); i.hasNext(); ) {\r\nAuthor author = (Author)i.next();\r\nSystem.out.println(\"Author: \" + author.getFirstName() + \" \" +\r\nauthor.getLastName());\r\n}\r\n\r\n<strong>book-mapping.xml </strong>\r\n\r\n&lt;?xml version=\"1.0\"?&gt;\r\n&lt;!DOCTYPE mapping PUBLIC \"-//EXOLAB/Castor Mapping DTD Version 1.0//EN\" \"http://castor.org/mapping.dtd\"&gt;\r\n&lt;mapping&gt;\r\n&lt;class name=\"ibm.xml.castor.Book\"&gt;\r\n&lt;map-to xml=\"book\" /&gt;\r\n&lt;field name=\"Title\" type=\"java.lang.String\"&gt;\r\n&lt;bind-xml name=\"title\" node=\"element\" location=\"book-info\" /&gt;\r\n&lt;/field&gt;\r\n&lt;field name=\"Isbn\" type=\"java.lang.String\"&gt;\r\n&lt;bind-xml name=\"isbn\" node=\"element\" location=\"book-info\" /&gt;\r\n&lt;/field&gt;\r\n&lt;field name=\"Authors\" type=\"ibm.xml.castor.Author\" collection=\"vector\"&gt;\r\n&lt;bind-xml name=\"author\" /&gt;\r\n&lt;/field&gt;\r\n&lt;/class&gt;\r\n&lt;class name=\"ibm.xml.castor.Author\"&gt;\r\n&lt;field name=\"FirstName\" type=\"java.lang.String\"&gt;\r\n&lt;bind-xml name=\"first\" node=\"attribute\" location=\"name\" /&gt;\r\n&lt;/field&gt;\r\n&lt;field name=\"LastName\" type=\"java.lang.String\"&gt;\r\n&lt;bind-xml name=\"last\" node=\"attribute\" location=\"name\" /&gt;\r\n&lt;/field&gt;\r\n&lt;/class&gt;\r\n&lt;/mapping&gt;\r\n\r\n<strong>book.xml </strong>\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;book&gt;\r\n&lt;author&gt;\r\n&lt;name first=\"Douglas\" last=\"Preston\" /&gt;\r\n&lt;/author&gt;\r\n&lt;author&gt;\r\n&lt;name first=\"Lincoln\" last=\"Child\" /&gt;\r\n&lt;/author&gt;\r\n&lt;book-info&gt;\r\n&lt;isbn&gt;9780446618502&lt;/isbn&gt;\r\n&lt;title&gt;The Book of the Dead&lt;/title&gt;\r\n&lt;/book-info&gt;\r\n&lt;/book&gt;\r\n\r\n<strong>小结：可见 通过映射文件可以实现更强大的转换，对于mapping映射 文件如何编写以及说明文档可以查看官方文档这里只是对castor做一些介绍,castor还可以通过jdbc把Java 对象绑定到 SQL 数据库。</strong>','实现 Castor 数据绑定','','publish','open','open','','%e5%ae%9e%e7%8e%b0-castor-%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a','','','2013-08-23 13:50:13','2013-08-23 05:50:13','',0,'http://localhost/wordpress-new/?p=66',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (67,1,'2013-08-23 13:50:13','2013-08-23 05:50:13','数据绑定风靡一时\r\n\r\n在 XML 新闻组、邮件列表和网站的讨论论坛中（在 参考资料 中可以找到这些内容的链接），最常见的一个主题就是数据绑定。Java 和 XML 开发人员正在寻求一种在 Java 对象与 XML 文档之间来回转换的简单方法。\r\n\r\nSun 借助其 JAXB，即 Java Architecture for XML Binding（如果您在其他地方看到缩写词 JAXB，那也是正常的；Sun 似乎每年都会更改 JAXB 所代表的含义）， 在数据绑定领域占据了主导地位。然而，JAXB API（如果您喜欢，也可以称为架构）存在着一些不足，并且更新速度较慢。它也不能处理到关系数据库的映射，而这种映射是一种很常见的请求。\r\n\r\nCastor 的诞生\r\n\r\n正是在这种情形下，Castor 出现了。Castor 是一种开源框架，它可用于无法使用 JAXB 的领域。Castor 一直在发展之中，并且早于 JAXB 代码库和 SUN 数据绑定规范。实际上，Castor 已经实现了更新，可结合 JAXB 方法实现数据绑定，因此使用 JAXB 的编程人员可以很容易地移动代码。\r\n\r\nCastor 的优势\r\n\r\n在讨论安装和使用 Castor 的细节之前，有必要指出尝试 Castor 以及从 JAXB 转变到 Castor 的理由。\r\n首先，Castor 几乎是 JAXB 的替代品。换句话说，可以轻易地将所有 JAXB 代码转变为 Castor（并不是完全取代，但是足以使刚刚接触 Castor 的程序员轻松完成任务）。\r\n其次，Castor 在数据绑定领域提供了许多的功能，无需使用模式便可在 Java 和 XML 之间进行转换，提供一种比 JAXB 更易于使用的绑定模式，以及能够对关系数据库和 XML 文档进行编组（marshal）和解组（unmarshal）。\r\nCastor 还提供了 JDO 功能。JDO 也就是 Java Data Objects，是驱动 Java-to-RDBMS 编组和解组的底层技术。尽管不再像前几年那么流行，JDO 仍然是一个不错的功能。此外，由于 JDO 也是一种 Sun 规范，因此不用编写模糊的 API。\r\n\r\n下面来看个例子如何实现java对象与xml文档之间的转换\r\n\r\n<strong>CD </strong>\r\n\r\npublic class CD implements java.io.Serializable {\r\nprivate String name = null;\r\nprivate String artist = null;\r\nprivate List tracks = null;\r\n}\r\n\r\n<strong>MarshalTester //编组</strong>\r\n\r\nimport java.io.FileWriter;\r\nimport org.exolab.castor.xml.Marshaller;\r\nCD sessions = new CD(\"Sessions for Robert J\", \"Eric Clapton\");\r\nsessions.addTrack(\"Little Queen of Spades\");\r\nsessions.addTrack(\"Terraplane Blues\");\r\nFileWriter writer = new FileWriter(\"cds.xml\");\r\nMarshaller.marshal(sessions, writer);\r\n\r\n<strong>UnmarshalTester </strong>//解组\r\n\r\nimport java.io.FileReader;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport org.exolab.castor.xml.Unmarshaller;\r\nFileReader reader = new FileReader(\"cds.xml\");\r\nCD cd = (CD)Unmarshaller.unmarshal(CD.class, reader);\r\nSystem.out.println(\"CD title: \" + cd.getName());\r\nSystem.out.println(\"CD artist: \" + cd.getArtist());\r\nList tracks = cd.getTracks();\r\nif (tracks == null) {\r\nSystem.out.println(\"No tracks.\");\r\n} else {\r\nfor (Iterator i = tracks.iterator(); i.hasNext(); ) {\r\nSystem.out.println(\"Track: \" + i.next());\r\n}\r\n}\r\n\r\n<strong>cds.xml  的内容应该如下</strong>\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;CD&gt;\r\n&lt;artist&gt;Eric Clapton&lt;/artist&gt;\r\n&lt;name&gt;Sessions for Robert J&lt;/name&gt;\r\n&lt;tracks xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\nxsi:type=\"java:java.lang.String\"&gt;Little Queen of Spades&lt;/tracks&gt;\r\n&lt;tracks xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\nxsi:type=\"java:java.lang.String\"&gt;Terraplane Blues&lt;/tracks&gt;\r\n&lt;/CD&gt;\r\n\r\n<strong>小结由此可见使用castor转换很方便但也有需要注意的地方</strong>\r\n\r\n<strong>Castor 要求使用无参数的构造器</strong>\r\n\r\n<strong>Castor 主要通过反射和调用 Class.forName(类名).newInstance() 这样的方法进行解组，因而 Castor 不需要了解很多就能实例化类。但是，它还要求类必须能通过不带参数的构造器实例化。 当前是在castor-1.1.2.1 版本下测试的 对于后续版本是否会解决这些问题请查看官方网站</strong>\r\n\r\n注意当前  <strong>castor-1.1.2.1版本除了castor提供的核心包以外还需要如下的包在运行代码的时候请把它们添加到classpath</strong>\r\n\r\nxerces-J_1.4.0.jar//解析xml  commons-logging-1.0.4.jar//日志包\r\n\r\n有的时候我们的环境不是很理想比如java类的属性与我们需要转换的xml在名称以及格式上有冲突或者不理想我们可以采用映射文件mapping的方式来指定如何编组和解组java类或xml文件例子如下\r\n\r\n<strong>Book </strong>\r\npublic class Book {\r\nprivate String isbn;\r\nprivate String title;\r\nprivate List&lt;Author&gt; authors ;\r\npublic Book() { }\r\n\r\npublic Book(String isbn, String title, List&lt;Author&gt; authors) {\r\nthis.isbn = isbn;\r\nthis.title = title;\r\nthis.authors = authors;\r\n}\r\n\r\npublic Book(String isbn, String title, Author author) {\r\nthis.isbn = isbn;\r\nthis.title = title;\r\nthis.authors = new LinkedList&lt;Author&gt;();\r\nauthors.add(author);\r\n}\r\n\r\npublic void setIsbn(String isbn) {\r\nthis.isbn = isbn;\r\n}\r\n\r\npublic String getIsbn() {\r\nreturn isbn;\r\n}\r\n\r\npublic void setTitle(String title) {\r\nthis.title = title;\r\n}\r\n\r\npublic String getTitle() {\r\nreturn title;\r\n}\r\n\r\npublic void setAuthors(List&lt;Author&gt; authors) {\r\nthis.authors = authors;\r\n}\r\n\r\npublic List&lt;Author&gt; getAuthors() {\r\nreturn authors;\r\n}\r\n\r\npublic void addAuthor(Author author) {\r\nauthors.add(author);\r\n}\r\n}\r\n\r\n<strong>Author </strong>\r\npublic class Author {\r\n\r\nprivate String firstName, lastName;\r\n\r\npublic Author() { }\r\n\r\npublic Author(String firstName, String lastName) {\r\nthis.firstName = firstName;\r\nthis.lastName = lastName;\r\n}\r\n\r\npublic void setFirstName(String firstName) {\r\nthis.firstName = firstName;\r\n}\r\n\r\npublic void setLastName(String lastName) {\r\nthis.lastName = lastName;\r\n}\r\n\r\npublic String getFirstName() {\r\nreturn firstName;\r\n}\r\n\r\npublic String getLastName() {\r\nreturn lastName;\r\n}\r\n}\r\n<strong>main方法</strong>\r\n\r\nMapping mapping = new Mapping();\r\nmapping.loadMapping(\"d:\\\\book-mapping.xml\");\r\nFileReader reader = new FileReader(\"d:\\\\book.xml\");\r\nUnmarshaller unmarshaller = new Unmarshaller(Book.class);\r\nunmarshaller.setMapping(mapping);\r\nBook book = (Book)unmarshaller.unmarshal(reader);\r\nSystem.out.println(\"Book ISBN: \" + book.getIsbn());\r\nSystem.out.println(\"Book Title: \" + book.getTitle());\r\nList authors = book.getAuthors();\r\nfor (Iterator i = authors.iterator(); i.hasNext(); ) {\r\nAuthor author = (Author)i.next();\r\nSystem.out.println(\"Author: \" + author.getFirstName() + \" \" +\r\nauthor.getLastName());\r\n}\r\n\r\n<strong>book-mapping.xml </strong>\r\n\r\n&lt;?xml version=\"1.0\"?&gt;\r\n&lt;!DOCTYPE mapping PUBLIC \"-//EXOLAB/Castor Mapping DTD Version 1.0//EN\" \"http://castor.org/mapping.dtd\"&gt;\r\n&lt;mapping&gt;\r\n&lt;class name=\"ibm.xml.castor.Book\"&gt;\r\n&lt;map-to xml=\"book\" /&gt;\r\n&lt;field name=\"Title\" type=\"java.lang.String\"&gt;\r\n&lt;bind-xml name=\"title\" node=\"element\" location=\"book-info\" /&gt;\r\n&lt;/field&gt;\r\n&lt;field name=\"Isbn\" type=\"java.lang.String\"&gt;\r\n&lt;bind-xml name=\"isbn\" node=\"element\" location=\"book-info\" /&gt;\r\n&lt;/field&gt;\r\n&lt;field name=\"Authors\" type=\"ibm.xml.castor.Author\" collection=\"vector\"&gt;\r\n&lt;bind-xml name=\"author\" /&gt;\r\n&lt;/field&gt;\r\n&lt;/class&gt;\r\n&lt;class name=\"ibm.xml.castor.Author\"&gt;\r\n&lt;field name=\"FirstName\" type=\"java.lang.String\"&gt;\r\n&lt;bind-xml name=\"first\" node=\"attribute\" location=\"name\" /&gt;\r\n&lt;/field&gt;\r\n&lt;field name=\"LastName\" type=\"java.lang.String\"&gt;\r\n&lt;bind-xml name=\"last\" node=\"attribute\" location=\"name\" /&gt;\r\n&lt;/field&gt;\r\n&lt;/class&gt;\r\n&lt;/mapping&gt;\r\n\r\n<strong>book.xml </strong>\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;book&gt;\r\n&lt;author&gt;\r\n&lt;name first=\"Douglas\" last=\"Preston\" /&gt;\r\n&lt;/author&gt;\r\n&lt;author&gt;\r\n&lt;name first=\"Lincoln\" last=\"Child\" /&gt;\r\n&lt;/author&gt;\r\n&lt;book-info&gt;\r\n&lt;isbn&gt;9780446618502&lt;/isbn&gt;\r\n&lt;title&gt;The Book of the Dead&lt;/title&gt;\r\n&lt;/book-info&gt;\r\n&lt;/book&gt;\r\n\r\n<strong>小结：可见 通过映射文件可以实现更强大的转换，对于mapping映射 文件如何编写以及说明文档可以查看官方文档这里只是对castor做一些介绍,castor还可以通过jdbc把Java 对象绑定到 SQL 数据库。</strong>','实现 Castor 数据绑定','','inherit','open','open','','66-revision-v1','','','2013-08-23 13:50:13','2013-08-23 05:50:13','',66,'http://localhost/wordpress-new/?p=67',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (68,1,'2013-08-23 13:50:40','2013-08-23 05:50:40','<strong>Axis2</strong>是目前比较流行的WebService引擎。WebService被应用在很多不同的场景。例如，可以使用WebService来发布服务端 Java类的方法，以便使用不同的客户端进行调用。这样可以有效地集成多种不同的技术来完成应用系统。WebService还经常被使用在SOA中，用于 SOA各个部分交换数据。下面使用几个实例来说明如何用axis发布web服务。在此之前先做准备工作\r\n<p align=\"left\"><strong>一、</strong><strong>Axis2</strong><strong>的下载和安装</strong></p>\r\n<p align=\"left\">    读者可以从如下的网址下载Axis2的最新版本：</p>\r\n<p align=\"left\">    <a href=\"http://ws.apache.org/axis2/\">http://ws.apache.org/axis2/</a></p>\r\n<p align=\"left\">    在本文使用了目前Axis2的最新版本1.4.1。可以下载如下两个zip包：</p>\r\n<p align=\"left\">    axis2-1.4.1-bin.zip</p>\r\n<p align=\"left\">    axis2-1.4.1-war.zip</p>\r\n<p align=\"left\">    其中axis2-1.4.1-bin.zip文件中包含了Axis2中所有的jar文件, axis2-1.4.1-war.zip文件用于将WebService发布到Web容器中。</p>\r\n<p align=\"left\">    将axis2-1.4.1-war.zip文件解压到相应的目录，将目录中的axis2.war文件放到&lt;Tomcat安装目录&gt;\\webapps目录中（本文使用的Tomcat的版本是6.x），并启动Tomcat。</p>\r\n<p align=\"left\">    在浏览器地址栏中输入如下的URL：</p>\r\n<p align=\"left\">    <a href=\"http://localhost:8080/axis2/\">http://localhost:8080/axis2/</a></p>\r\n<p align=\"left\">如果需要在eclipse环境下发布 可以把  axis2-1.4.1-war.zip中的axis2.war解压 采用工程的方式放到eclipse工程下面。</p>\r\n&nbsp;\r\n\r\n1.  <a href=\"http://www.blogjava.net/nokiaguy/archive/2009/nokiaguy/archive/2009/nokiaguy/archive/2009/01/02/249556.html\" target=\"_blank\">用POJO实现0配置的WebService</a>\r\n\r\n<a href=\"http://www.blogjava.net/nokiaguy/archive/2009/nokiaguy/archive/2009/nokiaguy/archive/2009/01/02/249556.html\" target=\"_blank\">无包</a>的类 SimpleService\r\n\r\npublic class SimpleService\r\n{\r\npublic String getGreeting(String name)\r\n{return \"你好 \" + name;}\r\npublic int getPrice()\r\n{return new java.util.Random().nextInt(1000);}\r\n}\r\n\r\n编译该类后把class文件放到web程序的 webapps\\axis2\\WEB-INF\\pojo目录下 对于具体放在哪个路径下可以通过 webapps\\axis2\\WEB-INF\\conf 下的axis2.xml进行配置pojo为默认路径 后面很多东西都是靠 axis2.xml文件进行配置的 启动服务器后 可以在\r\n<p align=\"left\"><a href=\"http://localhost:8080/axis2/services/listServices\">http://localhost:8080/axis2/services/listServices </a> 查看你所发布的web服务</p>\r\n<p align=\"left\"><strong>备注：  跟axis一样axis2的pojo发布方式 同样不能使用package（包）</strong></p>\r\n<p align=\"left\">客户端：下面是客户端的调用</p>\r\n<p align=\"left\">RPCServiceClient serviceClient = new RPCServiceClient();\r\nOptions options = serviceClient.getOptions();\r\n// 指定调用WebService的URL\r\nEndpointReference targetEPR = new EndpointReference(\"http://localhost:8081/axis2/services/SimpleService\");\r\noptions.setTo(targetEPR);\r\n// 指定getGreeting方法的参数值\r\nObject[] opAddEntryArgs = new Object[] {\"超人\"};\r\n// 指定getGreeting方法返回值的数据类型的Class对象\r\nClass[] classes = new Class[] {String.class};\r\nQName opAddEntry = new QName(\"http://ws.apache.org/axis2\", \"getGreeting\");\r\n// 调用getGreeting方法并输出该方法的返回值\r\nSystem.out.println(serviceClient.invokeBlocking(opAddEntry, opAddEntryArgs, classes)[0]);\r\n// 下面是调用getPrice方法的代码，这些代码与调用getGreeting方法的代码类似\r\nclasses = new Class[] {int.class};\r\nopAddEntry = new QName(\"http://ws.apache.org/axis2\", \"getPrice\");\r\nSystem.out.println(serviceClient.invokeBlocking(opAddEntry, new Object[]{}, classes)[0]);</p>\r\n<p align=\"left\">当然你可以使用任何客户端工具语言来访问或是axis都可以如果客户端也是采用的axis2可以使用axis2提供的 <strong>wsdl2java 客户端生成工具如下</strong></p>\r\n<p align=\"left\">在cmd下 进入axis2安装目录 如 F:\\book\\java\\Web Services\\axis2-1.4.1\\bin 在命令行下</p>\r\n<p align=\"left\">设置Java_home</p>\r\n<p align=\"left\">set JAVA_HOME=E:\\Java\\jdk1.6.0_25</p>\r\n<p align=\"left\">wsdl2java -uri http://localhost:8081/axis2/services/SimpleService?wsdl -p client -s -o stub</p>\r\n<p align=\"left\">它会在当前目录生成一个stub文件夹在里面有个 SimpleServiceStub.java 文件可以通过该类访问web服务如下main 方法</p>\r\n<p align=\"left\"><strong>SimpleServiceStub stub = new SimpleServiceStub();</strong>\r\n<strong> SimpleServiceStub.GetGreeting gg = new SimpleServiceStub.GetGreeting();</strong>\r\n<strong> gg.setName(\"比尔\"); </strong></p>\r\n<p align=\"left\">在使用wsdl2java工具时会要求设置 JAVA_HOME  和AXIS2_HOME 如果你当前是在</p>\r\n<p align=\"left\">AXIS2_HOME\\bin目录下就不需要设置AXIS2_HOME 只需要设置JAVA_HOME</p>\r\n<p align=\"left\">AXIS2与axis一样提供了复杂数据类型以及二进制文件的服务除了以pojo的方式来发布web服务外还提供通过配置文件 services.xml 发布如</p>\r\n<p align=\"left\">用Axis2实现Web Service，虽然可以将POJO类放在axis2\\WEB-INF\\pojo目录中直接发布成Web Service，这样做不需要进行任何配置，但这些POJO类不能在任何包中。这似乎有些不方便，为此，Axis2也允许将带包的POJO类发布成Web Service。\r\n先实现一个POJO类，代码如下：\r\npackage service;</p>\r\npublic class MyService\r\n{\r\npublic String getGreeting(String name)\r\n{\r\nreturn \"您好 \" + name;\r\n}\r\npublic void update(String data)\r\n{\r\nSystem.out.println(\"&lt;\" + data + \"&gt;已经更新\");\r\n}\r\n}\r\n这个类有两个方法，这两个方法都需要发布成Web Service方法。这种方式和直接放在pojo目录中的POJO类不同。要想将MyService类发布成Web Service，需要一个services.xml文件，这个文件需要放在META-INF目录中，该文件的内容如下：\r\n&lt;service name=\"myService\"&gt;\r\n&lt;description&gt;\r\nWeb Service例子\r\n&lt;/description&gt;\r\n&lt;parameter name=\"ServiceClass\"&gt;\r\nservice.MyService\r\n&lt;/parameter&gt;\r\n&lt;messageReceivers&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-out\"\r\n/&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-only\"\r\n/&gt;\r\n&lt;/messageReceivers&gt;\r\n&lt;/service&gt;\r\n其中&lt;service&gt;元素用于发布Web Service，一个&lt;service&gt;元素只能发布一个WebService类，name属性表示WebService名，如下面的URL可以获得这个WebService的WSDL内容：\r\nhttp://localhost:8080/axis2/services/myService?wsdl\r\n其中name属性名就是上面URL中\"?\"和\"/\"之间的部分。\r\n&lt;description&gt;元素表示当前Web Service的描述，&lt;parameter&gt;元素用于设置WebService的参数，在这里用于设置WebService对应的类名。在这里最值得注意的是&lt;messageReceivers&gt;元素，该元素用于设置处理WebService方法的处理器。例如，getGreeting方法有一个返回值，因此，需要使用可处理输入输出的RPCMessageReceiver类，而update方法没有返回值，因此，需要使用只能处理输入的RPCInOnlyMessageReceiver类。\r\n使用这种方式发布WebService，必须打包成.aar文件，..aar文件实际上就是改变了扩展名的.jar文件。在现在建立了两个文件：MyService.java和services.xml。将MyService.java编译，生成MyService.class。services.xml和MyService.class文件的位置如下：\r\nD:\\ws\\service\\MyService.class\r\nD:\\ws\\META-INF\\services.xml\r\n\r\n在windows控制台中进入ws目录，并输入如下的命令生成.aar文件（实际上，.jar文件也可以发布webservice，但axis2官方文档中建议使用.aar文件发布webservice）：\r\njar cvf ws.aar .\r\n\r\n最后将ws.aar文件复制到&lt;Tomcat安装目录&gt;\\webapps\\axis2\\WEB-INF\\services目录中，启动Tomcat后，就可以调用这个WebService了。\r\n另外services.xml文件中也可以直接指定WebService类的方法，如可以用下面的配置代码来发布WebService：\r\n\r\n&lt;service name=\"myService\"&gt;\r\n&lt;description&gt;\r\nWeb Service例子\r\n&lt;/description&gt;\r\n&lt;parameter name=\"ServiceClass\"&gt;\r\nservice.MyService\r\n&lt;/parameter&gt;\r\n&lt;operation name=\"getGreeting\"&gt;\r\n&lt;messageReceiver /&gt;\r\n&lt;/operation&gt;\r\n&lt;operation name=\"update\"&gt;\r\n&lt;messageReceiver\r\n/&gt;\r\n&lt;/operation&gt;\r\n&lt;/service&gt;\r\n\r\n上面的配置代码前面的部分和以前的services.xml文件的内容相同，但后面使用了&lt;operation&gt;元素来指定每一个WebService方法，并单独指定了处理每一个方法的处理器。对于客户端来说，调用使用这两个services.xml文件发布的WebService并没有太大我区别，只是使用第二个services.xml文件发布WebServices后，在使用wsdl2java命令或使用C#、delphi等生成客户端的stub时，update方法的String类型被封装在了update类中，在传递update方法的参数时需要建立update类的对象实例。而使用第一个services.xml文件发布的WebService在生成stub时直接可以为update方法传递String类型的参数。从这一点可以看出，这两种方法生成的WSDL有一定的区别。但实际上，如果客户端程序使用第一个services.xml文件发布的WebService生成stub类时（这时update方法的参数是String），在服务端又改为第二个services.xml文件来发布WebService，这时客户端并不需要再重新生成stub类，而可以直接调用update方法。也就是说，服务端使用什么样的方式发布WebService，对客户端并没有影响。\r\n如果想发布多个WebService，可以使用&lt;serviceGroup&gt;元素，如再建立一个MyService1类，代码如下：\r\npackage service\r\npublic class MyService1\r\n{\r\npublic String getName()\r\n{\r\nreturn \"bill\";\r\n}\r\n}\r\n在services.xml文件中可以使用如下的配置代码来配置MyService和MyService1类：\r\n\r\n&lt;serviceGroup&gt;\r\n&lt;service name=\"myService\"&gt;\r\n&lt;description&gt;\r\nWeb Service例子\r\n&lt;/description&gt;\r\n&lt;parameter name=\"ServiceClass\"&gt;\r\nservice.MyService\r\n&lt;/parameter&gt;\r\n&lt;messageReceivers&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-out\"\r\n/&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-only\"\r\n/&gt;\r\n&lt;/messageReceivers&gt;\r\n&lt;/service&gt;\r\n&lt;service name=\"myService1\"&gt;\r\n&lt;description&gt;\r\nWeb Service例子\r\n&lt;/description&gt;\r\n&lt;parameter name=\"ServiceClass\"&gt;\r\nservice.MyService1\r\n&lt;/parameter&gt;\r\n&lt;messageReceivers&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-out\"\r\n/&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-only\"\r\n/&gt;\r\n&lt;/messageReceivers&gt;\r\n&lt;/service&gt;\r\n&lt;/serviceGroup&gt;\r\n\r\n&nbsp;','Axis2 简介','','publish','open','open','','axis2-%e7%ae%80%e4%bb%8b','','','2013-08-23 13:50:40','2013-08-23 05:50:40','',0,'http://localhost/wordpress-new/?p=68',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (69,1,'2013-08-23 13:50:40','2013-08-23 05:50:40','<strong>Axis2</strong>是目前比较流行的WebService引擎。WebService被应用在很多不同的场景。例如，可以使用WebService来发布服务端 Java类的方法，以便使用不同的客户端进行调用。这样可以有效地集成多种不同的技术来完成应用系统。WebService还经常被使用在SOA中，用于 SOA各个部分交换数据。下面使用几个实例来说明如何用axis发布web服务。在此之前先做准备工作\r\n<p align=\"left\"><strong>一、</strong><strong>Axis2</strong><strong>的下载和安装</strong></p>\r\n<p align=\"left\">    读者可以从如下的网址下载Axis2的最新版本：</p>\r\n<p align=\"left\">    <a href=\"http://ws.apache.org/axis2/\">http://ws.apache.org/axis2/</a></p>\r\n<p align=\"left\">    在本文使用了目前Axis2的最新版本1.4.1。可以下载如下两个zip包：</p>\r\n<p align=\"left\">    axis2-1.4.1-bin.zip</p>\r\n<p align=\"left\">    axis2-1.4.1-war.zip</p>\r\n<p align=\"left\">    其中axis2-1.4.1-bin.zip文件中包含了Axis2中所有的jar文件, axis2-1.4.1-war.zip文件用于将WebService发布到Web容器中。</p>\r\n<p align=\"left\">    将axis2-1.4.1-war.zip文件解压到相应的目录，将目录中的axis2.war文件放到&lt;Tomcat安装目录&gt;\\webapps目录中（本文使用的Tomcat的版本是6.x），并启动Tomcat。</p>\r\n<p align=\"left\">    在浏览器地址栏中输入如下的URL：</p>\r\n<p align=\"left\">    <a href=\"http://localhost:8080/axis2/\">http://localhost:8080/axis2/</a></p>\r\n<p align=\"left\">如果需要在eclipse环境下发布 可以把  axis2-1.4.1-war.zip中的axis2.war解压 采用工程的方式放到eclipse工程下面。</p>\r\n&nbsp;\r\n\r\n1.  <a href=\"http://www.blogjava.net/nokiaguy/archive/2009/nokiaguy/archive/2009/nokiaguy/archive/2009/01/02/249556.html\" target=\"_blank\">用POJO实现0配置的WebService</a>\r\n\r\n<a href=\"http://www.blogjava.net/nokiaguy/archive/2009/nokiaguy/archive/2009/nokiaguy/archive/2009/01/02/249556.html\" target=\"_blank\">无包</a>的类 SimpleService\r\n\r\npublic class SimpleService\r\n{\r\npublic String getGreeting(String name)\r\n{return \"你好 \" + name;}\r\npublic int getPrice()\r\n{return new java.util.Random().nextInt(1000);}\r\n}\r\n\r\n编译该类后把class文件放到web程序的 webapps\\axis2\\WEB-INF\\pojo目录下 对于具体放在哪个路径下可以通过 webapps\\axis2\\WEB-INF\\conf 下的axis2.xml进行配置pojo为默认路径 后面很多东西都是靠 axis2.xml文件进行配置的 启动服务器后 可以在\r\n<p align=\"left\"><a href=\"http://localhost:8080/axis2/services/listServices\">http://localhost:8080/axis2/services/listServices </a> 查看你所发布的web服务</p>\r\n<p align=\"left\"><strong>备注：  跟axis一样axis2的pojo发布方式 同样不能使用package（包）</strong></p>\r\n<p align=\"left\">客户端：下面是客户端的调用</p>\r\n<p align=\"left\">RPCServiceClient serviceClient = new RPCServiceClient();\r\nOptions options = serviceClient.getOptions();\r\n// 指定调用WebService的URL\r\nEndpointReference targetEPR = new EndpointReference(\"http://localhost:8081/axis2/services/SimpleService\");\r\noptions.setTo(targetEPR);\r\n// 指定getGreeting方法的参数值\r\nObject[] opAddEntryArgs = new Object[] {\"超人\"};\r\n// 指定getGreeting方法返回值的数据类型的Class对象\r\nClass[] classes = new Class[] {String.class};\r\nQName opAddEntry = new QName(\"http://ws.apache.org/axis2\", \"getGreeting\");\r\n// 调用getGreeting方法并输出该方法的返回值\r\nSystem.out.println(serviceClient.invokeBlocking(opAddEntry, opAddEntryArgs, classes)[0]);\r\n// 下面是调用getPrice方法的代码，这些代码与调用getGreeting方法的代码类似\r\nclasses = new Class[] {int.class};\r\nopAddEntry = new QName(\"http://ws.apache.org/axis2\", \"getPrice\");\r\nSystem.out.println(serviceClient.invokeBlocking(opAddEntry, new Object[]{}, classes)[0]);</p>\r\n<p align=\"left\">当然你可以使用任何客户端工具语言来访问或是axis都可以如果客户端也是采用的axis2可以使用axis2提供的 <strong>wsdl2java 客户端生成工具如下</strong></p>\r\n<p align=\"left\">在cmd下 进入axis2安装目录 如 F:\\book\\java\\Web Services\\axis2-1.4.1\\bin 在命令行下</p>\r\n<p align=\"left\">设置Java_home</p>\r\n<p align=\"left\">set JAVA_HOME=E:\\Java\\jdk1.6.0_25</p>\r\n<p align=\"left\">wsdl2java -uri http://localhost:8081/axis2/services/SimpleService?wsdl -p client -s -o stub</p>\r\n<p align=\"left\">它会在当前目录生成一个stub文件夹在里面有个 SimpleServiceStub.java 文件可以通过该类访问web服务如下main 方法</p>\r\n<p align=\"left\"><strong>SimpleServiceStub stub = new SimpleServiceStub();</strong>\r\n<strong> SimpleServiceStub.GetGreeting gg = new SimpleServiceStub.GetGreeting();</strong>\r\n<strong> gg.setName(\"比尔\"); </strong></p>\r\n<p align=\"left\">在使用wsdl2java工具时会要求设置 JAVA_HOME  和AXIS2_HOME 如果你当前是在</p>\r\n<p align=\"left\">AXIS2_HOME\\bin目录下就不需要设置AXIS2_HOME 只需要设置JAVA_HOME</p>\r\n<p align=\"left\">AXIS2与axis一样提供了复杂数据类型以及二进制文件的服务除了以pojo的方式来发布web服务外还提供通过配置文件 services.xml 发布如</p>\r\n<p align=\"left\">用Axis2实现Web Service，虽然可以将POJO类放在axis2\\WEB-INF\\pojo目录中直接发布成Web Service，这样做不需要进行任何配置，但这些POJO类不能在任何包中。这似乎有些不方便，为此，Axis2也允许将带包的POJO类发布成Web Service。\r\n先实现一个POJO类，代码如下：\r\npackage service;</p>\r\npublic class MyService\r\n{\r\npublic String getGreeting(String name)\r\n{\r\nreturn \"您好 \" + name;\r\n}\r\npublic void update(String data)\r\n{\r\nSystem.out.println(\"&lt;\" + data + \"&gt;已经更新\");\r\n}\r\n}\r\n这个类有两个方法，这两个方法都需要发布成Web Service方法。这种方式和直接放在pojo目录中的POJO类不同。要想将MyService类发布成Web Service，需要一个services.xml文件，这个文件需要放在META-INF目录中，该文件的内容如下：\r\n&lt;service name=\"myService\"&gt;\r\n&lt;description&gt;\r\nWeb Service例子\r\n&lt;/description&gt;\r\n&lt;parameter name=\"ServiceClass\"&gt;\r\nservice.MyService\r\n&lt;/parameter&gt;\r\n&lt;messageReceivers&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-out\"\r\n/&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-only\"\r\n/&gt;\r\n&lt;/messageReceivers&gt;\r\n&lt;/service&gt;\r\n其中&lt;service&gt;元素用于发布Web Service，一个&lt;service&gt;元素只能发布一个WebService类，name属性表示WebService名，如下面的URL可以获得这个WebService的WSDL内容：\r\nhttp://localhost:8080/axis2/services/myService?wsdl\r\n其中name属性名就是上面URL中\"?\"和\"/\"之间的部分。\r\n&lt;description&gt;元素表示当前Web Service的描述，&lt;parameter&gt;元素用于设置WebService的参数，在这里用于设置WebService对应的类名。在这里最值得注意的是&lt;messageReceivers&gt;元素，该元素用于设置处理WebService方法的处理器。例如，getGreeting方法有一个返回值，因此，需要使用可处理输入输出的RPCMessageReceiver类，而update方法没有返回值，因此，需要使用只能处理输入的RPCInOnlyMessageReceiver类。\r\n使用这种方式发布WebService，必须打包成.aar文件，..aar文件实际上就是改变了扩展名的.jar文件。在现在建立了两个文件：MyService.java和services.xml。将MyService.java编译，生成MyService.class。services.xml和MyService.class文件的位置如下：\r\nD:\\ws\\service\\MyService.class\r\nD:\\ws\\META-INF\\services.xml\r\n\r\n在windows控制台中进入ws目录，并输入如下的命令生成.aar文件（实际上，.jar文件也可以发布webservice，但axis2官方文档中建议使用.aar文件发布webservice）：\r\njar cvf ws.aar .\r\n\r\n最后将ws.aar文件复制到&lt;Tomcat安装目录&gt;\\webapps\\axis2\\WEB-INF\\services目录中，启动Tomcat后，就可以调用这个WebService了。\r\n另外services.xml文件中也可以直接指定WebService类的方法，如可以用下面的配置代码来发布WebService：\r\n\r\n&lt;service name=\"myService\"&gt;\r\n&lt;description&gt;\r\nWeb Service例子\r\n&lt;/description&gt;\r\n&lt;parameter name=\"ServiceClass\"&gt;\r\nservice.MyService\r\n&lt;/parameter&gt;\r\n&lt;operation name=\"getGreeting\"&gt;\r\n&lt;messageReceiver /&gt;\r\n&lt;/operation&gt;\r\n&lt;operation name=\"update\"&gt;\r\n&lt;messageReceiver\r\n/&gt;\r\n&lt;/operation&gt;\r\n&lt;/service&gt;\r\n\r\n上面的配置代码前面的部分和以前的services.xml文件的内容相同，但后面使用了&lt;operation&gt;元素来指定每一个WebService方法，并单独指定了处理每一个方法的处理器。对于客户端来说，调用使用这两个services.xml文件发布的WebService并没有太大我区别，只是使用第二个services.xml文件发布WebServices后，在使用wsdl2java命令或使用C#、delphi等生成客户端的stub时，update方法的String类型被封装在了update类中，在传递update方法的参数时需要建立update类的对象实例。而使用第一个services.xml文件发布的WebService在生成stub时直接可以为update方法传递String类型的参数。从这一点可以看出，这两种方法生成的WSDL有一定的区别。但实际上，如果客户端程序使用第一个services.xml文件发布的WebService生成stub类时（这时update方法的参数是String），在服务端又改为第二个services.xml文件来发布WebService，这时客户端并不需要再重新生成stub类，而可以直接调用update方法。也就是说，服务端使用什么样的方式发布WebService，对客户端并没有影响。\r\n如果想发布多个WebService，可以使用&lt;serviceGroup&gt;元素，如再建立一个MyService1类，代码如下：\r\npackage service\r\npublic class MyService1\r\n{\r\npublic String getName()\r\n{\r\nreturn \"bill\";\r\n}\r\n}\r\n在services.xml文件中可以使用如下的配置代码来配置MyService和MyService1类：\r\n\r\n&lt;serviceGroup&gt;\r\n&lt;service name=\"myService\"&gt;\r\n&lt;description&gt;\r\nWeb Service例子\r\n&lt;/description&gt;\r\n&lt;parameter name=\"ServiceClass\"&gt;\r\nservice.MyService\r\n&lt;/parameter&gt;\r\n&lt;messageReceivers&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-out\"\r\n/&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-only\"\r\n/&gt;\r\n&lt;/messageReceivers&gt;\r\n&lt;/service&gt;\r\n&lt;service name=\"myService1\"&gt;\r\n&lt;description&gt;\r\nWeb Service例子\r\n&lt;/description&gt;\r\n&lt;parameter name=\"ServiceClass\"&gt;\r\nservice.MyService1\r\n&lt;/parameter&gt;\r\n&lt;messageReceivers&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-out\"\r\n/&gt;\r\n&lt;messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-only\"\r\n/&gt;\r\n&lt;/messageReceivers&gt;\r\n&lt;/service&gt;\r\n&lt;/serviceGroup&gt;\r\n\r\n&nbsp;','Axis2 简介','','inherit','open','open','','68-revision-v1','','','2013-08-23 13:50:40','2013-08-23 05:50:40','',68,'http://localhost/wordpress-new/?p=69',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (70,1,'2013-08-23 13:51:06','2013-08-23 05:51:06','使用CXF来实现web服务。这里采用最简单的hello world来简介如何通过cxf实现web服务如果需要详细了解cxf请查看官方文档\r\n\r\n如下\r\n\r\n1.interface HelloService\r\n\r\npackage cfx.server;\r\n\r\nimport javax.jws.WebMethod;\r\nimport javax.jws.WebParam;\r\nimport javax.jws.WebService;\r\n\r\n@WebService\r\npublic interface HelloService {\r\n@WebMethod\r\nString sayHi(@WebParam String name);\r\n}\r\n\r\n2.实现类HelloServiceImpl\r\n\r\npackage cfx.server;\r\n\r\npublic class HelloServiceImpl implements HelloService {\r\npublic String sayHi(String name) {\r\nSystem.out.println(\"HelloServiceImpl.sayHi called\");\r\nreturn \"Hello\" + name;\r\n}\r\n}\r\n\r\n3.编写cxf-servlet.xml 文件在服务器的该路径下如E:\\Apache Software Foundation\\Tomcat 6.0\\webapps\\CXF\\WEB-INF\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\r\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\nxmlns:jaxws=\"http://cxf.apache.org/jaxws\"\r\nxmlns:soap=\"http://cxf.apache.org/bindings/soap\"\r\nxsi:schemaLocation=\"\r\nhttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\nhttp://cxf.apache.org/bindings/soap http://cxf.apache.org/schemas/configuration/soap.xsd\r\nhttp://cxf.apache.org/jaxws\r\nhttp://cxf.apache.org/schemas/jaxws.xsd\"&gt;\r\n&lt;jaxws:server id=\"jaxwsService\" serviceClass=\"cfx.server.HelloService\" address=\"/hello\"&gt;\r\n&lt;jaxws:serviceBean&gt;\r\n&lt;bean /&gt;\r\n&lt;/jaxws:serviceBean&gt;\r\n&lt;/jaxws:server&gt;\r\n&lt;/beans&gt;\r\n\r\n4.在tomcat服务器的web.xml下 添加如下servlet\r\n\r\n&lt;servlet&gt;\r\n&lt;description&gt;Apache CXF Endpoint&lt;/description&gt;\r\n&lt;display-name&gt;cxf&lt;/display-name&gt;\r\n&lt;servlet-name&gt;cxf&lt;/servlet-name&gt;\r\n&lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;\r\n&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\r\n&lt;/servlet&gt;\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;cxf&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n\r\n5.客户端 CXF\r\n\r\npublic static void main(String[] args) {\r\nJaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();\r\nfactory.setServiceClass(HelloService.class);\r\nfactory.setAddress(\"http://localhost:8081/CXF/services/hello\");\r\nHelloService client = (HelloService) factory.create();\r\nString reply = client.sayHi(\"特蕾莎\");\r\nSystem.out.println(\"Server said: \" + reply);\r\n}\r\n\r\n结束','Apache CXF','','publish','open','open','','apache-cxf','','','2013-08-23 13:51:06','2013-08-23 05:51:06','',0,'http://localhost/wordpress-new/?p=70',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (71,1,'2013-08-23 13:51:06','2013-08-23 05:51:06','使用CXF来实现web服务。这里采用最简单的hello world来简介如何通过cxf实现web服务如果需要详细了解cxf请查看官方文档\r\n\r\n如下\r\n\r\n1.interface HelloService\r\n\r\npackage cfx.server;\r\n\r\nimport javax.jws.WebMethod;\r\nimport javax.jws.WebParam;\r\nimport javax.jws.WebService;\r\n\r\n@WebService\r\npublic interface HelloService {\r\n@WebMethod\r\nString sayHi(@WebParam String name);\r\n}\r\n\r\n2.实现类HelloServiceImpl\r\n\r\npackage cfx.server;\r\n\r\npublic class HelloServiceImpl implements HelloService {\r\npublic String sayHi(String name) {\r\nSystem.out.println(\"HelloServiceImpl.sayHi called\");\r\nreturn \"Hello\" + name;\r\n}\r\n}\r\n\r\n3.编写cxf-servlet.xml 文件在服务器的该路径下如E:\\Apache Software Foundation\\Tomcat 6.0\\webapps\\CXF\\WEB-INF\r\n\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\r\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\nxmlns:jaxws=\"http://cxf.apache.org/jaxws\"\r\nxmlns:soap=\"http://cxf.apache.org/bindings/soap\"\r\nxsi:schemaLocation=\"\r\nhttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\nhttp://cxf.apache.org/bindings/soap http://cxf.apache.org/schemas/configuration/soap.xsd\r\nhttp://cxf.apache.org/jaxws\r\nhttp://cxf.apache.org/schemas/jaxws.xsd\"&gt;\r\n&lt;jaxws:server id=\"jaxwsService\" serviceClass=\"cfx.server.HelloService\" address=\"/hello\"&gt;\r\n&lt;jaxws:serviceBean&gt;\r\n&lt;bean /&gt;\r\n&lt;/jaxws:serviceBean&gt;\r\n&lt;/jaxws:server&gt;\r\n&lt;/beans&gt;\r\n\r\n4.在tomcat服务器的web.xml下 添加如下servlet\r\n\r\n&lt;servlet&gt;\r\n&lt;description&gt;Apache CXF Endpoint&lt;/description&gt;\r\n&lt;display-name&gt;cxf&lt;/display-name&gt;\r\n&lt;servlet-name&gt;cxf&lt;/servlet-name&gt;\r\n&lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;\r\n&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\r\n&lt;/servlet&gt;\r\n&lt;servlet-mapping&gt;\r\n&lt;servlet-name&gt;cxf&lt;/servlet-name&gt;\r\n&lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n\r\n5.客户端 CXF\r\n\r\npublic static void main(String[] args) {\r\nJaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();\r\nfactory.setServiceClass(HelloService.class);\r\nfactory.setAddress(\"http://localhost:8081/CXF/services/hello\");\r\nHelloService client = (HelloService) factory.create();\r\nString reply = client.sayHi(\"特蕾莎\");\r\nSystem.out.println(\"Server said: \" + reply);\r\n}\r\n\r\n结束','Apache CXF','','inherit','open','open','','70-revision-v1','','','2013-08-23 13:51:06','2013-08-23 05:51:06','',70,'http://localhost/wordpress-new/?p=71',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (72,1,'2013-08-23 13:51:33','2013-08-23 05:51:33','<strong>IBM MQ</strong> 作为消息中间件 。适用于任何需要进行网络通信的系统，负责建立网络通信的通道，进行数据或文件发送。消息中间件的一个重要作用是可以实现跨平台操作，为不同操作系统上的应用软件集成提供服务。\r\n<h2><strong>三种通信技术的比较</strong></h2>\r\n(1)    <strong>CPI-C</strong>\r\n\r\nCPI-C是一个同步的对话通信模式。参加通信的某一程序发起一次对话，并控制信息的流动，发起者可随后向对方发送数据，而对方可接收数据，数据也可反向流动。\r\n\r\n参加通信的程序必须跟踪对话的状态，以备故障发生时作恢复连接用。在对话过程中两个程序都必须同时参加对话。如果由于某种原因造成连接断开，由连接建立者重建并恢复这次对话。这给应用程序增加了连接的负担。通信双方也可处于对等地位，在程序开始时确定了谁是对话的发起者，并保存下去，也可改变这种关系，但必须在该对话完成之后。这意味着CPI-C既支持客户——服务器环境也支持对等通信方式。\r\n\r\n前面提到，CPI-C是一种同步通信模型，但在某些事务处理环境的支持下，CPI-C可以实现一定程度的异步，在CICS环境中这种支持是通过“临时数据队列”这种技术实现的。\r\n\r\n在这以前，只有SNA协议支持CPI-C，现在TCP/IP和SNA都支持CPI-C。\r\n\r\n由于应用程序必须参与对错误的处理和恢复，所以CPI-C的编程接口相当复杂。\r\n\r\n（2）<strong>RPC</strong>\r\n\r\n（RPC）远程过程调用也是一种同步的、对话方式的模型，一个调用程序向服务器提出申请，该调用被一个负责通信的转接器发向远端系统。调用者和被调用者关系是固定的，很难实现对等通信。和CPI-C一样，由应用程序处理错误，并且在申请的服务得到响应之前，服务申请者被阻塞。\r\n\r\n（3）<strong>MQI</strong>(Message Queue Interface)\r\n\r\n消息队列接口为程序提供了一种异步通信方式。一个程序以一个队列作为中转与另一个程序相互通信，这个队列相对于该程序而言既可是本地的也可以是远程的。当程序A需要和程序B通信时，A只需PUT一条消息到一个和B相联系的队列上，程序A然后可以干别的事。它似乎感觉不到通信的发生，通信以及对通信错误的恢复是由队列管理完成的。\r\n\r\n通信的方式和使用的传送协议无关。因为应用程序感觉不到通信的发生，因而可以使用各种标准协议，比如TCP/IP,SNA或者其他局域网协议。\r\n\r\n当程序A通过向某一队列PUT一条消息来申请程序B的服务时，程序B不一定必需在运行。而且一个程序可以通过向不同的队列PUT消息来实现与多个程序的通信。\r\n\r\n<strong>  WebSphere MQ的原理</strong>\r\n\r\nWebsphere MQ是IBM的商业通讯中间件(Commercial Messaging Middleware)。Websphere MQ提供一个具有工业标准、安全、可靠的消息传输系统。它的功能是控制和管理一个集成的商业应用，使得组成这个商业应用的多个分支程序(模块)之间通过传递消息完成整个工作流程。Websphere MQ基本由一个消息传输系统和一个应用程序接口组成，其资源是消息和队列(Messaging and Queuing)。\r\n\r\n<strong>消息</strong>：消息就是一个信息单元，这个信息单元可以是一个请求（Request message），也可以是一个应答(Reply message)，或者是一个报告(Report message)或一份报文(Datagram   messge)。一个消息包含两个因素——消息描述(用于定义诸如消息传输目标等)和数据消息(如应用程序数据或数据库查询等)。程序之间的通信通过传递消息而非直接调用程序。\r\n\r\n<strong>队列:</strong>一个安全的存储消息的地方，消息的存储一般是顺序的，队列是消息分阶段地传送和接收。因为消息存放在队列中，所以应用程序可以相互独立的运行，以不同的速度，在不同的时间，在不同的地点。\r\n\r\n<strong>消息传输系统：</strong>用于确保队列之间的消息提供，包括网络中不同系统上的远程队列之间的消息提供。并保证网络故障或关闭后的恢复。\r\n\r\n<strong>应用程序接口：</strong>应用程序和消息系统之间通过Websphere MQ API实现的接口Websphere MQ API在所有Websphere MQ平台上是一致的。API只有14个调用，2个关键动词：发送(PUT)和接收(GET)。\r\n\r\n例如.应用程序A和应用程序B运行于同一系统A，它们不需要直接的通讯。应用程序A向队列1发送一条消息，而当应用程序B需要时就可以得到该消息。\r\n\r\n如果消息传输的目标改为在系统B上的应用程序C，这种变化不会对应用程序A产生影响，应用程序A向队列Q2发送一条消息，系统A的Websphere MQ发现Q2实际上在系统B，它将消息放到本地的一个特殊队列－传输队列(Transmission Queue)。系统A的Websphere MQ然后建立一条到系统B通讯联接，传递这条消息到系统B，并等待确认。只有Websphere MQ接到系统B成功地收到消息的确认后，才从传输队列中移走消息。如果通讯线路不通，或系统B不在运行，消息会留在传输队列中，直到被成功地传送到目的地。这是Websphere MQ最基本而最重要的技术—可靠消息传输。\r\n\r\n事实上，Websphere MQ具有特殊的技术防止消息重复传送，确保消息一次且仅一次(once-and-only-once)传递。\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;','IBM WebSphere MQ简介','','publish','open','open','','ibm-websphere-mq%e7%ae%80%e4%bb%8b','','','2013-08-23 13:51:33','2013-08-23 05:51:33','',0,'http://localhost/wordpress-new/?p=72',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (73,1,'2013-08-23 13:51:33','2013-08-23 05:51:33','<strong>IBM MQ</strong> 作为消息中间件 。适用于任何需要进行网络通信的系统，负责建立网络通信的通道，进行数据或文件发送。消息中间件的一个重要作用是可以实现跨平台操作，为不同操作系统上的应用软件集成提供服务。\r\n<h2><strong>三种通信技术的比较</strong></h2>\r\n(1)    <strong>CPI-C</strong>\r\n\r\nCPI-C是一个同步的对话通信模式。参加通信的某一程序发起一次对话，并控制信息的流动，发起者可随后向对方发送数据，而对方可接收数据，数据也可反向流动。\r\n\r\n参加通信的程序必须跟踪对话的状态，以备故障发生时作恢复连接用。在对话过程中两个程序都必须同时参加对话。如果由于某种原因造成连接断开，由连接建立者重建并恢复这次对话。这给应用程序增加了连接的负担。通信双方也可处于对等地位，在程序开始时确定了谁是对话的发起者，并保存下去，也可改变这种关系，但必须在该对话完成之后。这意味着CPI-C既支持客户——服务器环境也支持对等通信方式。\r\n\r\n前面提到，CPI-C是一种同步通信模型，但在某些事务处理环境的支持下，CPI-C可以实现一定程度的异步，在CICS环境中这种支持是通过“临时数据队列”这种技术实现的。\r\n\r\n在这以前，只有SNA协议支持CPI-C，现在TCP/IP和SNA都支持CPI-C。\r\n\r\n由于应用程序必须参与对错误的处理和恢复，所以CPI-C的编程接口相当复杂。\r\n\r\n（2）<strong>RPC</strong>\r\n\r\n（RPC）远程过程调用也是一种同步的、对话方式的模型，一个调用程序向服务器提出申请，该调用被一个负责通信的转接器发向远端系统。调用者和被调用者关系是固定的，很难实现对等通信。和CPI-C一样，由应用程序处理错误，并且在申请的服务得到响应之前，服务申请者被阻塞。\r\n\r\n（3）<strong>MQI</strong>(Message Queue Interface)\r\n\r\n消息队列接口为程序提供了一种异步通信方式。一个程序以一个队列作为中转与另一个程序相互通信，这个队列相对于该程序而言既可是本地的也可以是远程的。当程序A需要和程序B通信时，A只需PUT一条消息到一个和B相联系的队列上，程序A然后可以干别的事。它似乎感觉不到通信的发生，通信以及对通信错误的恢复是由队列管理完成的。\r\n\r\n通信的方式和使用的传送协议无关。因为应用程序感觉不到通信的发生，因而可以使用各种标准协议，比如TCP/IP,SNA或者其他局域网协议。\r\n\r\n当程序A通过向某一队列PUT一条消息来申请程序B的服务时，程序B不一定必需在运行。而且一个程序可以通过向不同的队列PUT消息来实现与多个程序的通信。\r\n\r\n<strong>  WebSphere MQ的原理</strong>\r\n\r\nWebsphere MQ是IBM的商业通讯中间件(Commercial Messaging Middleware)。Websphere MQ提供一个具有工业标准、安全、可靠的消息传输系统。它的功能是控制和管理一个集成的商业应用，使得组成这个商业应用的多个分支程序(模块)之间通过传递消息完成整个工作流程。Websphere MQ基本由一个消息传输系统和一个应用程序接口组成，其资源是消息和队列(Messaging and Queuing)。\r\n\r\n<strong>消息</strong>：消息就是一个信息单元，这个信息单元可以是一个请求（Request message），也可以是一个应答(Reply message)，或者是一个报告(Report message)或一份报文(Datagram   messge)。一个消息包含两个因素——消息描述(用于定义诸如消息传输目标等)和数据消息(如应用程序数据或数据库查询等)。程序之间的通信通过传递消息而非直接调用程序。\r\n\r\n<strong>队列:</strong>一个安全的存储消息的地方，消息的存储一般是顺序的，队列是消息分阶段地传送和接收。因为消息存放在队列中，所以应用程序可以相互独立的运行，以不同的速度，在不同的时间，在不同的地点。\r\n\r\n<strong>消息传输系统：</strong>用于确保队列之间的消息提供，包括网络中不同系统上的远程队列之间的消息提供。并保证网络故障或关闭后的恢复。\r\n\r\n<strong>应用程序接口：</strong>应用程序和消息系统之间通过Websphere MQ API实现的接口Websphere MQ API在所有Websphere MQ平台上是一致的。API只有14个调用，2个关键动词：发送(PUT)和接收(GET)。\r\n\r\n例如.应用程序A和应用程序B运行于同一系统A，它们不需要直接的通讯。应用程序A向队列1发送一条消息，而当应用程序B需要时就可以得到该消息。\r\n\r\n如果消息传输的目标改为在系统B上的应用程序C，这种变化不会对应用程序A产生影响，应用程序A向队列Q2发送一条消息，系统A的Websphere MQ发现Q2实际上在系统B，它将消息放到本地的一个特殊队列－传输队列(Transmission Queue)。系统A的Websphere MQ然后建立一条到系统B通讯联接，传递这条消息到系统B，并等待确认。只有Websphere MQ接到系统B成功地收到消息的确认后，才从传输队列中移走消息。如果通讯线路不通，或系统B不在运行，消息会留在传输队列中，直到被成功地传送到目的地。这是Websphere MQ最基本而最重要的技术—可靠消息传输。\r\n\r\n事实上，Websphere MQ具有特殊的技术防止消息重复传送，确保消息一次且仅一次(once-and-only-once)传递。\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;','IBM WebSphere MQ简介','','inherit','open','open','','72-revision-v1','','','2013-08-23 13:51:33','2013-08-23 05:51:33','',72,'http://localhost/wordpress-new/?p=73',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (74,1,'2013-08-23 13:51:53','2013-08-23 05:51:53','对于手持设备如 手机在转换方向的时候 。显示屏需要重新布局当前的Activity界面，由于屏幕的问题在重绘界面的时候由于组件大小的问题导致有些组件可能无法显示。在Android里处理这种方式是对其重新进行布局采用多个配置文件来实现\r\n\r\n在资源目录下实现多个layout文件如\r\n\r\n默认的配置路径 res/layout/main.xml\r\n\r\n元素 android:orientation=\"vertical\" 当设备为垂直状态的配置\r\n\r\n新增资源文件在如下路径 res/layout-land/main.xml\r\n\r\n元素 android:orientation=\"horizontal\" 当设备为横向状态 设备会自动载入该配置文件的配置项  元素 android:orientation=\"horizontal\" 设置方向为水平 并重新为原有的组件进行布局\r\n\r\n也就是说Android系统才用不同的配置为不同的方向进行重新设置','Android 开发笔记','','publish','open','open','','android-%e5%bc%80%e5%8f%91%e7%ac%94%e8%ae%b0','','','2013-08-23 13:51:53','2013-08-23 05:51:53','',0,'http://localhost/wordpress-new/?p=74',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (75,1,'2013-08-23 13:51:53','2013-08-23 05:51:53','对于手持设备如 手机在转换方向的时候 。显示屏需要重新布局当前的Activity界面，由于屏幕的问题在重绘界面的时候由于组件大小的问题导致有些组件可能无法显示。在Android里处理这种方式是对其重新进行布局采用多个配置文件来实现\r\n\r\n在资源目录下实现多个layout文件如\r\n\r\n默认的配置路径 res/layout/main.xml\r\n\r\n元素 android:orientation=\"vertical\" 当设备为垂直状态的配置\r\n\r\n新增资源文件在如下路径 res/layout-land/main.xml\r\n\r\n元素 android:orientation=\"horizontal\" 当设备为横向状态 设备会自动载入该配置文件的配置项  元素 android:orientation=\"horizontal\" 设置方向为水平 并重新为原有的组件进行布局\r\n\r\n也就是说Android系统才用不同的配置为不同的方向进行重新设置','Android 开发笔记','','inherit','open','open','','74-revision-v1','','','2013-08-23 13:51:53','2013-08-23 05:51:53','',74,'http://localhost/wordpress-new/?p=75',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (76,1,'2013-08-23 13:55:04','2013-08-23 05:55:04','前面对IBM MQ做了一些简单的介绍。现在让我们来具体的实现如何配置MQ并通过MQ提供的API ，使用java来实现消息的传递.\r\n\r\n<strong>1.配置MQ</strong>\r\n\r\n在真实的环境中IBM　MQ传递消息是在不同的机器上配置MQ网络来进行的。当前我们只使用本机来实现与远程MQ服务的消息传递。首先准备你的机器并确保已安装好IBM WebSphere MQ 。打开我们的MQ资源管理器。然后开始如下步骤来实现MQ通信管理器的配置。\r\n\r\n<strong>1.右键选择队列管理器</strong>。分别创建2个队列管理器 A 和 B 并配置他们的属性由于是在同一台机器上配置2个队列管理器因此需要分配不同的端口：A : 127.0.0.1(1416)    B:127.0.0.1(1417)\r\n\r\n2.创建完A ，B2个队列管理器后 为他们分别创建队列和通信通道。选择队列管理器A 为其新建队列\r\n\r\n<strong>2.1.新建本地队列</strong> A.loc  采用默认设置 .再新建一个本地队列A.tran 修改其用法属性为传输。A.tran也叫做传输队列，其作为与远程队列进行打交道的通信队列.\r\n\r\n2.2 采用同样的方法为队列管理器B 创建 一个本地队列 和一个传输队列分别为 B.loc和 B.tran\r\n\r\n<strong>3.然后为了与远程队列管理器B打交道需要为远程队列管理器A 配置一个远程队列定义</strong> A.rem并设置其如下属性\r\n\r\n远程队列 B.loc  远程队列管理器 B 传输队列 A.tran\r\n\r\n那么反过来如果B要想A通信也需要配置一个远程队列定义 指向A 那么也需要对管理器B进行配置 远程队列 B.rem\r\n\r\n远程队列A.loc 远程队列管理器 B 传输队列 B.tran\r\n\r\n从这里可以看出队列管理器就像一个网络系统一样。如果需要通信那么需要知道对方的通信名称或者地址 远程队列定义就是用来干这事儿的。当然就像网络一样只知道名字还不行 得知道具体的位置在哪里。那么下面我们就来让他们互相知道对方的具体位置在网络上的哪个地方。\r\n\r\n<strong>4.配置通道</strong>\r\n\r\n为选择队列管理器A  创建发送方通道名称  A.B 并配置其如下属性\r\n\r\n连接名称: 127.0.0.1(1417)    --可以看出在这里就为我们的队列管理器A与队列管理器B同上信了\r\n\r\n传输队列 A.tran\r\n\r\n同样的为了让B能向管理器A通信 也要为其创建发送方通道 B.A 并配置其属性\r\n\r\n连接名称:127.0.0.1(1416) 传输队列 B.tran\r\n\r\n4.1.既然创建了发送通道自然需要 创建一个接收的通道分别为A和B创建接收通道B.A 和 A.B 默认设置\r\n\r\n4.2 为了使队列管理器之间通过API编程进行通信还需要分别为他们创建服务器连接名称 svrcon\r\n\r\n<strong>最后 我们分别启动2个队列管理器的发送通道 A.B 和 B.A 如果运行成功的话你可以看到发送方和接收方的通道状态为 正在运行。</strong>\r\n\r\n现在你可以来测试一下消息的发送了。分别选择A B队列管理的远程队列并放入一些测试的消息。然后（大约1秒左右）你就可以看到A B队列管理的本地队列 A.loc 和 B.loc 接收了对方的消息\r\n\r\n&nbsp;','MQ的配置并用java来实现发送和接收消息','','publish','open','open','','mq%e7%9a%84%e9%85%8d%e7%bd%ae%e5%b9%b6%e7%94%a8java%e6%9d%a5%e5%ae%9e%e7%8e%b0%e5%8f%91%e9%80%81%e5%92%8c%e6%8e%a5%e6%94%b6%e6%b6%88%e6%81%af','','','2013-08-23 13:55:04','2013-08-23 05:55:04','',0,'http://localhost/wordpress-new/?p=76',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (77,1,'2013-08-23 13:55:04','2013-08-23 05:55:04','前面对IBM MQ做了一些简单的介绍。现在让我们来具体的实现如何配置MQ并通过MQ提供的API ，使用java来实现消息的传递.\r\n\r\n<strong>1.配置MQ</strong>\r\n\r\n在真实的环境中IBM　MQ传递消息是在不同的机器上配置MQ网络来进行的。当前我们只使用本机来实现与远程MQ服务的消息传递。首先准备你的机器并确保已安装好IBM WebSphere MQ 。打开我们的MQ资源管理器。然后开始如下步骤来实现MQ通信管理器的配置。\r\n\r\n<strong>1.右键选择队列管理器</strong>。分别创建2个队列管理器 A 和 B 并配置他们的属性由于是在同一台机器上配置2个队列管理器因此需要分配不同的端口：A : 127.0.0.1(1416)    B:127.0.0.1(1417)\r\n\r\n2.创建完A ，B2个队列管理器后 为他们分别创建队列和通信通道。选择队列管理器A 为其新建队列\r\n\r\n<strong>2.1.新建本地队列</strong> A.loc  采用默认设置 .再新建一个本地队列A.tran 修改其用法属性为传输。A.tran也叫做传输队列，其作为与远程队列进行打交道的通信队列.\r\n\r\n2.2 采用同样的方法为队列管理器B 创建 一个本地队列 和一个传输队列分别为 B.loc和 B.tran\r\n\r\n<strong>3.然后为了与远程队列管理器B打交道需要为远程队列管理器A 配置一个远程队列定义</strong> A.rem并设置其如下属性\r\n\r\n远程队列 B.loc  远程队列管理器 B 传输队列 A.tran\r\n\r\n那么反过来如果B要想A通信也需要配置一个远程队列定义 指向A 那么也需要对管理器B进行配置 远程队列 B.rem\r\n\r\n远程队列A.loc 远程队列管理器 B 传输队列 B.tran\r\n\r\n从这里可以看出队列管理器就像一个网络系统一样。如果需要通信那么需要知道对方的通信名称或者地址 远程队列定义就是用来干这事儿的。当然就像网络一样只知道名字还不行 得知道具体的位置在哪里。那么下面我们就来让他们互相知道对方的具体位置在网络上的哪个地方。\r\n\r\n<strong>4.配置通道</strong>\r\n\r\n为选择队列管理器A  创建发送方通道名称  A.B 并配置其如下属性\r\n\r\n连接名称: 127.0.0.1(1417)    --可以看出在这里就为我们的队列管理器A与队列管理器B同上信了\r\n\r\n传输队列 A.tran\r\n\r\n同样的为了让B能向管理器A通信 也要为其创建发送方通道 B.A 并配置其属性\r\n\r\n连接名称:127.0.0.1(1416) 传输队列 B.tran\r\n\r\n4.1.既然创建了发送通道自然需要 创建一个接收的通道分别为A和B创建接收通道B.A 和 A.B 默认设置\r\n\r\n4.2 为了使队列管理器之间通过API编程进行通信还需要分别为他们创建服务器连接名称 svrcon\r\n\r\n<strong>最后 我们分别启动2个队列管理器的发送通道 A.B 和 B.A 如果运行成功的话你可以看到发送方和接收方的通道状态为 正在运行。</strong>\r\n\r\n现在你可以来测试一下消息的发送了。分别选择A B队列管理的远程队列并放入一些测试的消息。然后（大约1秒左右）你就可以看到A B队列管理的本地队列 A.loc 和 B.loc 接收了对方的消息\r\n\r\n&nbsp;','MQ的配置并用java来实现发送和接收消息','','inherit','open','open','','76-revision-v1','','','2013-08-23 13:55:04','2013-08-23 05:55:04','',76,'http://localhost/wordpress-new/?p=77',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (78,1,'2013-08-23 13:55:40','2013-08-23 05:55:40','上次我们讲到如何配置MQ来实现本机的通信。这次我们使用java编程来实现这么一个过程。\r\n\r\n当前在eclipse环境下进行测试 注意需要导入包com.ibm.mq.jar。如果是单独的在控制台下进行测试时除了com.ibm.mq.jar包外 还会缺少一些包 在运行的时候请注意。\r\n\r\n<strong>发送方</strong>\r\n\r\npublic class MQSend {\r\npublic static byte[] put(String msg) {\r\ntry {\r\nString hostName = \"127.0.0.1\";\r\nString channel = \"svrcon\";//服务器连接通道\r\nString qManager = \"A\";\r\nString qName = \"A.rem\";//向管理器A的远程队列发消息 管理器A通过配置会向管理器B的本地队列放消息\r\n/* 设置MQEnvironment 属性以便客户机连接 */\r\nMQEnvironment.hostname = hostName;\r\nMQEnvironment.channel = channel;\r\nMQEnvironment.port =1416; //端口\r\nMQEnvironment.CCSID = 819;//字符集\r\nMQEnvironment.properties.put(MQC.TRANSPORT_PROPERTY,MQC.TRANSPORT_MQSERIES_BINDINGS);\r\nMQQueueManager qMgr = new MQQueueManager(qManager);/* 连接到队列管理器 */\r\n/* 设置打开选项以便打开用于输出的队列，如果队列管理器正在停止，我们也已设置了选项去应对不成功情况。 */\r\n/* MQC.MQOO_SET_IDENTITY_CONTEXT 启用唯一标识 */\r\nint openOptions = MQC.MQOO_OUTPUT | MQC.MQOO_FAIL_IF_QUIESCING|MQC.MQOO_SET_IDENTITY_CONTEXT;\r\nMQQueue queue = qMgr.accessQueue(qName, openOptions, null, null,null);/* 打开队列 */\r\n/* 设置放置消息选项我们将使用默认设置 */\r\nMQPutMessageOptions pmo = new MQPutMessageOptions();\r\npmo.options = pmo.options + MQC.MQPMO_NEW_MSG_ID;\r\npmo.options = pmo.options + MQC.MQPMO_SYNCPOINT;\r\npmo.options = pmo.options + MQC.MQOO_SET_IDENTITY_CONTEXT;/* 创建消息缓冲区 */\r\nMQMessage outMsg = new MQMessage();\r\n/* 设置MQMD 格式字段 */\r\noutMsg.format = MQC.MQFMT_NONE;\r\noutMsg.characterSet= 819;\r\noutMsg.messageId = MQC.MQMI_NONE;\r\n//outMsg.correlationId = id1.getBytes(); 可以配置其接收的id\r\n//当不指定correlationId时默认为outMsg.messageId;\r\n/* 准备用户数据消息 并以字节传递*/\r\noutMsg.write(msg.getBytes(\"GBK\"));\r\n/* 向队列上放置消息 */\r\nqueue.put(outMsg, pmo);\r\n/*获取 id用于接收方取消息的标识*/\r\nbyte[] id=outMsg.messageId;\r\n/* 关闭队列和队列管理器对象 */\r\nqMgr.commit();\r\nqueue.close();\r\nqMgr.disconnect();\r\nreturn id;\r\n} catch (MQException ex) {ex.printStackTrace();\r\n} catch (Exception e) {e.printStackTrace();}\r\nreturn null;\r\n}}\r\n\r\n<strong>接收方</strong>\r\n\r\npublic class MQRevi {\r\npublic static void get(byte[] id ) {\r\ntry{\r\nString hostName = \"127.0.0.1\";\r\nString channel = \"svrcon\";\r\nString qManager = \"B\";\r\nString qName = \"B.loc\";/*从队列管理器的本地队列取消息 接收通过管理器A的远程队列发送的消息*/\r\nMQEnvironment.addConnectionPoolToken();\r\n/* 设置MQEnvironment 属性以便客户机连接 */\r\nMQEnvironment.hostname = hostName;\r\nMQEnvironment.channel = channel;\r\nMQEnvironment.port =1417;\r\nMQEnvironment.CCSID = 819;\r\nMQEnvironment.properties.put(MQC.TRANSPORT_PROPERTY,MQC.TRANSPORT_MQSERIES_BINDINGS);\r\nMQQueueManager qMgr = new MQQueueManager(qManager);/* 连接到队列管理器 */\r\n/* 设置打开选项以便打开用于输出的队列，如果队列管理器正在停止，我们也已设置了选项去应对不成功情况。 */\r\nint openOptions = MQC.MQOO_INPUT_SHARED | MQC.MQOO_FAIL_IF_QUIESCING;\r\nMQQueue que = qMgr.accessQueue(qName, openOptions, null, null,null); //设置取出消息的属性（默认属性）\r\nMQGetMessageOptions gmo = new MQGetMessageOptions();\r\ngmo.options =gmo.options + MQC.MQGMO_SYNCPOINT /*在同步点控制下获取消息*/\r\n+ MQC.MQGMO_WAIT /*如果在队列上没有消息则等待*/\r\n+ MQC.MQGMO_FAIL_IF_QUIESCING; /*如果队列管理器停顿则失败*/\r\ngmo.waitInterval = 3000 ;/*设置等待的时间限制*/MQC.MQEI_UNLIMITED 可以设置无限等待直到 有数据为止\r\nMQMessage retrievedMessage = new MQMessage();// 从队列中取出消息\r\n//retrievedMessage.correlationId = id;//如果发送方没有指定correlationId则不能设置\r\n//且//gmo.matchOptions = MQC.MQMO_MATCH_CORREL_ID;也需要设置\r\nretrievedMessage.messageId = id;\r\nque.get(retrievedMessage, gmo);\r\nbyte[] msgBuffer = new byte[retrievedMessage.getMessageLength()];\r\nretrievedMessage.readFully(msgBuffer);\r\nString response = new String(msgBuffer, \"GBK\");\r\nSystem.out.println(response);//输出消息\r\n/* 关闭队列和队列管理器对象 */\r\nqMgr.commit();\r\nque.close();\r\nqMgr.disconnect();\r\n} catch (MQException ex) {ex.printStackTrace();\r\n} catch (Exception e) {e.printStackTrace();}\r\n}}\r\n\r\n测试发送和接收\r\n\r\npublic class MQTest {\r\npublic static void main(String args[]) {\r\nbyte[] id1 = MQSend.put(\"我\");\r\nbyte[]id2 =MQSend.put(\"你\");\r\nbyte[]id3 = MQSend.put(\"他\");\r\nThread.sleep(3000);//接收方可能需要对消息进行处理\r\nMQRevi.get(id2);//根据发送时获取的msgid来获取对应的消息\r\n}\r\n}\r\n\r\n输出: 你\r\n\r\n小结 通过IBM MQ可以很方便的实现不同系统之间的信息传递。对于开发人员来说不需要去与底层的数据传输打交道，提高了开发效率。从上面的列子可以看出系统通过MQ可以实现 2个系统之间消息的实时和异步传递。对应用开发来说 实时和异步可能会有区别，但对于MQ来说 不管是实时还是异步消息都是一样的。打个比方说对于需要<strong>实时返回的信息</strong> 。发送方直接发送消息到A的远程队列A.rem，接收方在经过处理后回复应答消息到B的远程队列B.rem 。而MQ则负责消息的传递。通过上面的例子对于发送方来说发送消息后，通过waittime，立即访问A的本地队列A.loc 获取从接收方B方发过来的应答信息。在这里从应用上来说是实时返回的，应用系统可能需要设置超时时间一般来说10秒左右,如果超时则抛弃该条消息。 而对于<strong>异步返回的信息</strong>，对于MQ来说没有任何区别，只在于应用系统发送消息后，可以在任何时候打开本地队列去获取从接收方反馈的消息（如果有的话），而我们的系统可能需要设置一个循环时间去打开本地队列A.loc看看本地队列管理器A是否收到从B发来的消息.因此MQ系统，就好比一个邮件系统，你可以随时发送信件给对方， 而当对方发送邮件给你的时候你不需要守在邮箱方便，只是在你需要收邮件的时候去看一看你的邮箱是否有邮件.\r\n\r\n备注：MQ 还提供了对消息通道的压缩算法以提高对大消息的传输性能，当然这对应用是透明的你只需要在MQ里进行配置即可或者在进行发送时直接设置MQ的属性如\r\n\r\nCollection msgComp = new Vector();\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_ZLIBFAST));\r\n/*\r\n* 支持MQC.MQCOMPRESS_ZLIBFAST 、MQC.MQCOMPRESS_RLE\r\n* 、MQC.MQCOMPRESS_ZLIBHIGH 、MQC.MQCOMPRESS_SYSTEM\r\n* 、MQC.MQCOMPRESS_NONE 、MQC.MQCOMPRESS_NOT_AVAILABLE 等多种压缩算法\r\n*/\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_RLE));\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_ZLIBHIGH));\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_SYSTEM));\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_NONE));\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_NOT_AVAILABLE));\r\nMQEnvironment.msgCompList = msgComp;\r\n\r\n行程编码 (RLE) 压缩算法需要非常少的处理器时间，适用于在连续位置重复许多相同字节值的数据。对不具有此重复级别的数据无效。\r\nZLIB 压缩算法需要更多的处理器时间，但适用于更具变化性的数据。\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;','使用Java编程来实现MQ消息的发送','','publish','open','open','','%e4%bd%bf%e7%94%a8java%e7%bc%96%e7%a8%8b%e6%9d%a5%e5%ae%9e%e7%8e%b0mq%e6%b6%88%e6%81%af%e7%9a%84%e5%8f%91%e9%80%81','','','2013-08-23 13:55:40','2013-08-23 05:55:40','',0,'http://localhost/wordpress-new/?p=78',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (79,1,'2013-08-23 13:55:40','2013-08-23 05:55:40','上次我们讲到如何配置MQ来实现本机的通信。这次我们使用java编程来实现这么一个过程。\r\n\r\n当前在eclipse环境下进行测试 注意需要导入包com.ibm.mq.jar。如果是单独的在控制台下进行测试时除了com.ibm.mq.jar包外 还会缺少一些包 在运行的时候请注意。\r\n\r\n<strong>发送方</strong>\r\n\r\npublic class MQSend {\r\npublic static byte[] put(String msg) {\r\ntry {\r\nString hostName = \"127.0.0.1\";\r\nString channel = \"svrcon\";//服务器连接通道\r\nString qManager = \"A\";\r\nString qName = \"A.rem\";//向管理器A的远程队列发消息 管理器A通过配置会向管理器B的本地队列放消息\r\n/* 设置MQEnvironment 属性以便客户机连接 */\r\nMQEnvironment.hostname = hostName;\r\nMQEnvironment.channel = channel;\r\nMQEnvironment.port =1416; //端口\r\nMQEnvironment.CCSID = 819;//字符集\r\nMQEnvironment.properties.put(MQC.TRANSPORT_PROPERTY,MQC.TRANSPORT_MQSERIES_BINDINGS);\r\nMQQueueManager qMgr = new MQQueueManager(qManager);/* 连接到队列管理器 */\r\n/* 设置打开选项以便打开用于输出的队列，如果队列管理器正在停止，我们也已设置了选项去应对不成功情况。 */\r\n/* MQC.MQOO_SET_IDENTITY_CONTEXT 启用唯一标识 */\r\nint openOptions = MQC.MQOO_OUTPUT | MQC.MQOO_FAIL_IF_QUIESCING|MQC.MQOO_SET_IDENTITY_CONTEXT;\r\nMQQueue queue = qMgr.accessQueue(qName, openOptions, null, null,null);/* 打开队列 */\r\n/* 设置放置消息选项我们将使用默认设置 */\r\nMQPutMessageOptions pmo = new MQPutMessageOptions();\r\npmo.options = pmo.options + MQC.MQPMO_NEW_MSG_ID;\r\npmo.options = pmo.options + MQC.MQPMO_SYNCPOINT;\r\npmo.options = pmo.options + MQC.MQOO_SET_IDENTITY_CONTEXT;/* 创建消息缓冲区 */\r\nMQMessage outMsg = new MQMessage();\r\n/* 设置MQMD 格式字段 */\r\noutMsg.format = MQC.MQFMT_NONE;\r\noutMsg.characterSet= 819;\r\noutMsg.messageId = MQC.MQMI_NONE;\r\n//outMsg.correlationId = id1.getBytes(); 可以配置其接收的id\r\n//当不指定correlationId时默认为outMsg.messageId;\r\n/* 准备用户数据消息 并以字节传递*/\r\noutMsg.write(msg.getBytes(\"GBK\"));\r\n/* 向队列上放置消息 */\r\nqueue.put(outMsg, pmo);\r\n/*获取 id用于接收方取消息的标识*/\r\nbyte[] id=outMsg.messageId;\r\n/* 关闭队列和队列管理器对象 */\r\nqMgr.commit();\r\nqueue.close();\r\nqMgr.disconnect();\r\nreturn id;\r\n} catch (MQException ex) {ex.printStackTrace();\r\n} catch (Exception e) {e.printStackTrace();}\r\nreturn null;\r\n}}\r\n\r\n<strong>接收方</strong>\r\n\r\npublic class MQRevi {\r\npublic static void get(byte[] id ) {\r\ntry{\r\nString hostName = \"127.0.0.1\";\r\nString channel = \"svrcon\";\r\nString qManager = \"B\";\r\nString qName = \"B.loc\";/*从队列管理器的本地队列取消息 接收通过管理器A的远程队列发送的消息*/\r\nMQEnvironment.addConnectionPoolToken();\r\n/* 设置MQEnvironment 属性以便客户机连接 */\r\nMQEnvironment.hostname = hostName;\r\nMQEnvironment.channel = channel;\r\nMQEnvironment.port =1417;\r\nMQEnvironment.CCSID = 819;\r\nMQEnvironment.properties.put(MQC.TRANSPORT_PROPERTY,MQC.TRANSPORT_MQSERIES_BINDINGS);\r\nMQQueueManager qMgr = new MQQueueManager(qManager);/* 连接到队列管理器 */\r\n/* 设置打开选项以便打开用于输出的队列，如果队列管理器正在停止，我们也已设置了选项去应对不成功情况。 */\r\nint openOptions = MQC.MQOO_INPUT_SHARED | MQC.MQOO_FAIL_IF_QUIESCING;\r\nMQQueue que = qMgr.accessQueue(qName, openOptions, null, null,null); //设置取出消息的属性（默认属性）\r\nMQGetMessageOptions gmo = new MQGetMessageOptions();\r\ngmo.options =gmo.options + MQC.MQGMO_SYNCPOINT /*在同步点控制下获取消息*/\r\n+ MQC.MQGMO_WAIT /*如果在队列上没有消息则等待*/\r\n+ MQC.MQGMO_FAIL_IF_QUIESCING; /*如果队列管理器停顿则失败*/\r\ngmo.waitInterval = 3000 ;/*设置等待的时间限制*/MQC.MQEI_UNLIMITED 可以设置无限等待直到 有数据为止\r\nMQMessage retrievedMessage = new MQMessage();// 从队列中取出消息\r\n//retrievedMessage.correlationId = id;//如果发送方没有指定correlationId则不能设置\r\n//且//gmo.matchOptions = MQC.MQMO_MATCH_CORREL_ID;也需要设置\r\nretrievedMessage.messageId = id;\r\nque.get(retrievedMessage, gmo);\r\nbyte[] msgBuffer = new byte[retrievedMessage.getMessageLength()];\r\nretrievedMessage.readFully(msgBuffer);\r\nString response = new String(msgBuffer, \"GBK\");\r\nSystem.out.println(response);//输出消息\r\n/* 关闭队列和队列管理器对象 */\r\nqMgr.commit();\r\nque.close();\r\nqMgr.disconnect();\r\n} catch (MQException ex) {ex.printStackTrace();\r\n} catch (Exception e) {e.printStackTrace();}\r\n}}\r\n\r\n测试发送和接收\r\n\r\npublic class MQTest {\r\npublic static void main(String args[]) {\r\nbyte[] id1 = MQSend.put(\"我\");\r\nbyte[]id2 =MQSend.put(\"你\");\r\nbyte[]id3 = MQSend.put(\"他\");\r\nThread.sleep(3000);//接收方可能需要对消息进行处理\r\nMQRevi.get(id2);//根据发送时获取的msgid来获取对应的消息\r\n}\r\n}\r\n\r\n输出: 你\r\n\r\n小结 通过IBM MQ可以很方便的实现不同系统之间的信息传递。对于开发人员来说不需要去与底层的数据传输打交道，提高了开发效率。从上面的列子可以看出系统通过MQ可以实现 2个系统之间消息的实时和异步传递。对应用开发来说 实时和异步可能会有区别，但对于MQ来说 不管是实时还是异步消息都是一样的。打个比方说对于需要<strong>实时返回的信息</strong> 。发送方直接发送消息到A的远程队列A.rem，接收方在经过处理后回复应答消息到B的远程队列B.rem 。而MQ则负责消息的传递。通过上面的例子对于发送方来说发送消息后，通过waittime，立即访问A的本地队列A.loc 获取从接收方B方发过来的应答信息。在这里从应用上来说是实时返回的，应用系统可能需要设置超时时间一般来说10秒左右,如果超时则抛弃该条消息。 而对于<strong>异步返回的信息</strong>，对于MQ来说没有任何区别，只在于应用系统发送消息后，可以在任何时候打开本地队列去获取从接收方反馈的消息（如果有的话），而我们的系统可能需要设置一个循环时间去打开本地队列A.loc看看本地队列管理器A是否收到从B发来的消息.因此MQ系统，就好比一个邮件系统，你可以随时发送信件给对方， 而当对方发送邮件给你的时候你不需要守在邮箱方便，只是在你需要收邮件的时候去看一看你的邮箱是否有邮件.\r\n\r\n备注：MQ 还提供了对消息通道的压缩算法以提高对大消息的传输性能，当然这对应用是透明的你只需要在MQ里进行配置即可或者在进行发送时直接设置MQ的属性如\r\n\r\nCollection msgComp = new Vector();\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_ZLIBFAST));\r\n/*\r\n* 支持MQC.MQCOMPRESS_ZLIBFAST 、MQC.MQCOMPRESS_RLE\r\n* 、MQC.MQCOMPRESS_ZLIBHIGH 、MQC.MQCOMPRESS_SYSTEM\r\n* 、MQC.MQCOMPRESS_NONE 、MQC.MQCOMPRESS_NOT_AVAILABLE 等多种压缩算法\r\n*/\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_RLE));\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_ZLIBHIGH));\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_SYSTEM));\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_NONE));\r\nmsgComp.add(new Integer(MQC.MQCOMPRESS_NOT_AVAILABLE));\r\nMQEnvironment.msgCompList = msgComp;\r\n\r\n行程编码 (RLE) 压缩算法需要非常少的处理器时间，适用于在连续位置重复许多相同字节值的数据。对不具有此重复级别的数据无效。\r\nZLIB 压缩算法需要更多的处理器时间，但适用于更具变化性的数据。\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;','使用Java编程来实现MQ消息的发送','','inherit','open','open','','78-revision-v1','','','2013-08-23 13:55:40','2013-08-23 05:55:40','',78,'http://localhost/wordpress-new/?p=79',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (80,1,'2013-08-23 13:56:27','2013-08-23 05:56:27','<strong>ADB quickview</strong>\r\nManage the state of an emulator or device\r\nRun shell commands on a device\r\nManage port forwarding on an emulator or device\r\nCopy files to/from an emulator or device\r\n\r\n<strong>Android Debug Bridge </strong>\r\n\r\nAndroid Debug Bridge (adb) is a versatile command line tool that lets you communicate with an emulator instance or connected Android-powered device. It is a client-server program that includes three components:\r\nA client, which runs on your development machine. You can invoke a client from a shell by issuing an adb command. Other Android tools such as the ADT plugin and DDMS also create adb clients.\r\nA server, which runs as a background process on your development machine. The server manages communication between the client and the adb daemon running on an emulator or device.\r\nA daemon, which runs as a background process on each emulator or device instance.\r\n\r\nYou can find the adb tool in &lt;sdk&gt;/platform-tools/.\r\n\r\nWhen you start an adb client, the client first checks whether there is an adb server process already running. If there isn\'t, it starts the server process. When the server starts, it binds to local TCP port 5037 and listens for commands sent from adb clients—all adb clients use port 5037 to communicate with the adb server.\r\n\r\nThe server then sets up connections to all running emulator/device instances. It locates emulator/device instances by scanning odd-numbered ports in the range 5555 to 5585, the range used by emulators/devices. Where the server finds an adb daemon, it sets up a connection to that port. Note that each emulator/device instance acquires a pair of sequential ports — an even-numbered port for console connections and an odd-numbered port for adb connections. For example:\r\n\r\nEmulator 1, console: 5554\r\nEmulator 1, adb: 5555\r\nEmulator 2, console: 5556\r\nEmulator 2, adb: 5557 ...\r\n\r\nAs shown, the emulator instance connected to adb on port 5555 is the same as the instance whose console listens on port 5554.\r\n\r\nOnce the server has set up connections to all emulator instances, you can use adb commands to control and access those instances. Because the server manages connections to emulator/device instances and handles commands from multiple adb clients, you can control any emulator/device instance from any client (or from a script).\r\n\r\nThe sections below describe the commands that you can use to access adb capabilities and manage the state of an emulator/device. Note that if you are developing Android applications in Eclipse and have installed the ADT plugin, you do not need to access adb from the command line. The ADT plugin provides a transparent integration of adb into the Eclipse IDE. However, you can still use adb directly as necessary, such as for debugging.','Android Debug Bridge (ADB)','','publish','open','open','','android-debug-bridge-adb','','','2013-08-23 13:56:27','2013-08-23 05:56:27','',0,'http://localhost/wordpress-new/?p=80',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (81,1,'2013-08-23 13:56:27','2013-08-23 05:56:27','<strong>ADB quickview</strong>\r\nManage the state of an emulator or device\r\nRun shell commands on a device\r\nManage port forwarding on an emulator or device\r\nCopy files to/from an emulator or device\r\n\r\n<strong>Android Debug Bridge </strong>\r\n\r\nAndroid Debug Bridge (adb) is a versatile command line tool that lets you communicate with an emulator instance or connected Android-powered device. It is a client-server program that includes three components:\r\nA client, which runs on your development machine. You can invoke a client from a shell by issuing an adb command. Other Android tools such as the ADT plugin and DDMS also create adb clients.\r\nA server, which runs as a background process on your development machine. The server manages communication between the client and the adb daemon running on an emulator or device.\r\nA daemon, which runs as a background process on each emulator or device instance.\r\n\r\nYou can find the adb tool in &lt;sdk&gt;/platform-tools/.\r\n\r\nWhen you start an adb client, the client first checks whether there is an adb server process already running. If there isn\'t, it starts the server process. When the server starts, it binds to local TCP port 5037 and listens for commands sent from adb clients—all adb clients use port 5037 to communicate with the adb server.\r\n\r\nThe server then sets up connections to all running emulator/device instances. It locates emulator/device instances by scanning odd-numbered ports in the range 5555 to 5585, the range used by emulators/devices. Where the server finds an adb daemon, it sets up a connection to that port. Note that each emulator/device instance acquires a pair of sequential ports — an even-numbered port for console connections and an odd-numbered port for adb connections. For example:\r\n\r\nEmulator 1, console: 5554\r\nEmulator 1, adb: 5555\r\nEmulator 2, console: 5556\r\nEmulator 2, adb: 5557 ...\r\n\r\nAs shown, the emulator instance connected to adb on port 5555 is the same as the instance whose console listens on port 5554.\r\n\r\nOnce the server has set up connections to all emulator instances, you can use adb commands to control and access those instances. Because the server manages connections to emulator/device instances and handles commands from multiple adb clients, you can control any emulator/device instance from any client (or from a script).\r\n\r\nThe sections below describe the commands that you can use to access adb capabilities and manage the state of an emulator/device. Note that if you are developing Android applications in Eclipse and have installed the ADT plugin, you do not need to access adb from the command line. The ADT plugin provides a transparent integration of adb into the Eclipse IDE. However, you can still use adb directly as necessary, such as for debugging.','Android Debug Bridge (ADB)','','inherit','open','open','','80-revision-v1','','','2013-08-23 13:56:27','2013-08-23 05:56:27','',80,'http://localhost/wordpress-new/?p=81',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (82,1,'2013-08-23 13:56:52','2013-08-23 05:56:52','Jive论坛的一个主要特点就是其性能速度快，因此很多巨大访问量的网站都采用了Jive论坛。这些都是由于Jive采取了高速缓存机制。\r\n\r\n缓存（Cache）机制是提高系统运行性能必不可少的技术。缓存机制从原理上讲比较简单，就是在原始数据第一次读取后保存在内存中，下次读取时，就直接从内存中读取。原始数据有可能保存在持久化介质或网络上。缓存机制也是代理模式的一种实现。\r\n4.1 缓存原理和实现\r\n\r\nJive的Cache总体来说实现得不是非常精简和有效。它是针对每个具体数据对象逐个实现缓冲，这种“穷尽”的办法不是实践所推荐的用法。通过使用动态代理模式，可以根据具体方法的不同来实现缓存是值得推荐的做法。Jive的缓存实现得比较简单，可以用来学习和研究缓存机制。\r\n\r\nJive中的Cache实现了缓存机制的大部分行为，它是将对象用惟一的关键字Key作标识保存在HashMap或Hashtable中。当然，必须知道这些对象的大小，这个前提条件的设定可以保证缓存增长时不会超过规定的最大值。\r\n\r\n如果缓存增长得太大，一些不经常被访问的对象将首先从缓存中删除。如果设置了对象的最大生命周期时间，即使这个对象被反复频繁访问，也将从缓存中删除。这个特性可以适用于一些周期性需要刷新的数据，如来自数据库的数据。\r\n\r\n在Cach中除了getObject()方法的性能依据缓存大小，其他方法的性能都是比较快的。一个HashMap用来实现快速寻找，两个LinkedList中一个以一定的访问顺序来保存对象，叫accessed LinkedList；另外一个以它们加入缓存的顺序保存这些对象，这种保存对象只是保存对象的引用，叫 age LinkedList。注意，这里的LinkedList不是JDK中的LinkedList，而是Jive自己定义的LinkedList。\r\n\r\n当对象被加入缓存时，首先被CacheObject封装。封装有以下信息：对象大小（以字节计算），一个指向accessed LinkedList的引用，一个指向age LinkedList的引用。\r\n\r\n当从缓存中获取一个对象如ObjectA时，首先，HashMap寻找到指向封装ObjectA等信息的CacheObject对象。然后，这个对象将被移动到accessed LinkedList的前面，还有其他一些动作如缓存清理、删除、过期失效等都是在这个动作中一起触发实现的。\r\n\r\npublic class Cache implements Cacheable {\r\n\r\n/**\r\n\r\n* 因为System.currentTimeMillis()执行非常耗费性能，因此如果get操作都执行\r\n\r\n* 这条语句将会形成性能瓶颈， 通过一个全局时间戳来实现每秒更新\r\n\r\n* 当然，这意味着在缓存过期时间计算上有一到几秒的误差\r\n\r\n*/\r\n\r\nprotected static long currentTime = CacheTimer.currentTime;\r\n\r\n//CacheObject对象\r\n\r\nprotected HashMap cachedObjectsHash;\r\n\r\n//accessed LinkedList 最经常访问的排列在最前面\r\n\r\nprotected LinkedList lastAccessedList;\r\n\r\n//以缓存加入顺序排列，最后加入排在最前面；越早加入的排在最后面\r\n\r\nprotected LinkedList ageList;\r\n\r\n//缓存最大限制 默认是128k 可根据内存设定，越大性能越高\r\n\r\nprotected int maxSize = 128 * 1024;\r\n\r\n//当前缓存的大小\r\n\r\nprotected int size = 0;\r\n\r\n//最大生命周期时间，默认是没有\r\n\r\nprotected long maxLifetime = -1;\r\n\r\n//缓存的击中率，用于评测缓存效率\r\n\r\nprotected long cacheHits, cacheMisses = 0L;\r\n\r\npublic Cache() {\r\n\r\n// 构造HashMap. 默认capacity 是11\r\n\r\n// 如果实际大小超过11，HashMap将自动扩充，但是每次扩充都\r\n\r\n// 是性能开销，因此期初要设置大一点\r\n\r\ncachedObjectsHash = new HashMap(103);\r\n\r\nlastAccessedList = new LinkedList();\r\n\r\nageList = new LinkedList();\r\n\r\n}\r\n\r\npublic Cache(int maxSize) {\r\n\r\nthis();\r\n\r\nthis.maxSize = maxSize;\r\n\r\n}\r\n\r\npublic Cache(long maxLifetime) {\r\n\r\nthis();\r\n\r\nthis.maxLifetime = maxLifetime;\r\n\r\n}\r\n\r\npublic Cache(int maxSize, long maxLifetime) {\r\n\r\nthis();\r\n\r\nthis.maxSize = maxSize;\r\n\r\nthis.maxLifetime = maxLifetime;\r\n\r\n}\r\n\r\npublic int getSize() { return size; }\r\n\r\npublic int getMaxSize() { return maxSize; }\r\n\r\npublic void setMaxSize(int maxSize) {\r\n\r\nthis.maxSize = maxSize;\r\n\r\n// 有可能缓存大小超过最大值，需要激活删除清理动作\r\n\r\ncullCache();\r\n\r\n}\r\n\r\npublic synchronized int getNumElements() {\r\n\r\nreturn cachedObjectsHash.size();\r\n\r\n}\r\n\r\n/**\r\n\r\n* 增加一个Cacheable对象\r\n\r\n* 因为HashMap不是线程安全的，所以操作方法要使用同步\r\n\r\n* 如果使用Hashtable就不必同步\r\n\r\n*/\r\n\r\npublic synchronized void add(Object key, Cacheable object) {\r\n\r\n// 删除已经存在的key\r\n\r\nremove(key);\r\n\r\nint objectSize = object.getSize();\r\n\r\n// 如果被缓存对象的大小超过最大值，就放弃\r\n\r\nif (objectSize &gt; maxSize * .90) { return; }\r\n\r\nsize += objectSize;\r\n\r\n//创建一个CacheObject对象\r\n\r\nCacheObject cacheObject = new CacheObject(object, objectSize);\r\n\r\ncachedObjectsHash.put(key, cacheObject); //保存这个CacheObject\r\n\r\n// 加入accessed LinkedList，Jive自己的LinkedList在加入时可以返回值\r\n\r\nLinkedListNode lastAccessedNode = lastAccessedList.addFirst(key);\r\n\r\n// 保存引用\r\n\r\ncacheObject.lastAccessedListNode = lastAccessedNode;\r\n\r\n// 加入到age LinkedList\r\n\r\nLinkedListNode ageNode = ageList.addFirst(key);\r\n\r\n// 这里直接调用System.currentTimeMillis();用法值得讨论\r\n\r\nageNode.timestamp = System.currentTimeMillis();\r\n\r\n// 保存引用\r\n\r\ncacheObject.ageListNode = ageNode;\r\n\r\n// 做一些清理工作\r\n\r\ncullCache();\r\n\r\n}\r\n\r\n/**\r\n\r\n* 从缓存中获得一个被缓存的对象，这个方法在下面两种情况返回空\r\n\r\n* &lt;li&gt;该对象引用从来没有被加入缓存中\r\n\r\n* &lt;li&gt;对象引用因为过期被清除&lt;/ul&gt;\r\n\r\n*/\r\n\r\npublic synchronized Cacheable get(Object key) {\r\n\r\n// 清除过期缓存\r\n\r\ndeleteExpiredEntries();\r\n\r\n//以Key从缓存中获取一个对象引用\r\n\r\nCacheObject cacheObject = (CacheObject)cachedObjectsHash.get(key);\r\n\r\nif (cacheObject == null) {\r\n\r\n// 不存在，增加未命中率\r\n\r\ncacheMisses++;\r\n\r\nreturn null;\r\n\r\n}\r\n\r\n// 存在，增加命中率\r\n\r\ncacheHits++;\r\n\r\n// 从accessed LinkedList中将对象从当前位置删除\r\n\r\n// 重新插入在第一个\r\n\r\ncacheObject.lastAccessedListNode.remove();\r\n\r\nlastAccessedList.addFirst(cacheObject.lastAccessedListNode);\r\n\r\nreturn cacheObject.object;\r\n\r\n}\r\n\r\n…\r\n\r\n}\r\n\r\n在Cache中，关键字Key是一个对象，为了再次提高性能，可以进一步将Key确定为一个long类型的整数。\r\n4.2 缓存使用\r\n\r\n建立LongCache只是为了提高原来的Cache性能，本身无多大意义，可以将LongCache看成与Cache一样的类。\r\n\r\nLongCache的关键字Key是Forum、ForumThread以及 ForumMessage等long类型的ID，值Value是Forum、ForumThread以及ForumMessage等的对象。这些基本是通过DatabaseCacheManager实现完成，在主要类DbForumFactory的初始化构造时，同时构造了DatabaseCacheManager的实例cacheManager。\r\n\r\n前面过滤器功能分析中，Message对象获得方法的第一句如下：\r\n\r\nprotected ForumMessage getMessage(long messageID, long threadID, long forumID) throws\r\n\r\nForumMessageNotFoundException {\r\n\r\nDbForumMessage message = cacheManager.messageCache.get(messageID);\r\n\r\n…\r\n\r\n}\r\n\r\n其中，cacheManager是DatabaseCacheManager的实例，DatabaseCacheManager是一个缓存Facade类。在其中包含了5种类型的缓存，都是针对 Jive的5个主要对象，DatabaseCacheManager主要代码如下：\r\n\r\npublic class DatabaseCacheManager {\r\n\r\n…\r\n\r\npublic UserCache userCache; //用户资料缓存\r\n\r\npublic GroupCache groupCache; //组资料缓存\r\n\r\npublic ForumCache forumCache; //Forum论坛缓存\r\n\r\npublic ForumThreadCache threadCache; //Thread主题缓存\r\n\r\npublic ForumMessageCache messageCache; //Message缓存\r\n\r\npublic UserPermissionsCache userPermsCache; //用户权限缓存\r\n\r\npublic DatabaseCacheManager(DbForumFactory factory) {\r\n\r\n…\r\n\r\nforumCache =\r\n\r\nnew ForumCache(new LongCache(forumCacheSize, 6*HOUR), factory);\r\n\r\nthreadCache =\r\n\r\nnew ForumThreadCache(\r\n\r\nnew LongCache(threadCacheSize, 6*HOUR), factory);\r\n\r\nmessageCache = new ForumMessageCache(\r\n\r\nnew LongCache(messageCacheSize, 6*HOUR), factory);\r\n\r\nuserCache = new UserCache(\r\n\r\nnew LongCache(userCacheSize, 6*HOUR), factory);\r\n\r\ngroupCache = new GroupCache(\r\n\r\nnew LongCache(groupCacheSize, 6*HOUR), factory);\r\n\r\nuserPermsCache = new UserPermissionsCache(\r\n\r\nnew UserPermsCache(userPermCacheSize, 24*HOUR), factory\r\n\r\n);\r\n\r\n}\r\n\r\n…\r\n\r\n}\r\n\r\n从以上代码看出，ForumCache等对象生成都是以LongCache为基础构建的，以ForumCache为例，代码如下：\r\n\r\npublic class ForumCache extends DatabaseCache {\r\n\r\n//以Cache构建ID缓存\r\n\r\nprotected Cache forumIDCache = new Cache(128*1024, 6*JiveGlobals.HOUR);\r\n\r\n//以LongCache构建整个对象缓存\r\n\r\npublic ForumCache(LongCache cache, DbForumFactory forumFactory) {\r\n\r\nsuper(cache, forumFactory);\r\n\r\n}\r\n\r\npublic DbForum get(long forumID) throws ForumNotFoundException {\r\n\r\n…\r\n\r\nDbForum forum = (DbForum)cache.get(forumID);\r\n\r\nif (forum == null) { //如果缓存没有从数据库中获取\r\n\r\nforum = new DbForum(forumID, factory);\r\n\r\ncache.add(forumID, forum);\r\n\r\n}\r\n\r\nreturn forum;\r\n\r\n}\r\n\r\npublic Forum get(String name) throws ForumNotFoundException {\r\n\r\n//以name为key，从forumIDCache中获取ID\r\n\r\nCacheableLong forumIDLong = (CacheableLong)forumIDCache.get(name);\r\n\r\nif (forumIDLong == null) { //如果缓存没有 从数据库获得\r\n\r\nlong forumID = factory.getForumID(name);\r\n\r\nforumIDLong = new CacheableLong(forumID); //生成一个缓存对象\r\n\r\nforumIDCache.add(name, forumIDLong);\r\n\r\n}\r\n\r\nreturn get(forumIDLong.getLong());\r\n\r\n}\r\n\r\n…\r\n\r\n}\r\n\r\n由此可以看到，LongCache封装了Cache的核心功能，而ForumCache等类则是在LongCache核心外又包装了与应用系统相关的操作，这有点类似装饰（Decorator）模式。\r\n\r\n从中也可以看到Cache和LongCache两种缓存的用法。\r\n\r\n使用Cache时的关键字Key是任何字段。如上面代码中的String name，如果用户大量帖子主题查询中，Key是query + blockID，见DbForum中的getThreadBlock方法；而值Value则是Long类型的ID，如ForumID或ThreadID等。\r\n\r\nLongCache的关键字Key是Long类型的ID，如ForumID或ThreadID等；而值Value则是Forum、ForumThread或ForumMessage等主要具体对象。\r\n\r\n在实际使用中，大多数是根据ID获得对象。但有时并不是这样，因此根据应用区分了两种Cache，这其实类似数据库的数据表，除了主关键字外还有其他关键字。\r\n4.3 小结\r\n\r\n缓存中对象是原对象的映射，如何确保缓存中对象和原对象的一致性？即当原对象发生变化时，缓存中的对象也必须立即更新。这是缓存机制需要解决的另外一个基本技术问题。\r\n\r\nJive中是在原对象发生变化时，立即进行清除缓存中对象，如ForumMessage对象的创建。在DbForumThread的AddMessage方法中有下列语句：\r\n\r\nfactory.cacheManager.threadCache.remove(this.id);\r\n\r\nfactory.cacheManager.forumCache.remove(this.forumID);\r\n\r\n即当有新的帖子加入时，将ForumThreadCache和ForumCache相关缓冲全部清除。这样，当有相关对象读取时，将直接从数据库中读取，这是一种非常简单的缓存更新方式。\r\n\r\n在复杂的系统，例如有一台以上的服务器运行着Jive系统。如果一个用户登陆一台服务器后，通过这台服务器增加新帖。那么按照上述原理，只能更新本服务器JVM中的缓存数据，而其他服务器则无从得知这种改变，这就需要一种分布式的缓存机制。\r\n\r\n到目前可以发现，整个Jive系统其实是围绕Forum、ForumThread和ForumMessage等这些主要对象展开的读取、修改或创建等操作。由于这些对象原先持久化保存在数据库中，为了提高性能和加强安全性，Jive在这些对象外面分别实现两层包装，如图3-7所示。\r\n\r\n客户端如果需要访问这些对象，首先要经过它们的代理对象。进行访问权限的检查，然后再从缓存中获取该对象。只有缓存不存在时，才会从数据库中获取。\r\n\r\n这套机制是大多数应用系统都面临的必须解决的基本功能，因此完全可以做成一个通用的可重复使用的框架。这样在具体应用时，不必每个应用系统都架设开发这样的机制。其实EJB就是这样一套框架，实体Bean都由缓存机制支持，而通过设定ejb-jar.xml可以实现访问权限控制，这些工作都直接由EJB容器实现了，不必在代码中自己来实现。剩余的工作是调整EJB容器的参数，使之适合应用系统的具体要求，这些将在以后章节中讨论。\r\n\r\n在Jive中，图3-7的机制是通过不同方式实现的。基本上是一配二模式：一个对象有一个缓冲对象和一个代理对象，这样做的一个缺点是导致对象太多，系统变得复杂。这点在阅读Jive源码时可能已经发现。\r\n\r\n如果建立一个对象工厂，工厂内部封装了图3-7机制实现过程，客户端可以根据不同的工厂输入参数获得具体不同的对象。这样也许代码结构要更加抽象和紧凑，Java的动态代理API也许是实现这个工厂的主要技术基础。有兴趣者可以进一步研究提炼','Jive的缓存机制','','publish','open','open','','jive%e7%9a%84%e7%bc%93%e5%ad%98%e6%9c%ba%e5%88%b6','','','2013-08-23 13:56:52','2013-08-23 05:56:52','',0,'http://localhost/wordpress-new/?p=82',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (83,1,'2013-08-23 13:56:52','2013-08-23 05:56:52','Jive论坛的一个主要特点就是其性能速度快，因此很多巨大访问量的网站都采用了Jive论坛。这些都是由于Jive采取了高速缓存机制。\r\n\r\n缓存（Cache）机制是提高系统运行性能必不可少的技术。缓存机制从原理上讲比较简单，就是在原始数据第一次读取后保存在内存中，下次读取时，就直接从内存中读取。原始数据有可能保存在持久化介质或网络上。缓存机制也是代理模式的一种实现。\r\n4.1 缓存原理和实现\r\n\r\nJive的Cache总体来说实现得不是非常精简和有效。它是针对每个具体数据对象逐个实现缓冲，这种“穷尽”的办法不是实践所推荐的用法。通过使用动态代理模式，可以根据具体方法的不同来实现缓存是值得推荐的做法。Jive的缓存实现得比较简单，可以用来学习和研究缓存机制。\r\n\r\nJive中的Cache实现了缓存机制的大部分行为，它是将对象用惟一的关键字Key作标识保存在HashMap或Hashtable中。当然，必须知道这些对象的大小，这个前提条件的设定可以保证缓存增长时不会超过规定的最大值。\r\n\r\n如果缓存增长得太大，一些不经常被访问的对象将首先从缓存中删除。如果设置了对象的最大生命周期时间，即使这个对象被反复频繁访问，也将从缓存中删除。这个特性可以适用于一些周期性需要刷新的数据，如来自数据库的数据。\r\n\r\n在Cach中除了getObject()方法的性能依据缓存大小，其他方法的性能都是比较快的。一个HashMap用来实现快速寻找，两个LinkedList中一个以一定的访问顺序来保存对象，叫accessed LinkedList；另外一个以它们加入缓存的顺序保存这些对象，这种保存对象只是保存对象的引用，叫 age LinkedList。注意，这里的LinkedList不是JDK中的LinkedList，而是Jive自己定义的LinkedList。\r\n\r\n当对象被加入缓存时，首先被CacheObject封装。封装有以下信息：对象大小（以字节计算），一个指向accessed LinkedList的引用，一个指向age LinkedList的引用。\r\n\r\n当从缓存中获取一个对象如ObjectA时，首先，HashMap寻找到指向封装ObjectA等信息的CacheObject对象。然后，这个对象将被移动到accessed LinkedList的前面，还有其他一些动作如缓存清理、删除、过期失效等都是在这个动作中一起触发实现的。\r\n\r\npublic class Cache implements Cacheable {\r\n\r\n/**\r\n\r\n* 因为System.currentTimeMillis()执行非常耗费性能，因此如果get操作都执行\r\n\r\n* 这条语句将会形成性能瓶颈， 通过一个全局时间戳来实现每秒更新\r\n\r\n* 当然，这意味着在缓存过期时间计算上有一到几秒的误差\r\n\r\n*/\r\n\r\nprotected static long currentTime = CacheTimer.currentTime;\r\n\r\n//CacheObject对象\r\n\r\nprotected HashMap cachedObjectsHash;\r\n\r\n//accessed LinkedList 最经常访问的排列在最前面\r\n\r\nprotected LinkedList lastAccessedList;\r\n\r\n//以缓存加入顺序排列，最后加入排在最前面；越早加入的排在最后面\r\n\r\nprotected LinkedList ageList;\r\n\r\n//缓存最大限制 默认是128k 可根据内存设定，越大性能越高\r\n\r\nprotected int maxSize = 128 * 1024;\r\n\r\n//当前缓存的大小\r\n\r\nprotected int size = 0;\r\n\r\n//最大生命周期时间，默认是没有\r\n\r\nprotected long maxLifetime = -1;\r\n\r\n//缓存的击中率，用于评测缓存效率\r\n\r\nprotected long cacheHits, cacheMisses = 0L;\r\n\r\npublic Cache() {\r\n\r\n// 构造HashMap. 默认capacity 是11\r\n\r\n// 如果实际大小超过11，HashMap将自动扩充，但是每次扩充都\r\n\r\n// 是性能开销，因此期初要设置大一点\r\n\r\ncachedObjectsHash = new HashMap(103);\r\n\r\nlastAccessedList = new LinkedList();\r\n\r\nageList = new LinkedList();\r\n\r\n}\r\n\r\npublic Cache(int maxSize) {\r\n\r\nthis();\r\n\r\nthis.maxSize = maxSize;\r\n\r\n}\r\n\r\npublic Cache(long maxLifetime) {\r\n\r\nthis();\r\n\r\nthis.maxLifetime = maxLifetime;\r\n\r\n}\r\n\r\npublic Cache(int maxSize, long maxLifetime) {\r\n\r\nthis();\r\n\r\nthis.maxSize = maxSize;\r\n\r\nthis.maxLifetime = maxLifetime;\r\n\r\n}\r\n\r\npublic int getSize() { return size; }\r\n\r\npublic int getMaxSize() { return maxSize; }\r\n\r\npublic void setMaxSize(int maxSize) {\r\n\r\nthis.maxSize = maxSize;\r\n\r\n// 有可能缓存大小超过最大值，需要激活删除清理动作\r\n\r\ncullCache();\r\n\r\n}\r\n\r\npublic synchronized int getNumElements() {\r\n\r\nreturn cachedObjectsHash.size();\r\n\r\n}\r\n\r\n/**\r\n\r\n* 增加一个Cacheable对象\r\n\r\n* 因为HashMap不是线程安全的，所以操作方法要使用同步\r\n\r\n* 如果使用Hashtable就不必同步\r\n\r\n*/\r\n\r\npublic synchronized void add(Object key, Cacheable object) {\r\n\r\n// 删除已经存在的key\r\n\r\nremove(key);\r\n\r\nint objectSize = object.getSize();\r\n\r\n// 如果被缓存对象的大小超过最大值，就放弃\r\n\r\nif (objectSize &gt; maxSize * .90) { return; }\r\n\r\nsize += objectSize;\r\n\r\n//创建一个CacheObject对象\r\n\r\nCacheObject cacheObject = new CacheObject(object, objectSize);\r\n\r\ncachedObjectsHash.put(key, cacheObject); //保存这个CacheObject\r\n\r\n// 加入accessed LinkedList，Jive自己的LinkedList在加入时可以返回值\r\n\r\nLinkedListNode lastAccessedNode = lastAccessedList.addFirst(key);\r\n\r\n// 保存引用\r\n\r\ncacheObject.lastAccessedListNode = lastAccessedNode;\r\n\r\n// 加入到age LinkedList\r\n\r\nLinkedListNode ageNode = ageList.addFirst(key);\r\n\r\n// 这里直接调用System.currentTimeMillis();用法值得讨论\r\n\r\nageNode.timestamp = System.currentTimeMillis();\r\n\r\n// 保存引用\r\n\r\ncacheObject.ageListNode = ageNode;\r\n\r\n// 做一些清理工作\r\n\r\ncullCache();\r\n\r\n}\r\n\r\n/**\r\n\r\n* 从缓存中获得一个被缓存的对象，这个方法在下面两种情况返回空\r\n\r\n* &lt;li&gt;该对象引用从来没有被加入缓存中\r\n\r\n* &lt;li&gt;对象引用因为过期被清除&lt;/ul&gt;\r\n\r\n*/\r\n\r\npublic synchronized Cacheable get(Object key) {\r\n\r\n// 清除过期缓存\r\n\r\ndeleteExpiredEntries();\r\n\r\n//以Key从缓存中获取一个对象引用\r\n\r\nCacheObject cacheObject = (CacheObject)cachedObjectsHash.get(key);\r\n\r\nif (cacheObject == null) {\r\n\r\n// 不存在，增加未命中率\r\n\r\ncacheMisses++;\r\n\r\nreturn null;\r\n\r\n}\r\n\r\n// 存在，增加命中率\r\n\r\ncacheHits++;\r\n\r\n// 从accessed LinkedList中将对象从当前位置删除\r\n\r\n// 重新插入在第一个\r\n\r\ncacheObject.lastAccessedListNode.remove();\r\n\r\nlastAccessedList.addFirst(cacheObject.lastAccessedListNode);\r\n\r\nreturn cacheObject.object;\r\n\r\n}\r\n\r\n…\r\n\r\n}\r\n\r\n在Cache中，关键字Key是一个对象，为了再次提高性能，可以进一步将Key确定为一个long类型的整数。\r\n4.2 缓存使用\r\n\r\n建立LongCache只是为了提高原来的Cache性能，本身无多大意义，可以将LongCache看成与Cache一样的类。\r\n\r\nLongCache的关键字Key是Forum、ForumThread以及 ForumMessage等long类型的ID，值Value是Forum、ForumThread以及ForumMessage等的对象。这些基本是通过DatabaseCacheManager实现完成，在主要类DbForumFactory的初始化构造时，同时构造了DatabaseCacheManager的实例cacheManager。\r\n\r\n前面过滤器功能分析中，Message对象获得方法的第一句如下：\r\n\r\nprotected ForumMessage getMessage(long messageID, long threadID, long forumID) throws\r\n\r\nForumMessageNotFoundException {\r\n\r\nDbForumMessage message = cacheManager.messageCache.get(messageID);\r\n\r\n…\r\n\r\n}\r\n\r\n其中，cacheManager是DatabaseCacheManager的实例，DatabaseCacheManager是一个缓存Facade类。在其中包含了5种类型的缓存，都是针对 Jive的5个主要对象，DatabaseCacheManager主要代码如下：\r\n\r\npublic class DatabaseCacheManager {\r\n\r\n…\r\n\r\npublic UserCache userCache; //用户资料缓存\r\n\r\npublic GroupCache groupCache; //组资料缓存\r\n\r\npublic ForumCache forumCache; //Forum论坛缓存\r\n\r\npublic ForumThreadCache threadCache; //Thread主题缓存\r\n\r\npublic ForumMessageCache messageCache; //Message缓存\r\n\r\npublic UserPermissionsCache userPermsCache; //用户权限缓存\r\n\r\npublic DatabaseCacheManager(DbForumFactory factory) {\r\n\r\n…\r\n\r\nforumCache =\r\n\r\nnew ForumCache(new LongCache(forumCacheSize, 6*HOUR), factory);\r\n\r\nthreadCache =\r\n\r\nnew ForumThreadCache(\r\n\r\nnew LongCache(threadCacheSize, 6*HOUR), factory);\r\n\r\nmessageCache = new ForumMessageCache(\r\n\r\nnew LongCache(messageCacheSize, 6*HOUR), factory);\r\n\r\nuserCache = new UserCache(\r\n\r\nnew LongCache(userCacheSize, 6*HOUR), factory);\r\n\r\ngroupCache = new GroupCache(\r\n\r\nnew LongCache(groupCacheSize, 6*HOUR), factory);\r\n\r\nuserPermsCache = new UserPermissionsCache(\r\n\r\nnew UserPermsCache(userPermCacheSize, 24*HOUR), factory\r\n\r\n);\r\n\r\n}\r\n\r\n…\r\n\r\n}\r\n\r\n从以上代码看出，ForumCache等对象生成都是以LongCache为基础构建的，以ForumCache为例，代码如下：\r\n\r\npublic class ForumCache extends DatabaseCache {\r\n\r\n//以Cache构建ID缓存\r\n\r\nprotected Cache forumIDCache = new Cache(128*1024, 6*JiveGlobals.HOUR);\r\n\r\n//以LongCache构建整个对象缓存\r\n\r\npublic ForumCache(LongCache cache, DbForumFactory forumFactory) {\r\n\r\nsuper(cache, forumFactory);\r\n\r\n}\r\n\r\npublic DbForum get(long forumID) throws ForumNotFoundException {\r\n\r\n…\r\n\r\nDbForum forum = (DbForum)cache.get(forumID);\r\n\r\nif (forum == null) { //如果缓存没有从数据库中获取\r\n\r\nforum = new DbForum(forumID, factory);\r\n\r\ncache.add(forumID, forum);\r\n\r\n}\r\n\r\nreturn forum;\r\n\r\n}\r\n\r\npublic Forum get(String name) throws ForumNotFoundException {\r\n\r\n//以name为key，从forumIDCache中获取ID\r\n\r\nCacheableLong forumIDLong = (CacheableLong)forumIDCache.get(name);\r\n\r\nif (forumIDLong == null) { //如果缓存没有 从数据库获得\r\n\r\nlong forumID = factory.getForumID(name);\r\n\r\nforumIDLong = new CacheableLong(forumID); //生成一个缓存对象\r\n\r\nforumIDCache.add(name, forumIDLong);\r\n\r\n}\r\n\r\nreturn get(forumIDLong.getLong());\r\n\r\n}\r\n\r\n…\r\n\r\n}\r\n\r\n由此可以看到，LongCache封装了Cache的核心功能，而ForumCache等类则是在LongCache核心外又包装了与应用系统相关的操作，这有点类似装饰（Decorator）模式。\r\n\r\n从中也可以看到Cache和LongCache两种缓存的用法。\r\n\r\n使用Cache时的关键字Key是任何字段。如上面代码中的String name，如果用户大量帖子主题查询中，Key是query + blockID，见DbForum中的getThreadBlock方法；而值Value则是Long类型的ID，如ForumID或ThreadID等。\r\n\r\nLongCache的关键字Key是Long类型的ID，如ForumID或ThreadID等；而值Value则是Forum、ForumThread或ForumMessage等主要具体对象。\r\n\r\n在实际使用中，大多数是根据ID获得对象。但有时并不是这样，因此根据应用区分了两种Cache，这其实类似数据库的数据表，除了主关键字外还有其他关键字。\r\n4.3 小结\r\n\r\n缓存中对象是原对象的映射，如何确保缓存中对象和原对象的一致性？即当原对象发生变化时，缓存中的对象也必须立即更新。这是缓存机制需要解决的另外一个基本技术问题。\r\n\r\nJive中是在原对象发生变化时，立即进行清除缓存中对象，如ForumMessage对象的创建。在DbForumThread的AddMessage方法中有下列语句：\r\n\r\nfactory.cacheManager.threadCache.remove(this.id);\r\n\r\nfactory.cacheManager.forumCache.remove(this.forumID);\r\n\r\n即当有新的帖子加入时，将ForumThreadCache和ForumCache相关缓冲全部清除。这样，当有相关对象读取时，将直接从数据库中读取，这是一种非常简单的缓存更新方式。\r\n\r\n在复杂的系统，例如有一台以上的服务器运行着Jive系统。如果一个用户登陆一台服务器后，通过这台服务器增加新帖。那么按照上述原理，只能更新本服务器JVM中的缓存数据，而其他服务器则无从得知这种改变，这就需要一种分布式的缓存机制。\r\n\r\n到目前可以发现，整个Jive系统其实是围绕Forum、ForumThread和ForumMessage等这些主要对象展开的读取、修改或创建等操作。由于这些对象原先持久化保存在数据库中，为了提高性能和加强安全性，Jive在这些对象外面分别实现两层包装，如图3-7所示。\r\n\r\n客户端如果需要访问这些对象，首先要经过它们的代理对象。进行访问权限的检查，然后再从缓存中获取该对象。只有缓存不存在时，才会从数据库中获取。\r\n\r\n这套机制是大多数应用系统都面临的必须解决的基本功能，因此完全可以做成一个通用的可重复使用的框架。这样在具体应用时，不必每个应用系统都架设开发这样的机制。其实EJB就是这样一套框架，实体Bean都由缓存机制支持，而通过设定ejb-jar.xml可以实现访问权限控制，这些工作都直接由EJB容器实现了，不必在代码中自己来实现。剩余的工作是调整EJB容器的参数，使之适合应用系统的具体要求，这些将在以后章节中讨论。\r\n\r\n在Jive中，图3-7的机制是通过不同方式实现的。基本上是一配二模式：一个对象有一个缓冲对象和一个代理对象，这样做的一个缺点是导致对象太多，系统变得复杂。这点在阅读Jive源码时可能已经发现。\r\n\r\n如果建立一个对象工厂，工厂内部封装了图3-7机制实现过程，客户端可以根据不同的工厂输入参数获得具体不同的对象。这样也许代码结构要更加抽象和紧凑，Java的动态代理API也许是实现这个工厂的主要技术基础。有兴趣者可以进一步研究提炼','Jive的缓存机制','','inherit','open','open','','82-revision-v1','','','2013-08-23 13:56:52','2013-08-23 05:56:52','',82,'http://localhost/wordpress-new/?p=83',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (84,1,'2013-08-23 13:57:20','2013-08-23 05:57:20','很多人对二级缓存都不太了解，或者是有错误的认识，我一直想写一篇文章介绍一下hibernate的二级缓存的，今天终于忍不住了。\r\n我的经验主要来自hibernate2.1版本，基本原理和3.0、3.1是一样的，请原谅我的顽固不化。\r\n\r\nhibernate的session提供了一级缓存，每个session，对同一个id进行两次load，不会发送两条sql给数据库，但是session关闭的时候，一级缓存就失效了。\r\n\r\n二级缓存是SessionFactory级别的全局缓存，它底下可以使用不同的缓存类库，比如ehcache、oscache等，需要设置hibernate.cache.provider_class，我们这里用ehcache，在2.1中就是\r\nhibernate.cache.provider_class=net.sf.hibernate.cache.EhCacheProvider\r\n如果使用查询缓存，加上\r\nhibernate.cache.use_query_cache=true\r\n\r\n缓存可以简单的看成一个Map，通过key在缓存里面找value。\r\n\r\nClass的缓存\r\n对于一条记录，也就是一个PO来说，是根据ID来找的，缓存的key就是ID，value是POJO。无论list，load还是iterate，只要读出一个对象，都会填充缓存。但是list不会使用缓存，而iterate会先取数据库select id出来，然后一个id一个id的load，如果在缓存里面有，就从缓存取，没有的话就去数据库load。假设是读写缓存，需要设置：\r\n&amp;lt;cache usage=\"read-write\"/&amp;gt;\r\n如果你使用的二级缓存实现是ehcache的话，需要配置ehcache.xml\r\n&amp;lt;cache name=\"com.xxx.pojo.Foo\" maxElementsInMemory=\"500\" eternal=\"false\" timeToLiveSeconds=\"7200\" timeToIdleSeconds=\"3600\" overflowToDisk=\"true\" /&amp;gt;\r\n其中eternal表示缓存是不是永远不超时，timeToLiveSeconds是缓存中每个元素（这里也就是一个POJO）的超时时间，如果eternal=\"false\"，超过指定的时间，这个元素就被移走了。timeToIdleSeconds是发呆时间，是可选的。当往缓存里面put的元素超过500个时，如果overflowToDisk=\"true\"，就会把缓存中的部分数据保存在硬盘上的临时文件里面。\r\n每个需要缓存的class都要这样配置。如果你没有配置，hibernate会在启动的时候警告你，然后使用defaultCache的配置，这样多个class会共享一个配置。\r\n当某个ID通过hibernate修改时，hibernate会知道，于是移除缓存。\r\n这样大家可能会想，同样的查询条件，第一次先list，第二次再iterate，就可以使用到缓存了。实际上这是很难的，因为你无法判断什么时候是第一次，而且每次查询的条件通常是不一样的，假如数据库里面有100条记录，id从1到100，第一次list的时候出了前50个id，第二次iterate的时候却查询到30至70号id，那么30-50是从缓存里面取的，51到70是从数据库取的，共发送1+20条sql。所以我一直认为iterate没有什么用，总是会有1+N的问题。\r\n（题外话：有说法说大型查询用list会把整个结果集装入内存，很慢，而iterate只select id比较好，但是大型查询总是要分页查的，谁也不会真的把整个结果集装进来，假如一页20条的话，iterate共需要执行21条语句，list虽然选择若干字段，比iterate第一条select id语句慢一些，但只有一条语句，不装入整个结果集hibernate还会根据数据库方言做优化，比如使用mysql的limit，整体看来应该还是list快。）\r\n如果想要对list或者iterate查询的结果缓存，就要用到查询缓存了\r\n\r\n查询缓存\r\n首先需要配置hibernate.cache.use_query_cache=true\r\n如果用ehcache，配置ehcache.xml，注意hibernate3.0以后不是net.sf的包名了\r\n&amp;lt;cache name=\"net.sf.hibernate.cache.StandardQueryCache\"\r\nmaxElementsInMemory=\"50\" eternal=\"false\" timeToIdleSeconds=\"3600\"\r\ntimeToLiveSeconds=\"7200\" overflowToDisk=\"true\"/&amp;gt;\r\n&amp;lt;cache name=\"net.sf.hibernate.cache.UpdateTimestampsCache\"\r\nmaxElementsInMemory=\"5000\" eternal=\"true\" overflowToDisk=\"true\"/&amp;gt;\r\n然后\r\nquery.setCacheable(true);//激活查询缓存\r\nquery.setCacheRegion(\"myCacheRegion\");//指定要使用的cacheRegion，可选\r\n第二行指定要使用的cacheRegion是myCacheRegion，即你可以给每个查询缓存做一个单独的配置，使用setCacheRegion来做这个指定，需要在ehcache.xml里面配置它：\r\n&amp;lt;cache name=\"myCacheRegion\" maxElementsInMemory=\"10\" eternal=\"false\" timeToIdleSeconds=\"3600\" timeToLiveSeconds=\"7200\" overflowToDisk=\"true\" /&amp;gt;\r\n如果省略第二行，不设置cacheRegion的话，那么会使用上面提到的标准查询缓存的配置，也就是net.sf.hibernate.cache.StandardQueryCache\r\n\r\n对于查询缓存来说，缓存的key是根据hql生成的sql，再加上参数，分页等信息（可以通过日志输出看到，不过它的输出不是很可读，最好改一下它的代码）。\r\n比如hql：\r\nfrom Cat c where c.name like ?\r\n生成大致如下的sql：\r\nselect * from cat c where c.name like ?\r\n参数是\"tiger%\"，那么查询缓存的key*大约*是这样的字符串（我是凭记忆写的，并不精确，不过看了也该明白了）：\r\nselect * from cat c where c.name like ? , parameter:tiger%\r\n这样，保证了同样的查询、同样的参数等条件下具有一样的key。\r\n现在说说缓存的value，如果是list方式的话，value在这里并不是整个结果集，而是查询出来的这一串ID。也就是说，不管是list方法还是iterate方法，第一次查询的时候，它们的查询方式很它们平时的方式是一样的，list执行一条sql，iterate执行1+N条，多出来的行为是它们填充了缓存。但是到同样条件第二次查询的时候，就都和iterate的行为一样了，根据缓存的key去缓存里面查到了value，value是一串id，然后在到class的缓存里面去一个一个的load出来。这样做是为了节约内存。\r\n可以看出来，查询缓存需要打开相关类的class缓存。list和iterate方法第一次执行的时候，都是既填充查询缓存又填充class缓存的。\r\n这里还有一个很容易被忽视的重要问题，即打开查询缓存以后，即使是list方法也可能遇到1+N的问题！相同条件第一次list的时候，因为查询缓存中找不到，不管class缓存是否存在数据，总是发送一条sql语句到数据库获取全部数据，然后填充查询缓存和class缓存。但是第二次执行的时候，问题就来了，如果你的class缓存的超时时间比较短，现在class缓存都超时了，但是查询缓存还在，那么list方法在获取id串以后，将会一个一个去数据库load！因此，class缓存的超时时间一定不能短于查询缓存设置的超时时间！如果还设置了发呆时间的话，保证class缓存的发呆时间也大于查询的缓存的生存时间。这里还有其他情况，比如class缓存被程序强制evict了，这种情况就请自己注意了。\r\n\r\n另外，如果hql查询包含select字句，那么查询缓存里面的value就是整个结果集了。\r\n\r\n当hibernate更新数据库的时候，它怎么知道更新哪些查询缓存呢？\r\nhibernate在一个地方维护每个表的最后更新时间，其实也就是放在上面net.sf.hibernate.cache.UpdateTimestampsCache所指定的缓存配置里面。\r\n当通过hibernate更新的时候，hibernate会知道这次更新影响了哪些表。然后它更新这些表的最后更新时间。每个缓存都有一个生成时间和这个缓存所查询的表，当hibernate查询一个缓存是否存在的时候，如果缓存存在，它还要取出缓存的生成时间和这个缓存所查询的表，然后去查找这些表的最后更新时间，如果有一个表在生成时间后更新过了，那么这个缓存是无效的。\r\n可以看出，只要更新过一个表，那么凡是涉及到这个表的查询缓存就失效了，因此查询缓存的命中率可能会比较低。\r\n\r\nCollection缓存\r\n需要在hbm的collection里面设置\r\n&amp;lt;cache usage=\"read-write\"/&amp;gt;\r\n假如class是Cat，collection叫children，那么ehcache里面配置\r\n&amp;lt;cache name=\"com.xxx.pojo.Cat.children\"\r\nmaxElementsInMemory=\"20\" eternal=\"false\" timeToIdleSeconds=\"3600\" timeToLiveSeconds=\"7200\"\r\noverflowToDisk=\"true\" /&amp;gt;\r\nCollection的缓存和前面查询缓存的list一样，也是只保持一串id，但它不会因为这个表更新过就失效，一个collection缓存仅在这个collection里面的元素有增删时才失效。\r\n这样有一个问题，如果你的collection是根据某个字段排序的，当其中一个元素更新了该字段时，导致顺序改变时，collection缓存里面的顺序没有做更新。\r\n\r\n缓存策略\r\n只读缓存（read-only）：没有什么好说的\r\n读/写缓存（read-write）:程序可能要的更新数据\r\n不严格的读/写缓存（nonstrict-read-write）：需要更新数据，但是两个事务更新同一条记录的可能性很小，性能比读写缓存好\r\n事务缓存（transactional）：缓存支持事务，发生异常的时候，缓存也能够回滚，只支持jta环境，这个我没有怎么研究过\r\n\r\n读写缓存和不严格读写缓存在实现上的区别在于，读写缓存更新缓存的时候会把缓存里面的数据换成一个锁，其他事务如果去取相应的缓存数据，发现被锁住了，然后就直接取数据库查询。\r\n在hibernate2.1的ehcache实现中，如果锁住部分缓存的事务发生了异常，那么缓存会一直被锁住，直到60秒后超时。\r\n不严格读写缓存不锁定缓存中的数据。\r\n\r\n使用二级缓存的前置条件\r\n你的hibernate程序对数据库有独占的写访问权，其他的进程更新了数据库，hibernate是不可能知道的。你操作数据库必需直接通过hibernate，如果你调用存储过程，或者自己使用jdbc更新数据库，hibernate也是不知道的。hibernate3.0的大批量更新和删除是不更新二级缓存的，但是据说3.1已经解决了这个问题。\r\n这个限制相当的棘手，有时候hibernate做批量更新、删除很慢，但是你却不能自己写jdbc来优化，很郁闷吧。\r\nSessionFactory也提供了移除缓存的方法，你一定要自己写一些JDBC的话，可以调用这些方法移除缓存，这些方法是：\r\nvoid evict(Class persistentClass)\r\nEvict all entries from the second-level cache.\r\nvoid evict(Class persistentClass, Serializable id)\r\nEvict an entry from the second-level cache.\r\nvoid evictCollection(String roleName)\r\nEvict all entries from the second-level cache.\r\nvoid evictCollection(String roleName, Serializable id)\r\nEvict an entry from the second-level cache.\r\nvoid evictQueries()\r\nEvict any query result sets cached in the default query cache region.\r\nvoid evictQueries(String cacheRegion)\r\nEvict any query result sets cached in the named query cache region.\r\n不过我不建议这样做，因为这样很难维护。比如你现在用JDBC批量更新了某个表，有3个查询缓存会用到这个表，用evictQueries(String cacheRegion)移除了3个查询缓存，然后用evict(Class persistentClass)移除了class缓存，看上去好像完整了。不过哪天你添加了一个相关查询缓存，可能会忘记更新这里的移除代码。如果你的jdbc代码到处都是，在你添加一个查询缓存的时候，还知道其他什么地方也要做相应的改动吗？\r\n\r\n----------------------------------------------------\r\n\r\n总结：\r\n不要想当然的以为缓存一定能提高性能，仅仅在你能够驾驭它并且条件合适的情况下才是这样的。hibernate的二级缓存限制还是比较多的，不方便用jdbc可能会大大的降低更新性能。在不了解原理的情况下乱用，可能会有1+N的问题。不当的使用还可能导致读出脏数据。\r\n如果受不了hibernate的诸多限制，那么还是自己在应用程序的层面上做缓存吧。\r\n在越高的层面上做缓存，效果就会越好。就好像尽管磁盘有缓存，数据库还是要实现自己的缓存，尽管数据库有缓存，咱们的应用程序还是要做缓存。因为底层的缓存它并不知道高层要用这些数据干什么，只能做的比较通用，而高层可以有针对性的实现缓存，所以在更高的级别上做缓存，效果也要好些吧。','hibernate二级缓存','','publish','open','open','','hibernate%e4%ba%8c%e7%ba%a7%e7%bc%93%e5%ad%98','','','2013-08-23 13:57:20','2013-08-23 05:57:20','',0,'http://localhost/wordpress-new/?p=84',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (85,1,'2013-08-23 13:57:20','2013-08-23 05:57:20','很多人对二级缓存都不太了解，或者是有错误的认识，我一直想写一篇文章介绍一下hibernate的二级缓存的，今天终于忍不住了。\r\n我的经验主要来自hibernate2.1版本，基本原理和3.0、3.1是一样的，请原谅我的顽固不化。\r\n\r\nhibernate的session提供了一级缓存，每个session，对同一个id进行两次load，不会发送两条sql给数据库，但是session关闭的时候，一级缓存就失效了。\r\n\r\n二级缓存是SessionFactory级别的全局缓存，它底下可以使用不同的缓存类库，比如ehcache、oscache等，需要设置hibernate.cache.provider_class，我们这里用ehcache，在2.1中就是\r\nhibernate.cache.provider_class=net.sf.hibernate.cache.EhCacheProvider\r\n如果使用查询缓存，加上\r\nhibernate.cache.use_query_cache=true\r\n\r\n缓存可以简单的看成一个Map，通过key在缓存里面找value。\r\n\r\nClass的缓存\r\n对于一条记录，也就是一个PO来说，是根据ID来找的，缓存的key就是ID，value是POJO。无论list，load还是iterate，只要读出一个对象，都会填充缓存。但是list不会使用缓存，而iterate会先取数据库select id出来，然后一个id一个id的load，如果在缓存里面有，就从缓存取，没有的话就去数据库load。假设是读写缓存，需要设置：\r\n&amp;lt;cache usage=\"read-write\"/&amp;gt;\r\n如果你使用的二级缓存实现是ehcache的话，需要配置ehcache.xml\r\n&amp;lt;cache name=\"com.xxx.pojo.Foo\" maxElementsInMemory=\"500\" eternal=\"false\" timeToLiveSeconds=\"7200\" timeToIdleSeconds=\"3600\" overflowToDisk=\"true\" /&amp;gt;\r\n其中eternal表示缓存是不是永远不超时，timeToLiveSeconds是缓存中每个元素（这里也就是一个POJO）的超时时间，如果eternal=\"false\"，超过指定的时间，这个元素就被移走了。timeToIdleSeconds是发呆时间，是可选的。当往缓存里面put的元素超过500个时，如果overflowToDisk=\"true\"，就会把缓存中的部分数据保存在硬盘上的临时文件里面。\r\n每个需要缓存的class都要这样配置。如果你没有配置，hibernate会在启动的时候警告你，然后使用defaultCache的配置，这样多个class会共享一个配置。\r\n当某个ID通过hibernate修改时，hibernate会知道，于是移除缓存。\r\n这样大家可能会想，同样的查询条件，第一次先list，第二次再iterate，就可以使用到缓存了。实际上这是很难的，因为你无法判断什么时候是第一次，而且每次查询的条件通常是不一样的，假如数据库里面有100条记录，id从1到100，第一次list的时候出了前50个id，第二次iterate的时候却查询到30至70号id，那么30-50是从缓存里面取的，51到70是从数据库取的，共发送1+20条sql。所以我一直认为iterate没有什么用，总是会有1+N的问题。\r\n（题外话：有说法说大型查询用list会把整个结果集装入内存，很慢，而iterate只select id比较好，但是大型查询总是要分页查的，谁也不会真的把整个结果集装进来，假如一页20条的话，iterate共需要执行21条语句，list虽然选择若干字段，比iterate第一条select id语句慢一些，但只有一条语句，不装入整个结果集hibernate还会根据数据库方言做优化，比如使用mysql的limit，整体看来应该还是list快。）\r\n如果想要对list或者iterate查询的结果缓存，就要用到查询缓存了\r\n\r\n查询缓存\r\n首先需要配置hibernate.cache.use_query_cache=true\r\n如果用ehcache，配置ehcache.xml，注意hibernate3.0以后不是net.sf的包名了\r\n&amp;lt;cache name=\"net.sf.hibernate.cache.StandardQueryCache\"\r\nmaxElementsInMemory=\"50\" eternal=\"false\" timeToIdleSeconds=\"3600\"\r\ntimeToLiveSeconds=\"7200\" overflowToDisk=\"true\"/&amp;gt;\r\n&amp;lt;cache name=\"net.sf.hibernate.cache.UpdateTimestampsCache\"\r\nmaxElementsInMemory=\"5000\" eternal=\"true\" overflowToDisk=\"true\"/&amp;gt;\r\n然后\r\nquery.setCacheable(true);//激活查询缓存\r\nquery.setCacheRegion(\"myCacheRegion\");//指定要使用的cacheRegion，可选\r\n第二行指定要使用的cacheRegion是myCacheRegion，即你可以给每个查询缓存做一个单独的配置，使用setCacheRegion来做这个指定，需要在ehcache.xml里面配置它：\r\n&amp;lt;cache name=\"myCacheRegion\" maxElementsInMemory=\"10\" eternal=\"false\" timeToIdleSeconds=\"3600\" timeToLiveSeconds=\"7200\" overflowToDisk=\"true\" /&amp;gt;\r\n如果省略第二行，不设置cacheRegion的话，那么会使用上面提到的标准查询缓存的配置，也就是net.sf.hibernate.cache.StandardQueryCache\r\n\r\n对于查询缓存来说，缓存的key是根据hql生成的sql，再加上参数，分页等信息（可以通过日志输出看到，不过它的输出不是很可读，最好改一下它的代码）。\r\n比如hql：\r\nfrom Cat c where c.name like ?\r\n生成大致如下的sql：\r\nselect * from cat c where c.name like ?\r\n参数是\"tiger%\"，那么查询缓存的key*大约*是这样的字符串（我是凭记忆写的，并不精确，不过看了也该明白了）：\r\nselect * from cat c where c.name like ? , parameter:tiger%\r\n这样，保证了同样的查询、同样的参数等条件下具有一样的key。\r\n现在说说缓存的value，如果是list方式的话，value在这里并不是整个结果集，而是查询出来的这一串ID。也就是说，不管是list方法还是iterate方法，第一次查询的时候，它们的查询方式很它们平时的方式是一样的，list执行一条sql，iterate执行1+N条，多出来的行为是它们填充了缓存。但是到同样条件第二次查询的时候，就都和iterate的行为一样了，根据缓存的key去缓存里面查到了value，value是一串id，然后在到class的缓存里面去一个一个的load出来。这样做是为了节约内存。\r\n可以看出来，查询缓存需要打开相关类的class缓存。list和iterate方法第一次执行的时候，都是既填充查询缓存又填充class缓存的。\r\n这里还有一个很容易被忽视的重要问题，即打开查询缓存以后，即使是list方法也可能遇到1+N的问题！相同条件第一次list的时候，因为查询缓存中找不到，不管class缓存是否存在数据，总是发送一条sql语句到数据库获取全部数据，然后填充查询缓存和class缓存。但是第二次执行的时候，问题就来了，如果你的class缓存的超时时间比较短，现在class缓存都超时了，但是查询缓存还在，那么list方法在获取id串以后，将会一个一个去数据库load！因此，class缓存的超时时间一定不能短于查询缓存设置的超时时间！如果还设置了发呆时间的话，保证class缓存的发呆时间也大于查询的缓存的生存时间。这里还有其他情况，比如class缓存被程序强制evict了，这种情况就请自己注意了。\r\n\r\n另外，如果hql查询包含select字句，那么查询缓存里面的value就是整个结果集了。\r\n\r\n当hibernate更新数据库的时候，它怎么知道更新哪些查询缓存呢？\r\nhibernate在一个地方维护每个表的最后更新时间，其实也就是放在上面net.sf.hibernate.cache.UpdateTimestampsCache所指定的缓存配置里面。\r\n当通过hibernate更新的时候，hibernate会知道这次更新影响了哪些表。然后它更新这些表的最后更新时间。每个缓存都有一个生成时间和这个缓存所查询的表，当hibernate查询一个缓存是否存在的时候，如果缓存存在，它还要取出缓存的生成时间和这个缓存所查询的表，然后去查找这些表的最后更新时间，如果有一个表在生成时间后更新过了，那么这个缓存是无效的。\r\n可以看出，只要更新过一个表，那么凡是涉及到这个表的查询缓存就失效了，因此查询缓存的命中率可能会比较低。\r\n\r\nCollection缓存\r\n需要在hbm的collection里面设置\r\n&amp;lt;cache usage=\"read-write\"/&amp;gt;\r\n假如class是Cat，collection叫children，那么ehcache里面配置\r\n&amp;lt;cache name=\"com.xxx.pojo.Cat.children\"\r\nmaxElementsInMemory=\"20\" eternal=\"false\" timeToIdleSeconds=\"3600\" timeToLiveSeconds=\"7200\"\r\noverflowToDisk=\"true\" /&amp;gt;\r\nCollection的缓存和前面查询缓存的list一样，也是只保持一串id，但它不会因为这个表更新过就失效，一个collection缓存仅在这个collection里面的元素有增删时才失效。\r\n这样有一个问题，如果你的collection是根据某个字段排序的，当其中一个元素更新了该字段时，导致顺序改变时，collection缓存里面的顺序没有做更新。\r\n\r\n缓存策略\r\n只读缓存（read-only）：没有什么好说的\r\n读/写缓存（read-write）:程序可能要的更新数据\r\n不严格的读/写缓存（nonstrict-read-write）：需要更新数据，但是两个事务更新同一条记录的可能性很小，性能比读写缓存好\r\n事务缓存（transactional）：缓存支持事务，发生异常的时候，缓存也能够回滚，只支持jta环境，这个我没有怎么研究过\r\n\r\n读写缓存和不严格读写缓存在实现上的区别在于，读写缓存更新缓存的时候会把缓存里面的数据换成一个锁，其他事务如果去取相应的缓存数据，发现被锁住了，然后就直接取数据库查询。\r\n在hibernate2.1的ehcache实现中，如果锁住部分缓存的事务发生了异常，那么缓存会一直被锁住，直到60秒后超时。\r\n不严格读写缓存不锁定缓存中的数据。\r\n\r\n使用二级缓存的前置条件\r\n你的hibernate程序对数据库有独占的写访问权，其他的进程更新了数据库，hibernate是不可能知道的。你操作数据库必需直接通过hibernate，如果你调用存储过程，或者自己使用jdbc更新数据库，hibernate也是不知道的。hibernate3.0的大批量更新和删除是不更新二级缓存的，但是据说3.1已经解决了这个问题。\r\n这个限制相当的棘手，有时候hibernate做批量更新、删除很慢，但是你却不能自己写jdbc来优化，很郁闷吧。\r\nSessionFactory也提供了移除缓存的方法，你一定要自己写一些JDBC的话，可以调用这些方法移除缓存，这些方法是：\r\nvoid evict(Class persistentClass)\r\nEvict all entries from the second-level cache.\r\nvoid evict(Class persistentClass, Serializable id)\r\nEvict an entry from the second-level cache.\r\nvoid evictCollection(String roleName)\r\nEvict all entries from the second-level cache.\r\nvoid evictCollection(String roleName, Serializable id)\r\nEvict an entry from the second-level cache.\r\nvoid evictQueries()\r\nEvict any query result sets cached in the default query cache region.\r\nvoid evictQueries(String cacheRegion)\r\nEvict any query result sets cached in the named query cache region.\r\n不过我不建议这样做，因为这样很难维护。比如你现在用JDBC批量更新了某个表，有3个查询缓存会用到这个表，用evictQueries(String cacheRegion)移除了3个查询缓存，然后用evict(Class persistentClass)移除了class缓存，看上去好像完整了。不过哪天你添加了一个相关查询缓存，可能会忘记更新这里的移除代码。如果你的jdbc代码到处都是，在你添加一个查询缓存的时候，还知道其他什么地方也要做相应的改动吗？\r\n\r\n----------------------------------------------------\r\n\r\n总结：\r\n不要想当然的以为缓存一定能提高性能，仅仅在你能够驾驭它并且条件合适的情况下才是这样的。hibernate的二级缓存限制还是比较多的，不方便用jdbc可能会大大的降低更新性能。在不了解原理的情况下乱用，可能会有1+N的问题。不当的使用还可能导致读出脏数据。\r\n如果受不了hibernate的诸多限制，那么还是自己在应用程序的层面上做缓存吧。\r\n在越高的层面上做缓存，效果就会越好。就好像尽管磁盘有缓存，数据库还是要实现自己的缓存，尽管数据库有缓存，咱们的应用程序还是要做缓存。因为底层的缓存它并不知道高层要用这些数据干什么，只能做的比较通用，而高层可以有针对性的实现缓存，所以在更高的级别上做缓存，效果也要好些吧。','hibernate二级缓存','','inherit','open','open','','84-revision-v1','','','2013-08-23 13:57:20','2013-08-23 05:57:20','',84,'http://localhost/wordpress-new/?p=85',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (86,1,'2013-08-23 13:57:49','2013-08-23 05:57:49','缓存是位于应用程序与物理数据源之间，用于临时存放复制数据的内存区域，目的是为了减少应用程序对物理数据源访问的次数，从而提高应用程序的运行性能.\r\nHibernate在查询数据时，首先到缓存中去查找，如果找到就直接使用，找不到的时候就会从物理数据源中检索，所以，把频繁使用的数据加载到缓存区后，就可以大大减少应用程序对物理数据源的访问，使得程序的运行性能明显的提升.\r\n\r\nHibernate缓存分类：\r\n\r\nSession缓存，一级缓存.\r\n\r\nSessionFactory的缓存分为内置缓存和外置缓存.内置缓存中存放的是SessionFactory对象的一些集合属性包含的数据(映射元素据及预定义SQL语句等),对于应用程序来说,它是只读的.外置缓存中存放的是数据库数据的副本,其作用和一级缓存类似.二级缓存除了以内存作为存储介质外,还可以选用硬盘等外部存储设备.\r\n\r\nHibernate的缓存范围\r\n\r\nHibernate的一级缓存和二级缓存都位于均位于持久层,且均用于存放数据库数据的副本,最大的区别就是缓存的范围各不一样.\r\n\r\n缓存的范围分为3类:\r\n\r\n1.事务范围\r\n事务范围的缓存只能被当前事务访问,每个事务都有各自的缓存,缓存内的数据通常采用相互关联的对象形式.缓存的生命周期依赖于事务的生命周期,只有当事务结束时,缓存的生命周期才会结束.事务范围的缓存使用内存作为存储介质,一级缓存就属于事务范围.\r\n2.应用范围\r\n应用程序的缓存可以被应用范围内的所有事务共享访问.缓存的生命周期依赖于应用的生命周期,只有当应用结束时,缓存的生命周期才会结束.应用范围的缓存可以使用内存或硬盘作为存储介质,二级缓存就属于应用范围.\r\n3.集群范围\r\n在集群环境中,缓存被一个机器或多个机器的进程共享,缓存中的数据被复制到集群环境中的每个进程节点,进程间通过远程通信来保证缓存中的数据的一致,缓存中的数据通常采用对象的松散数据形式.\r\n\r\nHibernate的缓存管理\r\n\r\n一级缓存的管理:\r\n\r\nevit(Object obj) 将指定的持久化对象从一级缓存中清除,释放对象所占用的内存资源,指定对象从持久化状态变为脱管状态,从而成为游离对象.\r\nclear() 将一级缓存中的所有持久化对象清除,释放其占用的内存资源\r\ncontains(Object obj) 判断指定的对象是否存在于一级缓存中.\r\nflush() 刷新一级缓存区的内容,使之与数据库数据保持同步.\r\n\r\n二级缓存的管理:\r\n\r\nevict(Class arg0, Serializable arg1) 将某个类的指定ID的持久化对象从二级缓存中清除,释放对象所占用的资源.\r\n\r\nJava代码\r\nsessionFactory.evict(Customer.class, new Integer(1));\r\n\r\nevict(Class arg0) 将指定类的所有持久化对象从二级缓存中清除,释放其占用的内存资源.\r\n\r\nJava代码\r\nsessionFactory.evict(Customer.class);\r\n\r\nevictCollection(String arg0) 将指定类的所有持久化对象的指定集合从二级缓存中清除,释放其占用的内存资源.\r\n\r\nJava代码\r\nsessionFactory.evictCollection(\"Customer.orders\");\r\n\r\nHibernate的二级缓存的配置\r\n\r\n首先,不是所有的数据都适合放在二级缓存中,看一下,什么样的数据适合放在二级缓存中来?什么样的数据不适合放在二级缓存中来?\r\n下面这几种情况就不适合加载到二级缓存中:\r\n1.经常被修改的数据\r\n2.绝对不允许出现并发访问的数据\r\n3.与其他应用共享的数据\r\n下面这己种情况合适加载到二级缓存中:\r\n1.数据更新频率低\r\n2.允许偶尔出现并发问题的非重要数据\r\n3.不会被并发访问的数据\r\n4.常量数据\r\n5.不会被第三方修改的数据\r\n\r\nHibernate的二级缓存功能是靠配置二级缓存插件来实现的,Hibernate为了集成这些插件,Hibernate提供了org.hibernate.cache.CacheProvider借口,它充当缓存插件与Hibernate之间的适配器 .\r\n\r\n常用的二级缓存插件\r\nEHCache org.hibernate.cache.EhCacheProvider\r\nOSCache org.hibernate.cache.OSCacheProvider\r\nSwarmCahe org.hibernate.cache.SwarmCacheProvider\r\nJBossCache org.hibernate.cache.TreeCacheProvider\r\n\r\n简单介绍一下EHCache的配置\r\nhibernate.cfg.xml\r\nXml代码\r\n&lt;hibernate-configuration&gt;\r\n&lt;session-factory&gt;\r\n&lt;!-- 设置二级缓存插件EHCache的Provider类--&gt;\r\n&lt;property name=\"hibernate.cache.provider_class\"&gt;\r\norg.hibernate.cache.EhCacheProvider\r\n&lt;/property&gt;\r\n&lt;!-- 启动\"查询缓存\" --&gt;\r\n&lt;property name=\"hibernate.cache.use_query_cache\"&gt;\r\ntrue\r\n&lt;/property&gt;\r\n&lt;/session-factory&gt;\r\n&lt;/hibernate-configuration&gt;\r\n\r\nehcache.xml\r\n\r\nXml代码\r\n&lt;ehcache&gt;\r\n&lt;!-- maxElementsInMemory为缓存对象的最大数目, eternal设置是否永远不过期,timeToIdleSeconds对象处于空闲状态的最多秒数,timeToLiveSeconds对象处于缓存状态的最多秒数 --&gt;\r\n&lt;diskStore path=\"java.io.tmpdir\"/&gt;\r\n&lt;defaultCache maxElementsInMemory=\"10000\" eternal=\"false\" timeToIdleSeconds=\"300\" timeToLiveSeconds=\"600\" overflowToDisk=\"true\"/&gt;\r\n&lt;/ehcache&gt;\r\n\r\n****.hbm.xml\r\n\r\nXml代码\r\n&lt;?xml version=\"1.0\" encoding=\'UTF-8\'?&gt;\r\n&lt;!DOCTYPE hibernate-mapping PUBLIC\r\n\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\r\n\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\" &gt;\r\n\r\n&lt;hibernate-mapping&gt;\r\n\r\n&lt;class&gt;\r\n&lt;!-- 设置该持久化类的二级缓存并发访问策略 read-only read-write nonstrict-read-write transactional--&gt;\r\n&lt;cache usage=\"read-write\"/&gt;\r\n&lt;/class&gt;\r\n\r\n&lt;/hibernate-mapping&gt;','Hibernate缓存机制','','publish','open','open','','hibernate%e7%bc%93%e5%ad%98%e6%9c%ba%e5%88%b6','','','2013-08-23 13:57:49','2013-08-23 05:57:49','',0,'http://localhost/wordpress-new/?p=86',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (87,1,'2013-08-23 13:57:49','2013-08-23 05:57:49','缓存是位于应用程序与物理数据源之间，用于临时存放复制数据的内存区域，目的是为了减少应用程序对物理数据源访问的次数，从而提高应用程序的运行性能.\r\nHibernate在查询数据时，首先到缓存中去查找，如果找到就直接使用，找不到的时候就会从物理数据源中检索，所以，把频繁使用的数据加载到缓存区后，就可以大大减少应用程序对物理数据源的访问，使得程序的运行性能明显的提升.\r\n\r\nHibernate缓存分类：\r\n\r\nSession缓存，一级缓存.\r\n\r\nSessionFactory的缓存分为内置缓存和外置缓存.内置缓存中存放的是SessionFactory对象的一些集合属性包含的数据(映射元素据及预定义SQL语句等),对于应用程序来说,它是只读的.外置缓存中存放的是数据库数据的副本,其作用和一级缓存类似.二级缓存除了以内存作为存储介质外,还可以选用硬盘等外部存储设备.\r\n\r\nHibernate的缓存范围\r\n\r\nHibernate的一级缓存和二级缓存都位于均位于持久层,且均用于存放数据库数据的副本,最大的区别就是缓存的范围各不一样.\r\n\r\n缓存的范围分为3类:\r\n\r\n1.事务范围\r\n事务范围的缓存只能被当前事务访问,每个事务都有各自的缓存,缓存内的数据通常采用相互关联的对象形式.缓存的生命周期依赖于事务的生命周期,只有当事务结束时,缓存的生命周期才会结束.事务范围的缓存使用内存作为存储介质,一级缓存就属于事务范围.\r\n2.应用范围\r\n应用程序的缓存可以被应用范围内的所有事务共享访问.缓存的生命周期依赖于应用的生命周期,只有当应用结束时,缓存的生命周期才会结束.应用范围的缓存可以使用内存或硬盘作为存储介质,二级缓存就属于应用范围.\r\n3.集群范围\r\n在集群环境中,缓存被一个机器或多个机器的进程共享,缓存中的数据被复制到集群环境中的每个进程节点,进程间通过远程通信来保证缓存中的数据的一致,缓存中的数据通常采用对象的松散数据形式.\r\n\r\nHibernate的缓存管理\r\n\r\n一级缓存的管理:\r\n\r\nevit(Object obj) 将指定的持久化对象从一级缓存中清除,释放对象所占用的内存资源,指定对象从持久化状态变为脱管状态,从而成为游离对象.\r\nclear() 将一级缓存中的所有持久化对象清除,释放其占用的内存资源\r\ncontains(Object obj) 判断指定的对象是否存在于一级缓存中.\r\nflush() 刷新一级缓存区的内容,使之与数据库数据保持同步.\r\n\r\n二级缓存的管理:\r\n\r\nevict(Class arg0, Serializable arg1) 将某个类的指定ID的持久化对象从二级缓存中清除,释放对象所占用的资源.\r\n\r\nJava代码\r\nsessionFactory.evict(Customer.class, new Integer(1));\r\n\r\nevict(Class arg0) 将指定类的所有持久化对象从二级缓存中清除,释放其占用的内存资源.\r\n\r\nJava代码\r\nsessionFactory.evict(Customer.class);\r\n\r\nevictCollection(String arg0) 将指定类的所有持久化对象的指定集合从二级缓存中清除,释放其占用的内存资源.\r\n\r\nJava代码\r\nsessionFactory.evictCollection(\"Customer.orders\");\r\n\r\nHibernate的二级缓存的配置\r\n\r\n首先,不是所有的数据都适合放在二级缓存中,看一下,什么样的数据适合放在二级缓存中来?什么样的数据不适合放在二级缓存中来?\r\n下面这几种情况就不适合加载到二级缓存中:\r\n1.经常被修改的数据\r\n2.绝对不允许出现并发访问的数据\r\n3.与其他应用共享的数据\r\n下面这己种情况合适加载到二级缓存中:\r\n1.数据更新频率低\r\n2.允许偶尔出现并发问题的非重要数据\r\n3.不会被并发访问的数据\r\n4.常量数据\r\n5.不会被第三方修改的数据\r\n\r\nHibernate的二级缓存功能是靠配置二级缓存插件来实现的,Hibernate为了集成这些插件,Hibernate提供了org.hibernate.cache.CacheProvider借口,它充当缓存插件与Hibernate之间的适配器 .\r\n\r\n常用的二级缓存插件\r\nEHCache org.hibernate.cache.EhCacheProvider\r\nOSCache org.hibernate.cache.OSCacheProvider\r\nSwarmCahe org.hibernate.cache.SwarmCacheProvider\r\nJBossCache org.hibernate.cache.TreeCacheProvider\r\n\r\n简单介绍一下EHCache的配置\r\nhibernate.cfg.xml\r\nXml代码\r\n&lt;hibernate-configuration&gt;\r\n&lt;session-factory&gt;\r\n&lt;!-- 设置二级缓存插件EHCache的Provider类--&gt;\r\n&lt;property name=\"hibernate.cache.provider_class\"&gt;\r\norg.hibernate.cache.EhCacheProvider\r\n&lt;/property&gt;\r\n&lt;!-- 启动\"查询缓存\" --&gt;\r\n&lt;property name=\"hibernate.cache.use_query_cache\"&gt;\r\ntrue\r\n&lt;/property&gt;\r\n&lt;/session-factory&gt;\r\n&lt;/hibernate-configuration&gt;\r\n\r\nehcache.xml\r\n\r\nXml代码\r\n&lt;ehcache&gt;\r\n&lt;!-- maxElementsInMemory为缓存对象的最大数目, eternal设置是否永远不过期,timeToIdleSeconds对象处于空闲状态的最多秒数,timeToLiveSeconds对象处于缓存状态的最多秒数 --&gt;\r\n&lt;diskStore path=\"java.io.tmpdir\"/&gt;\r\n&lt;defaultCache maxElementsInMemory=\"10000\" eternal=\"false\" timeToIdleSeconds=\"300\" timeToLiveSeconds=\"600\" overflowToDisk=\"true\"/&gt;\r\n&lt;/ehcache&gt;\r\n\r\n****.hbm.xml\r\n\r\nXml代码\r\n&lt;?xml version=\"1.0\" encoding=\'UTF-8\'?&gt;\r\n&lt;!DOCTYPE hibernate-mapping PUBLIC\r\n\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\r\n\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\" &gt;\r\n\r\n&lt;hibernate-mapping&gt;\r\n\r\n&lt;class&gt;\r\n&lt;!-- 设置该持久化类的二级缓存并发访问策略 read-only read-write nonstrict-read-write transactional--&gt;\r\n&lt;cache usage=\"read-write\"/&gt;\r\n&lt;/class&gt;\r\n\r\n&lt;/hibernate-mapping&gt;','Hibernate缓存机制','','inherit','open','open','','86-revision-v1','','','2013-08-23 13:57:49','2013-08-23 05:57:49','',86,'http://localhost/wordpress-new/?p=87',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (88,1,'2013-08-23 13:58:04','2013-08-23 05:58:04','“道德就是拿火腿肠喂流浪狗喂到心碎流泪，而完全不用去顾虑猪的感受。”这是一位网友对爱狗人士拯救流浪狗的讥讽，不少人觉得这句话绝妙，觉得它点出了爱狗人士的逻辑矛盾，进而觉得爱狗人士的做法是一种荒谬的伪善。类似这样的矛盾话题，近几年引发的争议不断，清华学生硫酸泼熊、虐兔虐猫的视频、爱狗人士的激烈抗争，以及最近发生的归真堂活熊取胆的争论，都涉及到一个话题：动物伦理。人类究竟应该怎样对待动物？\r\n\r\n火腿肠喂狗，并不荒谬\r\n\r\n谈到对一些动物的保护，首先必须面对一个逻辑上的困境：人类目前还没有实现完全素食，除了宰杀和食用动物，还存在广泛的把动物当工具的现象，比如动物实验等。这样的逻辑困境比比皆是：用火腿肠喂宠物狗，你让猪情何以堪？美国有个《动物福利法案》（Animal Welfare Act），里面对于很多动物都做了保护规定，不允许捕食。但在里面禽类、肉用动物和鼠类都被排除在外了。难道鸽子需要保护，鸡鸭就不需要？凭什么猫和狗就比老鼠高贵？一位香港人就曾这样质疑香港兽奸违法的规定：为什么我能杀死猪，但却不能和猪做爱？\r\n\r\n这样诉诸逻辑的质疑显然很有挑战性，貌似相当有理。但我在此要说的是，这其实是一种似是而非的观点，它表面合乎逻辑，但并不正确。\r\n\r\n为什么这样说呢？原因就在于，人类社会的规范系统极其复杂，本身就不是一个单靠逻辑而建立起来的系统。这个系统有两个维度：逻辑与历史。唯理主义的反思和历史传统的渐进式演进共同形成了我们今天的社会规范。在人类的规范体系中，逻辑上互相矛盾的现象几乎无处不在，比如虽然每个人都有私下处理自己身体的权利，但两个人自愿决斗早已经是非法行为，自愿卖器官也是非法；一个国家可能有一百多种大大小小的宗教，尽管法律规定所有宗教具有平等的地位，但绝不是每个宗教的节日都能像基督教的圣诞节那样全国放假一周。\r\n\r\n这样矛盾的例子几乎不胜枚举，这也决定了，我们无法用几条逻辑原则来完全概括复杂的社会规范系统。想用几条绝对原则来统摄人类社会的规范体系的做法，本身就是相当激进和幼稚的。大哲学家维特根斯坦就曾用“游戏”来阐释这一现象：无论你怎样概括游戏的概念特征，你都能找出一个游戏，不符合这一特征。在法学界，这一问题已经被充分讨论，以唯理主义作指导的欧陆法系，被很多人认为不如注重传统、靠判例演进的英美法系那样符合实质正义。\r\n\r\n我们回到动物伦理的话题，逻辑的原则固然是一种很重要的维度，但我们还必须回到历史和传统中来考察。\r\n\r\n中西方传统中的动物伦理\r\n\r\n经过漫长的历史演化和反思，人类的几个主流文明体系都对动物伦理有了成熟的看法。在几个核心观点上，中西方的主流看法都比较一致。比如都肯定人类的中心和支配地位，认为动植物可以作为人的工具而存在。但这并不意味着人可以肆意对待动物。人类如何对待动物，关乎人类的文明和尊严，关乎人类道德感的培育。\r\n\r\n我们先看西方的主流传统观点。阿奎那是基督教理论的里程碑式的人物，他对此有过专门的论述。他在“论杀死生物和热爱非理性生物的义务”中说，上帝命令动植物生命是为人而不是为它们自己而存在。但他明确反对肆意残酷对待动物，理由是对动物残酷就会对其他人残酷，善待动物无疑有利于人的道德感的培育。人对于动物存在一定的道德义务。另外，基督教的很多教派都认为人类是上帝创造的自然秩序有爱心的守卫者，自然和动物本身是善，人类有义务善待自然。\r\n\r\n康德也认为，动物是工具，人是目的。但他同时认为残酷对待动物毒害心灵，不利于道德和仁慈。他甚至指出，主人不应该抛弃长期相伴的狗，更不能吃了它，应该养它到死，这有利于我们对人的道德义务和情感。还有边沁和穆勒，虽然他们都不是素食主义者，也都不反对解剖动物，但边沁反对狩猎、钓鱼、以及引诱动物比赛，密尔则参与了英格兰皇家防止虐待动物协会。\r\n\r\n我们再来看看中国文化传统中的动物伦理。史载乾隆四十六年，山西太原有一家虐食驴肉的“驴香馆”，因为活生生取驴肉而被官府查禁，老板等一干人等被充军法办。惩戒的理由就在于这种行为破坏了中国传统的价值观。\r\n\r\n仁、恻隐之心、善端，是儒家文化的核心概念。孟子说：“君子之于禽兽也，见其生，不忍见其死。闻其声，不忍食其肉。是以君子远庖厨也。”宋明理学里，程颢就说“仁者浑然与物同体”，这里面就表达了对世间万物的仁慈恻隐之心。李渔更是反对残酷虐杀动物：“以生物多时之痛楚，易我片刻之甘甜；地狱之设，正为此人，其死后炮烙之刑，必有过于此者。”\r\n\r\n从东西方传统我们可以看到，尽可能人道地对待动物，实际上关乎人的尊严和道德感，这样一种价值倡导，是人性慈爱温暖的一种体现，并非伪善。英格兰历史上就曾规定，屠夫和医生不参加陪审团，因为他们习惯于看到死亡，心肠硬，会影响判断。还有，东西主流文明都反对兽奸，也是出于人的尊严和道德的考虑。\r\n\r\n照顾人心的感受，这同样能解释为什么对不同的动物，会有不同的标准。人类对不同的动物，感情是不一样的。你在路上踩到一只蚂蚁，与踩到猫的感受当然不会相同。我们大都可以接受炒田螺，但将一只活兔子直接放进锅里，恐怕会遭到很多人的谴责。另外，中国传统中很多地方都有厚葬耕牛的传统，这和不吃猫狗等宠物的道理一样，因为它们长期作为人类的朋友，这个关系里已经融入了人的诸多感情。\r\n\r\n人类一直在寻找最不坏的方式\r\n\r\n唯理主义者喜欢简单的二分法，不是正确就是错误，但经验主义者更强调传统的演化，认为人类文明一直都是在追寻“最不坏”的路上。\r\n\r\n释迦牟尼、柏拉图、老子都是素食主义者，他们表达了一种哲学上的对至善的追求。但在人类历史上，以及可预见的相当长的时段，人类都不可能完全做到素食。当杀戮动物不可避免，我们也可以选择最不坏的方式，而且，随着人类文明的进步，我们对待动物的文明程度也会水涨船高。\r\n\r\n近代以来，随着科学技术的进步，物资匮乏的程度得到了极大缓解，这使得人类可以放弃对一些动物的杀戮，而将利用动物的范围缩减到一个很小的范围，同时也有条件要求更文明的处理方式。\r\n\r\n1822年，人道主义者查理·马丁提出的《禁止虐待动物法令》在英国国会顺利通过。“马丁法案”是人类历史上第一部反对人类任意虐待动物的法令，是人类与动物关系史上的一个里程碑。之后，英国又三次增补该法案，将保护动物的范围延伸至“所有人类饲养的哺乳动物和部分受囚禁的野生动物”。之后，法国也于1850年通过了反虐待动物的法律，爱尔兰、德国、奥地利、比利时和荷兰等欧洲国家也相继跟随。至今，世界上已经有100多个国家制定了《禁止虐待动物法》，动物的生命价值已逐渐被法律所承认。近十年来，联合国粮食及农业组织都在积极倡导“食物伦理”（Food Ethics）。\r\n\r\n在中国，1931年的《公共租界工部局公共菜场章程》就规定：对动物“应以合乎人道之方法待遇之，无论何人应力求避免使其受非必要痛苦之举动。并采用各种方法及防备以免其受非必要之痛苦”。这一规定当年受到了很多社会知名人士的肯定。2002年，在南非举行的环境和可持续发展国际会议上，我国有41个民间组织参加，其中就有不少动物保护组织的参与。\r\n\r\n人类至今还必须依赖大量的动物实验，但人类同时也在努力将伤害降低到最低点。1959年英国学者提出动物实验的“3R”(替代、减少和优化)原则：使用没有知觉的实验材料代替活体动物，用最少的动物达到所需要的目的，优化实验程序、改进技术以最大程度地保护动物福利。英国出台了专门的《实验动物法》，对怎样使用实验动物，怎样把实验动物的痛苦减少到最低点都做出了明确的规定。\r\n\r\n所有这些，都表明了人类一直都在努力选择以“最不坏”的方式来对待动物。这是文明进步的体现。\r\n\r\n尊重传统，并不等于相对主义\r\n\r\n人类如何对待动物，是理性反思与传统演进结合的产物，动物伦理深深植根于传统。但我们也应该看到，传统并非一成不变，文明的进步使得文明的标准也会随之提高，以往符合传统的方式也可能受到挑战并得以修正。\r\n\r\n2006年，在香港禁止杀狗多年之后，有一位狗主因为宰杀和煮食自己的两只宠物狗而被判监禁30天，这是香港首宗因杀食狗肉被判监禁的个案，也显示了香港社会已经不再允许这种习俗。而众所周知，中国人在历史上一直有食用狗肉的传统。台湾的情况也类似，尽管台湾本土一直有吃狗肉进补的习惯，但这一习俗已经被抛弃，现行的《台湾动物保护法》就明确规定，宰杀犬、猫或经中央主管机关公告禁止宰杀之动物者，将会被处于巨额罚款，并得公布其姓名、名称或照片。\r\n\r\n还有，动物皮毛曾经是人类衣服的重要来源，但科技进步到今天，人类完全可以放弃动物皮毛做衣服，因此，近年来西方不少人都呼吁放弃皮毛做衣料，这一呼吁也得到了相当范围的认同。像西班牙斗牛这样以娱乐为目的而伤害动物的习俗，也受到了不少人的抵制。\r\n\r\n另外一个就是食用动物的范围的问题，自从畜牧业出现之后，人类食用的动物的种类就越来越少，特别是到了现代社会，水产、猪牛羊等少数几种养殖动物就足够满足人类的饮食需要，发达国家的人们完全不需要像非洲一些部落那样捕杀大猩猩为食了。我们看到，如今的欧美发达国家的动物食谱已经非常狭窄，很多动物都避免了被捕食的命运。\r\n\r\n日本，作为一个食谱广泛的民族，一些传统饮食习惯也被世界其他地区的人所非议。在世界越来越扁平的今天，这些习俗必然要做出调整，因为尊重传统并不等于相对主义。当然，这不是一个一蹴而就，非黑即白的问题，它只能在一个漫长的博弈和演化中找到答案。\r\n\r\n鹅肝酱，裘皮大衣、斗牛与归真堂\r\n\r\n当一些对动物的伤害逐渐可以避免时，一些传统必然要做出改变。一直中国的中医药中，有很多动物入药的需求，这也使得他们像鱼翅和燕窝一样，在近年饱受非议。最近的“归真堂活取熊胆”风波就是一个很好的例子。我们究竟该如何看待这一现象？\r\n\r\n归真堂遇到的抵制，在国际范围内早有类似例子。比如历史悠久的反裘皮大衣的运动，在欧洲各大时装展期间经常会遇到，大量的动物保护组织和明星参与其中。另外一个更接近的例子是鹅肝酱。鹅肝酱是法国的三大美食之一，虽然它并不是一个健康食品，但依然有不小的市场。鹅肝酱是用鹅的肥肝加工而成，相比正常的鹅肝而言，鹅肥肝比其大六至八倍。为了获得这样的肥肝，饲养者必须采用相当残忍的强饲法。几十年来，这样的养殖方法在欧洲受到了不少组织和个人的反对。\r\n\r\n然而，我们应该看到，不管是皮毛大衣、鹅肝酱、鱼翅、燕窝、还是西班牙斗牛，几乎被抵制了一个世纪，但是它们依然合法存在，很多法国人依然视鹅肝酱为骄傲的传统产品。一边是动物保护组织的激烈反对，一边是法国人的鹅肝酱生意照做，上市照上。这里面的原因就在于，动物伦理深植于传统之中，既然是传统的改变，则需要时间，需要整个社会认同和氛围到了一定的节点，消费市场衰落到一定的程度，才会上升到制度层面。\r\n\r\n人类现在完全可以做到不用动物皮毛做衣服、不吃鹅肝酱、不看斗牛，但我们看到，这些东西至今还有相当的市场需求，涉及到庞大的产业和大量从业人员，这也是它们在长期争议中继续存在的原因。我们可以预见，随着社会的进步，人们对于动物伦理的要求会越来越高，这些产业的市场也会越来越小，当社会共识到了很高的程度，这些产业才会退出历史舞台。\r\n\r\n这是一个长期演进的过程，归真堂遇到了一些人的抵制，而实际上，它遇到的抵制无论从程度还是时间上来讲，都远比不上鹅肝酱和裘皮大衣遭遇的强烈，只是对于中国人来讲，这似乎是一个新鲜的话题。我相信，与鹅肝酱、裘皮大衣、斗牛等一样，它们终将被历史抛弃，但是，这需要一个不短的时间，是一个生产者、消费者以及各种社会力量和文化博弈和演进的过程','动物伦理，为了人的尊严','','publish','open','open','','%e5%8a%a8%e7%89%a9%e4%bc%a6%e7%90%86%ef%bc%8c%e4%b8%ba%e4%ba%86%e4%ba%ba%e7%9a%84%e5%b0%8a%e4%b8%a5','','','2013-08-23 13:58:04','2013-08-23 05:58:04','',0,'http://localhost/wordpress-new/?p=88',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (89,1,'2013-08-23 13:58:04','2013-08-23 05:58:04','“道德就是拿火腿肠喂流浪狗喂到心碎流泪，而完全不用去顾虑猪的感受。”这是一位网友对爱狗人士拯救流浪狗的讥讽，不少人觉得这句话绝妙，觉得它点出了爱狗人士的逻辑矛盾，进而觉得爱狗人士的做法是一种荒谬的伪善。类似这样的矛盾话题，近几年引发的争议不断，清华学生硫酸泼熊、虐兔虐猫的视频、爱狗人士的激烈抗争，以及最近发生的归真堂活熊取胆的争论，都涉及到一个话题：动物伦理。人类究竟应该怎样对待动物？\r\n\r\n火腿肠喂狗，并不荒谬\r\n\r\n谈到对一些动物的保护，首先必须面对一个逻辑上的困境：人类目前还没有实现完全素食，除了宰杀和食用动物，还存在广泛的把动物当工具的现象，比如动物实验等。这样的逻辑困境比比皆是：用火腿肠喂宠物狗，你让猪情何以堪？美国有个《动物福利法案》（Animal Welfare Act），里面对于很多动物都做了保护规定，不允许捕食。但在里面禽类、肉用动物和鼠类都被排除在外了。难道鸽子需要保护，鸡鸭就不需要？凭什么猫和狗就比老鼠高贵？一位香港人就曾这样质疑香港兽奸违法的规定：为什么我能杀死猪，但却不能和猪做爱？\r\n\r\n这样诉诸逻辑的质疑显然很有挑战性，貌似相当有理。但我在此要说的是，这其实是一种似是而非的观点，它表面合乎逻辑，但并不正确。\r\n\r\n为什么这样说呢？原因就在于，人类社会的规范系统极其复杂，本身就不是一个单靠逻辑而建立起来的系统。这个系统有两个维度：逻辑与历史。唯理主义的反思和历史传统的渐进式演进共同形成了我们今天的社会规范。在人类的规范体系中，逻辑上互相矛盾的现象几乎无处不在，比如虽然每个人都有私下处理自己身体的权利，但两个人自愿决斗早已经是非法行为，自愿卖器官也是非法；一个国家可能有一百多种大大小小的宗教，尽管法律规定所有宗教具有平等的地位，但绝不是每个宗教的节日都能像基督教的圣诞节那样全国放假一周。\r\n\r\n这样矛盾的例子几乎不胜枚举，这也决定了，我们无法用几条逻辑原则来完全概括复杂的社会规范系统。想用几条绝对原则来统摄人类社会的规范体系的做法，本身就是相当激进和幼稚的。大哲学家维特根斯坦就曾用“游戏”来阐释这一现象：无论你怎样概括游戏的概念特征，你都能找出一个游戏，不符合这一特征。在法学界，这一问题已经被充分讨论，以唯理主义作指导的欧陆法系，被很多人认为不如注重传统、靠判例演进的英美法系那样符合实质正义。\r\n\r\n我们回到动物伦理的话题，逻辑的原则固然是一种很重要的维度，但我们还必须回到历史和传统中来考察。\r\n\r\n中西方传统中的动物伦理\r\n\r\n经过漫长的历史演化和反思，人类的几个主流文明体系都对动物伦理有了成熟的看法。在几个核心观点上，中西方的主流看法都比较一致。比如都肯定人类的中心和支配地位，认为动植物可以作为人的工具而存在。但这并不意味着人可以肆意对待动物。人类如何对待动物，关乎人类的文明和尊严，关乎人类道德感的培育。\r\n\r\n我们先看西方的主流传统观点。阿奎那是基督教理论的里程碑式的人物，他对此有过专门的论述。他在“论杀死生物和热爱非理性生物的义务”中说，上帝命令动植物生命是为人而不是为它们自己而存在。但他明确反对肆意残酷对待动物，理由是对动物残酷就会对其他人残酷，善待动物无疑有利于人的道德感的培育。人对于动物存在一定的道德义务。另外，基督教的很多教派都认为人类是上帝创造的自然秩序有爱心的守卫者，自然和动物本身是善，人类有义务善待自然。\r\n\r\n康德也认为，动物是工具，人是目的。但他同时认为残酷对待动物毒害心灵，不利于道德和仁慈。他甚至指出，主人不应该抛弃长期相伴的狗，更不能吃了它，应该养它到死，这有利于我们对人的道德义务和情感。还有边沁和穆勒，虽然他们都不是素食主义者，也都不反对解剖动物，但边沁反对狩猎、钓鱼、以及引诱动物比赛，密尔则参与了英格兰皇家防止虐待动物协会。\r\n\r\n我们再来看看中国文化传统中的动物伦理。史载乾隆四十六年，山西太原有一家虐食驴肉的“驴香馆”，因为活生生取驴肉而被官府查禁，老板等一干人等被充军法办。惩戒的理由就在于这种行为破坏了中国传统的价值观。\r\n\r\n仁、恻隐之心、善端，是儒家文化的核心概念。孟子说：“君子之于禽兽也，见其生，不忍见其死。闻其声，不忍食其肉。是以君子远庖厨也。”宋明理学里，程颢就说“仁者浑然与物同体”，这里面就表达了对世间万物的仁慈恻隐之心。李渔更是反对残酷虐杀动物：“以生物多时之痛楚，易我片刻之甘甜；地狱之设，正为此人，其死后炮烙之刑，必有过于此者。”\r\n\r\n从东西方传统我们可以看到，尽可能人道地对待动物，实际上关乎人的尊严和道德感，这样一种价值倡导，是人性慈爱温暖的一种体现，并非伪善。英格兰历史上就曾规定，屠夫和医生不参加陪审团，因为他们习惯于看到死亡，心肠硬，会影响判断。还有，东西主流文明都反对兽奸，也是出于人的尊严和道德的考虑。\r\n\r\n照顾人心的感受，这同样能解释为什么对不同的动物，会有不同的标准。人类对不同的动物，感情是不一样的。你在路上踩到一只蚂蚁，与踩到猫的感受当然不会相同。我们大都可以接受炒田螺，但将一只活兔子直接放进锅里，恐怕会遭到很多人的谴责。另外，中国传统中很多地方都有厚葬耕牛的传统，这和不吃猫狗等宠物的道理一样，因为它们长期作为人类的朋友，这个关系里已经融入了人的诸多感情。\r\n\r\n人类一直在寻找最不坏的方式\r\n\r\n唯理主义者喜欢简单的二分法，不是正确就是错误，但经验主义者更强调传统的演化，认为人类文明一直都是在追寻“最不坏”的路上。\r\n\r\n释迦牟尼、柏拉图、老子都是素食主义者，他们表达了一种哲学上的对至善的追求。但在人类历史上，以及可预见的相当长的时段，人类都不可能完全做到素食。当杀戮动物不可避免，我们也可以选择最不坏的方式，而且，随着人类文明的进步，我们对待动物的文明程度也会水涨船高。\r\n\r\n近代以来，随着科学技术的进步，物资匮乏的程度得到了极大缓解，这使得人类可以放弃对一些动物的杀戮，而将利用动物的范围缩减到一个很小的范围，同时也有条件要求更文明的处理方式。\r\n\r\n1822年，人道主义者查理·马丁提出的《禁止虐待动物法令》在英国国会顺利通过。“马丁法案”是人类历史上第一部反对人类任意虐待动物的法令，是人类与动物关系史上的一个里程碑。之后，英国又三次增补该法案，将保护动物的范围延伸至“所有人类饲养的哺乳动物和部分受囚禁的野生动物”。之后，法国也于1850年通过了反虐待动物的法律，爱尔兰、德国、奥地利、比利时和荷兰等欧洲国家也相继跟随。至今，世界上已经有100多个国家制定了《禁止虐待动物法》，动物的生命价值已逐渐被法律所承认。近十年来，联合国粮食及农业组织都在积极倡导“食物伦理”（Food Ethics）。\r\n\r\n在中国，1931年的《公共租界工部局公共菜场章程》就规定：对动物“应以合乎人道之方法待遇之，无论何人应力求避免使其受非必要痛苦之举动。并采用各种方法及防备以免其受非必要之痛苦”。这一规定当年受到了很多社会知名人士的肯定。2002年，在南非举行的环境和可持续发展国际会议上，我国有41个民间组织参加，其中就有不少动物保护组织的参与。\r\n\r\n人类至今还必须依赖大量的动物实验，但人类同时也在努力将伤害降低到最低点。1959年英国学者提出动物实验的“3R”(替代、减少和优化)原则：使用没有知觉的实验材料代替活体动物，用最少的动物达到所需要的目的，优化实验程序、改进技术以最大程度地保护动物福利。英国出台了专门的《实验动物法》，对怎样使用实验动物，怎样把实验动物的痛苦减少到最低点都做出了明确的规定。\r\n\r\n所有这些，都表明了人类一直都在努力选择以“最不坏”的方式来对待动物。这是文明进步的体现。\r\n\r\n尊重传统，并不等于相对主义\r\n\r\n人类如何对待动物，是理性反思与传统演进结合的产物，动物伦理深深植根于传统。但我们也应该看到，传统并非一成不变，文明的进步使得文明的标准也会随之提高，以往符合传统的方式也可能受到挑战并得以修正。\r\n\r\n2006年，在香港禁止杀狗多年之后，有一位狗主因为宰杀和煮食自己的两只宠物狗而被判监禁30天，这是香港首宗因杀食狗肉被判监禁的个案，也显示了香港社会已经不再允许这种习俗。而众所周知，中国人在历史上一直有食用狗肉的传统。台湾的情况也类似，尽管台湾本土一直有吃狗肉进补的习惯，但这一习俗已经被抛弃，现行的《台湾动物保护法》就明确规定，宰杀犬、猫或经中央主管机关公告禁止宰杀之动物者，将会被处于巨额罚款，并得公布其姓名、名称或照片。\r\n\r\n还有，动物皮毛曾经是人类衣服的重要来源，但科技进步到今天，人类完全可以放弃动物皮毛做衣服，因此，近年来西方不少人都呼吁放弃皮毛做衣料，这一呼吁也得到了相当范围的认同。像西班牙斗牛这样以娱乐为目的而伤害动物的习俗，也受到了不少人的抵制。\r\n\r\n另外一个就是食用动物的范围的问题，自从畜牧业出现之后，人类食用的动物的种类就越来越少，特别是到了现代社会，水产、猪牛羊等少数几种养殖动物就足够满足人类的饮食需要，发达国家的人们完全不需要像非洲一些部落那样捕杀大猩猩为食了。我们看到，如今的欧美发达国家的动物食谱已经非常狭窄，很多动物都避免了被捕食的命运。\r\n\r\n日本，作为一个食谱广泛的民族，一些传统饮食习惯也被世界其他地区的人所非议。在世界越来越扁平的今天，这些习俗必然要做出调整，因为尊重传统并不等于相对主义。当然，这不是一个一蹴而就，非黑即白的问题，它只能在一个漫长的博弈和演化中找到答案。\r\n\r\n鹅肝酱，裘皮大衣、斗牛与归真堂\r\n\r\n当一些对动物的伤害逐渐可以避免时，一些传统必然要做出改变。一直中国的中医药中，有很多动物入药的需求，这也使得他们像鱼翅和燕窝一样，在近年饱受非议。最近的“归真堂活取熊胆”风波就是一个很好的例子。我们究竟该如何看待这一现象？\r\n\r\n归真堂遇到的抵制，在国际范围内早有类似例子。比如历史悠久的反裘皮大衣的运动，在欧洲各大时装展期间经常会遇到，大量的动物保护组织和明星参与其中。另外一个更接近的例子是鹅肝酱。鹅肝酱是法国的三大美食之一，虽然它并不是一个健康食品，但依然有不小的市场。鹅肝酱是用鹅的肥肝加工而成，相比正常的鹅肝而言，鹅肥肝比其大六至八倍。为了获得这样的肥肝，饲养者必须采用相当残忍的强饲法。几十年来，这样的养殖方法在欧洲受到了不少组织和个人的反对。\r\n\r\n然而，我们应该看到，不管是皮毛大衣、鹅肝酱、鱼翅、燕窝、还是西班牙斗牛，几乎被抵制了一个世纪，但是它们依然合法存在，很多法国人依然视鹅肝酱为骄傲的传统产品。一边是动物保护组织的激烈反对，一边是法国人的鹅肝酱生意照做，上市照上。这里面的原因就在于，动物伦理深植于传统之中，既然是传统的改变，则需要时间，需要整个社会认同和氛围到了一定的节点，消费市场衰落到一定的程度，才会上升到制度层面。\r\n\r\n人类现在完全可以做到不用动物皮毛做衣服、不吃鹅肝酱、不看斗牛，但我们看到，这些东西至今还有相当的市场需求，涉及到庞大的产业和大量从业人员，这也是它们在长期争议中继续存在的原因。我们可以预见，随着社会的进步，人们对于动物伦理的要求会越来越高，这些产业的市场也会越来越小，当社会共识到了很高的程度，这些产业才会退出历史舞台。\r\n\r\n这是一个长期演进的过程，归真堂遇到了一些人的抵制，而实际上，它遇到的抵制无论从程度还是时间上来讲，都远比不上鹅肝酱和裘皮大衣遭遇的强烈，只是对于中国人来讲，这似乎是一个新鲜的话题。我相信，与鹅肝酱、裘皮大衣、斗牛等一样，它们终将被历史抛弃，但是，这需要一个不短的时间，是一个生产者、消费者以及各种社会力量和文化博弈和演进的过程','动物伦理，为了人的尊严','','inherit','open','open','','88-revision-v1','','','2013-08-23 13:58:04','2013-08-23 05:58:04','',88,'http://localhost/wordpress-new/?p=89',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (90,1,'2013-08-23 13:58:22','2013-08-23 05:58:22','1、头部要害及击打方法：头部是要害部位集中的地方，主要有十个要害区。\r\n（一）耳：耳廊神经离大脑较近，受到击打后可损伤脑膜中的动脉。击打的穴位是面部神经主枝至耳顶端上部。\r\n击打方法：两手成杯状；同时拍击双耳。在中国传统武术中叫“双峰贯耳”。\r\n击打后果：轻则击穿耳膜或耳内出血，重则致脑震荡或死亡。\r\n（二）太阳穴：此部位骨质脆弱。在眼角后约5厘米，向上约2。5厘米处，有一根聂页神经，向内朝颅骨方向击打，极容易制敌。\r\n击打方法：用掌外侧、拳、肘等击打，如敌倒地则用足尖。\r\n击打后果：轻则脑震荡，重则死亡。\r\n（三）眼睛：\r\n击打方法：用食指，中指猛刺敌双眼，中国传统武术称“双龙取珠”。也可挖敌双眼。\r\n击打后果：造成双目失明，失去战斗力。\r\n（四）鼻：\r\n击打方法；用掌外侧或拳头横击鼻梁。\r\n击打后果；可击碎鼻梁骨，使敌疼痛难忍。\r\n（五）上唇：此处是鼻软骨与硬骨的连接处，神经接近皮层。\r\n击打方法：用掌的小指一侧猛击或用拳戳击。\r\n击打后果：轻则剧痛，重则能使人昏迷。\r\n（六）下巴：\r\n击打方法；用掌根猛击敌下巴。因为用拳很可能损伤自己的手指关节，但如果拳头硬度不错，用拳头击打，往往一招就令敌腾空而倒。\r\n击打后果：剧痛或脱位。\r\n（七）喉结：喉结处有气管，颈动脉还有迷走神经。\r\n击打方法：用八字拳术或用掌外侧硬击，也可用手指抓捏。\r\n击打后果：轻则疼痛难忍，重则昏迷或死亡。\r\n（八）咽喉：\r\n击打方法：用手指猛戳咽喉下部的凹处。\r\n击打后果：可使敌感到剧痛，窒息。\r\n（九）颈外侧：\r\n击打方法：用掌外侧猛砍。\r\n击打后果：昏迷。\r\n（十）颈后部：\r\n击打方法：用掌或拳的小指一侧劈砸。\r\n击打后果：可致敌死亡。\r\n2、躯干要害部位及击打方法：躯干中有锁骨、腋窝、腹、裆、脊椎及心、肺、脾、胃、肾等要害部位。\r\n（一）锁骨：肩部有“肩井穴”，用掌外侧砍劈后，伤及“云门”“中府”两穴，直接击打锁骨，也可收到良好的效果。\r\n击打方法：用掌外侧向下猛砍。\r\n击打后果；可打断锁骨，使其瘫倒。\r\n（二）腋窝：格斗时，很少有人想到击打这个部位。其实腋窝下有一条粗大的神经，很不经打。\r\n击打方法：敌倒地后，用脚尖猛踢。\r\n击打后果：剧痛或短暂的局部瘫痪。\r\n（三）心窝；\r\n击打方法：用尖拳猛戳，不宜用手掌或拳头。\r\n击打后果；剧痛难忍，昏迷。\r\n（四）腹部：腹部包括腹腔剑突以下肚脐以上的部位，肝、脾、肾、胃重要器官密布其中。\r\n击打方法；拳打，膝顶，肘击，脚踢。穿透力最理想是拳指关节猛击。\r\n击打后果；致伤，死亡。\r\n（五）裆部：人体神经末梢最丰富，敏感的地方。\r\n击打方法；膝顶，脚踢，手抓。\r\n击打后果：剧痛，甚至死亡。\r\n（六）肾部：\r\n击打方法：用掌外侧砍，拳打，脚踢等。\r\n击打后果；肾部致伤。\r\n（七）肋部：最理想是击打右肋部，因肝脏位于右肋下部，此处骨头也最细脆，容易折断。折断的肋骨很容易刺破内脏。\r\n击打方法：掌砍，脚尖踢，膝顶等。\r\n击打后果：肝脏严重损伤，重则死亡。\r\n（八）脊椎：它是人体支柱，受到击打，极易脱位。\r\n击打方法：敌倒地后，用膝，肘，脚顶，撞，踩，部位是皮带上方7—9厘米处。\r\n击打后果：瘫痪，死亡。\r\n3、四肢要害及击打方法；四肢骨共有100多块。施以正确的击打方法导致脱臼、骨折或韧带撕裂。在施用擒拿术时，对四肢关节是不能不高度重视的。\r\n（一）指关节：都是单轴关节，活动范围较小，只能伸屈，伸直时，往后或往两侧猛折会造成脱臼或骨折。\r\n击打方法；用手猛折。\r\n击打后果：骨折，脱臼。\r\n（二）腕关节：腕关节有8块腕骨，骨小易碎。\r\n击打方法：施用擒拿术时，用掌外侧扣压。\r\n击打后果：脱臼、骨折、剧痛难熬。\r\n（三）肘关节：它由桡骨，尺骨和肱骨连接而成，完全伸直后，最怕从后施加\r\n=============================================================\r\n此文说得都快把人体范围囊括完了，其实简单的说，不外乎就是几个地方。\r\n\r\n下巴两侧的三叉神经网，被重击之后会导致暂时性的平衡障碍，站都不太站得稳。\r\n腋下，腋下拥有最丰富的神经网，用指头稍微按一下都会刺痛一两分钟，如果是没受过训练的人，一拳就可以让整条手臂使不上力。\r\n后腰，这里是肾脏，剧烈的打击会导致肾破裂，而且不需要什么技术含量，不过不建议打这个位置。\r\n膝盖，膝盖上的月牙形软骨是最脆弱的，只需要脚尖一脚，就可以疼得站不稳，膝盖两侧也是很脆弱的部位。','人体要害部位打击法(特警专用)','','publish','open','open','','%e4%ba%ba%e4%bd%93%e8%a6%81%e5%ae%b3%e9%83%a8%e4%bd%8d%e6%89%93%e5%87%bb%e6%b3%95%e7%89%b9%e8%ad%a6%e4%b8%93%e7%94%a8','','','2013-08-23 13:58:22','2013-08-23 05:58:22','',0,'http://localhost/wordpress-new/?p=90',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (91,1,'2013-08-23 13:58:22','2013-08-23 05:58:22','1、头部要害及击打方法：头部是要害部位集中的地方，主要有十个要害区。\r\n（一）耳：耳廊神经离大脑较近，受到击打后可损伤脑膜中的动脉。击打的穴位是面部神经主枝至耳顶端上部。\r\n击打方法：两手成杯状；同时拍击双耳。在中国传统武术中叫“双峰贯耳”。\r\n击打后果：轻则击穿耳膜或耳内出血，重则致脑震荡或死亡。\r\n（二）太阳穴：此部位骨质脆弱。在眼角后约5厘米，向上约2。5厘米处，有一根聂页神经，向内朝颅骨方向击打，极容易制敌。\r\n击打方法：用掌外侧、拳、肘等击打，如敌倒地则用足尖。\r\n击打后果：轻则脑震荡，重则死亡。\r\n（三）眼睛：\r\n击打方法：用食指，中指猛刺敌双眼，中国传统武术称“双龙取珠”。也可挖敌双眼。\r\n击打后果：造成双目失明，失去战斗力。\r\n（四）鼻：\r\n击打方法；用掌外侧或拳头横击鼻梁。\r\n击打后果；可击碎鼻梁骨，使敌疼痛难忍。\r\n（五）上唇：此处是鼻软骨与硬骨的连接处，神经接近皮层。\r\n击打方法：用掌的小指一侧猛击或用拳戳击。\r\n击打后果：轻则剧痛，重则能使人昏迷。\r\n（六）下巴：\r\n击打方法；用掌根猛击敌下巴。因为用拳很可能损伤自己的手指关节，但如果拳头硬度不错，用拳头击打，往往一招就令敌腾空而倒。\r\n击打后果：剧痛或脱位。\r\n（七）喉结：喉结处有气管，颈动脉还有迷走神经。\r\n击打方法：用八字拳术或用掌外侧硬击，也可用手指抓捏。\r\n击打后果：轻则疼痛难忍，重则昏迷或死亡。\r\n（八）咽喉：\r\n击打方法：用手指猛戳咽喉下部的凹处。\r\n击打后果：可使敌感到剧痛，窒息。\r\n（九）颈外侧：\r\n击打方法：用掌外侧猛砍。\r\n击打后果：昏迷。\r\n（十）颈后部：\r\n击打方法：用掌或拳的小指一侧劈砸。\r\n击打后果：可致敌死亡。\r\n2、躯干要害部位及击打方法：躯干中有锁骨、腋窝、腹、裆、脊椎及心、肺、脾、胃、肾等要害部位。\r\n（一）锁骨：肩部有“肩井穴”，用掌外侧砍劈后，伤及“云门”“中府”两穴，直接击打锁骨，也可收到良好的效果。\r\n击打方法：用掌外侧向下猛砍。\r\n击打后果；可打断锁骨，使其瘫倒。\r\n（二）腋窝：格斗时，很少有人想到击打这个部位。其实腋窝下有一条粗大的神经，很不经打。\r\n击打方法：敌倒地后，用脚尖猛踢。\r\n击打后果：剧痛或短暂的局部瘫痪。\r\n（三）心窝；\r\n击打方法：用尖拳猛戳，不宜用手掌或拳头。\r\n击打后果；剧痛难忍，昏迷。\r\n（四）腹部：腹部包括腹腔剑突以下肚脐以上的部位，肝、脾、肾、胃重要器官密布其中。\r\n击打方法；拳打，膝顶，肘击，脚踢。穿透力最理想是拳指关节猛击。\r\n击打后果；致伤，死亡。\r\n（五）裆部：人体神经末梢最丰富，敏感的地方。\r\n击打方法；膝顶，脚踢，手抓。\r\n击打后果：剧痛，甚至死亡。\r\n（六）肾部：\r\n击打方法：用掌外侧砍，拳打，脚踢等。\r\n击打后果；肾部致伤。\r\n（七）肋部：最理想是击打右肋部，因肝脏位于右肋下部，此处骨头也最细脆，容易折断。折断的肋骨很容易刺破内脏。\r\n击打方法：掌砍，脚尖踢，膝顶等。\r\n击打后果：肝脏严重损伤，重则死亡。\r\n（八）脊椎：它是人体支柱，受到击打，极易脱位。\r\n击打方法：敌倒地后，用膝，肘，脚顶，撞，踩，部位是皮带上方7—9厘米处。\r\n击打后果：瘫痪，死亡。\r\n3、四肢要害及击打方法；四肢骨共有100多块。施以正确的击打方法导致脱臼、骨折或韧带撕裂。在施用擒拿术时，对四肢关节是不能不高度重视的。\r\n（一）指关节：都是单轴关节，活动范围较小，只能伸屈，伸直时，往后或往两侧猛折会造成脱臼或骨折。\r\n击打方法；用手猛折。\r\n击打后果：骨折，脱臼。\r\n（二）腕关节：腕关节有8块腕骨，骨小易碎。\r\n击打方法：施用擒拿术时，用掌外侧扣压。\r\n击打后果：脱臼、骨折、剧痛难熬。\r\n（三）肘关节：它由桡骨，尺骨和肱骨连接而成，完全伸直后，最怕从后施加\r\n=============================================================\r\n此文说得都快把人体范围囊括完了，其实简单的说，不外乎就是几个地方。\r\n\r\n下巴两侧的三叉神经网，被重击之后会导致暂时性的平衡障碍，站都不太站得稳。\r\n腋下，腋下拥有最丰富的神经网，用指头稍微按一下都会刺痛一两分钟，如果是没受过训练的人，一拳就可以让整条手臂使不上力。\r\n后腰，这里是肾脏，剧烈的打击会导致肾破裂，而且不需要什么技术含量，不过不建议打这个位置。\r\n膝盖，膝盖上的月牙形软骨是最脆弱的，只需要脚尖一脚，就可以疼得站不稳，膝盖两侧也是很脆弱的部位。','人体要害部位打击法(特警专用)','','inherit','open','open','','90-revision-v1','','','2013-08-23 13:58:22','2013-08-23 05:58:22','',90,'http://localhost/wordpress-new/?p=91',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (92,1,'2013-08-23 13:58:40','2013-08-23 05:58:40','1、 乌托邦：\r\n\r\n源出希腊文ou（无）和topos（处所），意即“乌有之乡”。1516年，英国空想社会主义者莫尔在其《乌托邦》一书中，描述了一个他所憧憬的美好社会，即乌托邦。那里一切生产资料均归全民所有，生活用品则按需分配；人人都从事生产劳动，并有充足的时间供科学研究和娱乐；那里没有酒店妓院，也没有堕落和罪恶……。故此词喻指根本无法实现的理想或空想的美好社会。\r\n\r\n2. 柏拉图式恋爱：\r\n\r\n柏拉图是古希腊著名的唯心主义哲学家，苏格拉底的弟子，亚里士多德的老师。他在对话体著作《会饮篇》中，阐述了自己对爱情的看法：爱神是人与神之间的中介，他用神秘的激情控制着世界，使人以一种不可遏止的欲望去追求永恒的美。这个追求是一个逐渐上升的认识过程。爱的最低级的形式是热恋中的情人“专注于对方美的形体”，渴望与对方肉体的结合，爱的较高形式则是从沉湎于美的形体升华到爱恋形体所表现出来的美，爱的最高形式是沉思的美，即不带感性形体的美。他由此提出了将真、善、美合为最高理想的看法。后来，人们把男女之间那种与性无涉的、理想化的相互爱慕情谊，称为柏拉图式恋爱，现代语也叫精神恋爱。\r\n\r\n3.犹大的亲吻：\r\n\r\n犹大是《圣经》中耶稣基督的亲信子弟12门徒之一。耶稣传布新道虽然受到了百姓的拥护，却引起犹太教长老司祭们的仇恨。他们用30个银币收买了犹大，要他帮助辨认出耶稣。他们到客马尼园抓耶稣时，犹大假装请安，拥抱和亲吻耶稣。耶稣随即被捕，后被钉死在十字架上。人们用犹大的亲吻比喻可耻的叛卖行为\r\n\r\n4.海妖之歌：\r\n\r\n出自希腊神话。传说在一个岛上住着一些以美妙歌声迷人害人的海妖，名叫塞壬。后奥德赛路经该岛，事先得到瑟西女仙的警告，用蜡封住同伴们的耳朵，又把自己绑在桅杆上，同伴们奋力划桨，终于战胜了迷人的歌声。比喻那种骗人的甜言蜜语。\r\n\r\n5.苹果之争：出自希腊神话。密尔弥多涅斯人的国王珀琉斯和女神西蒂斯邀请众神参加婚礼，惟独忘了争吵之神厄里斯。厄里斯寻衅将一个金苹果扔在宴席中，说是要送给最美丽的女神。天后赫拉、智慧女神雅典娜和爱神阿芙罗狄蒂都争相要这个金苹果，最后苹果判给了阿芙罗狄蒂。并由此引发了特洛伊战争。比喻祸端。或指挑动是非、播弄不合。\r\n\r\n6.阿基里斯之踵：\r\n\r\n希腊神话英雄阿基里斯唯一能被刺伤的地方。他出生后，母亲海洋女神西蒂斯握着他的脚跟在冥河里浸泡，因此他全身除脚踵外其他地方刀枪不入。比喻易受伤害的地方或致命弱点。\r\n\r\n7.忘忧果：\r\n\r\n出自荷马史诗《奥德赛》。奥德赛的船队返乡途中，船被风雨吹到一处海边。同伴们吃了当地特产忘忧果之后，竟然忘记家乡和亲人，忘记自己上岸的目的，也忘记回船上去。后比喻身居异乡，乐不思归。\r\n\r\n8.月桂：\r\n\r\n出自希腊神话。阿波罗爱上了女妖达乎涅，但达乎涅拒绝了他的追求。有一次阿波罗遇见达乎涅，达乎涅立即跑到河边，向他父亲河神呼救，她父亲便将她变成了一棵月桂树。阿波罗抚摩着月桂说：“你既然不能做我的妻子，你至少也得做我的树。月桂树啊，我的头发上、竖琴上、箭囊上要永远缠着你的树枝，我要让罗马大将在凯旋的欢呼中头上戴着你的花冠，你的枝叶永远接受光荣吧。”后来人们遂用月桂树枝编成的花冠赠给优秀的诗人。月桂、桂冠也被用来做胜利和光荣的象征。\r\n\r\n9. 洗礼：\r\n\r\n出自《圣经》。人类的始祖亚当和夏娃因听了神蛇的话偷吃禁果犯下了罪，这个罪过从此代代相传，叫做“原罪”；各人违背上帝旨意也会犯罪，称为“本罪”。所以，凡笃信上帝的人，必须经过洗礼，洗刷原罪和本罪。洗礼时，主洗者口诵经文，受洗者注水额上或头上，也有全身浸入水中的，故洗礼也称“浸洗”。后比喻经受某种锻炼或考验。\r\n\r\n10.卡夫卡式的变形：\r\n\r\n卡夫卡是奥地利作家，他写过一部小说《变形记》。书中主人公格里高尔。萨姆沙是一家公司的推销员。他忠于职守，循规蹈矩，成年累月为推销商品劳碌奔波。一天早晨醒来，他突然发现自己变成了一只“大甲虫”，内心十分恐惧和痛苦，父母对他的变化十分悲伤，妹妹开始同情他。他逐渐失去了人的习性，“虫性”不断加重，他失去了工作，父亲恨他不死，母亲、妹妹也由哀怜转而生厌，邻居耻与为邻。他最后在孤独中死去。此语比喻一个人突遭不幸，成了别人的累赘时，他与周围人的关系也会变化，这种变化撕掉了人与人之间温情脉脉的面纱，暴露出赤裸裸的利害关系。\r\n\r\n11.跨掉的一代：\r\n\r\n原系20世纪五六十年代流行于美国的一种文学流派。该派均为青年作家，他们以虚无主义态度否定一切，要求摆脱一切传统束缚，拒绝承当任何社会和家庭义务，追求所谓“绝对自由”的生活：吸毒、酗酒、偷窃、同性恋等。在艺术上则主张抛弃传统手法，提倡随意发挥。其作品形式上大多支离破碎，内容上消极颓废，但在一定程度上反映了对美国社会的反叛。后指对现实不满而又无所作为、甚至沾有恶习的颓废青年人。\r\n\r\n12.华尔街的“民意”：\r\n\r\n华尔街是美国纽约的一条街。17世纪时，这里就是贸易中心和贩卖黑奴的市场，二战后，这里成了美国重要的金融中心。华尔街便是美国垄断资本的代名词，华尔街的“民意”即指美国垄断资本家的意愿。\r\n\r\n13.A字第一号：\r\n\r\nA是英语的第一个字母，因而常用来表示“第一”的意思。最早出现在英国著名的劳埃德海运保险社的船只登记簿上。凡属最好的船只，都用“A1”在登记簿上作登记；而已沉没的船只则登记在一个黑色封皮的簿子上。后来，人们就把最好的或一流水平的称为“A字第一号”，而把记载不祥消息或为进行某种迫害而开列的名单叫做“黑名单”。\r\n\r\n14.欧•亨利手法：\r\n\r\n欧•亨利是美国20世纪初短篇小说家。他主要写幽默小说，其作品常以“含泪的微笑”抚慰那些小人物在残酷的社会现实的打击的心灵创伤。他善用夸张、嘲讽、双关语等，并尤擅于安排故事结尾，笔锋一转，让主人公命运发生一百八十度的变化，使读者瞠目结舌，却又深信不疑。后泛指这种在结尾处峰回路转、柳暗化明的突变手法。\r\n\r\n15.蒙娜丽莎的微笑：\r\n\r\n《蒙娜丽莎》是意大利达•芬奇的作品。完成于1506年，画中的蒙娜丽莎相传原是佛罗伦萨有名的美女，她性情矜持，郁郁寡欢。为了使蒙娜丽莎发自心扉的微笑，达•芬奇请乐队演奏美人家乡的作品，才使他嫣然一笑。而这一微笑的含义就成为几百年艺术史上的不解之迷。常比喻青年女子迷人的微笑，或转义为神秘的微笑。\r\n\r\n16.极乐世界：\r\n\r\n原为印度佛教名词。又译“安乐国”、“安养国”、“佛国”、“净国”、“净土”等，俗称“西天”。极乐世界是“无有众苦，但受诸乐”的地界。比喻最快乐的地方或虚无飘渺的地方。\r\n\r\n17.护城神像：\r\n\r\n古希腊作为城市保卫者的武装神祗的雕像。当时的人认为，只要护城神像还在，敌人就攻不破。被雕成的神像主要有太阳神阿波罗、爱与美之神阿芙罗狄蒂和智慧女神雅典娜。后转义为有力的保障和支柱。\r\n\r\n18.骑士精神：\r\n\r\n骑士原是中世纪时欧洲封建贵族中等级最低、人数最多的一个阶层。他们通过服骑兵兵役获得国王或大领主的采邑。因当时欧洲各国封建割据，领主们为保存并扩张势力，就得依靠骑射搏击的武功。因此无论国君还是爵爷，实际上都是骑士，这使得骑士的地位大大提高了。由于当时社会崇尚武艺，因而骑士很受人仰慕。骑士周身披着钢甲，头上戴着有蒙面罩的兜帽，腰间插着十字柄的直剑，手执长矛和盾牌，骑膘悍的高头大马，威风凛凛。他们经常比武打斗，与上流社会的妇女谈情说爱。成为当时文学创作的重要题材，出现了历久不衰的“骑士传奇文学”。后来，欧洲人常把崇尚武艺、扶弱抑强、尊重女性、忠贞爱情、捍卫荣誉的品质称为“骑士精神”。另，18世纪意大利有些贵族青年效仿中世纪骑士的做法，甘愿为一些名门贵妇服役，人们嘲讽的称这些贵族青年为“侍从骑士”。由此，此语成了为贵妇人效劳并向她们献殷勤的青年男子同义语。\r\n\r\n19.禁果：\r\n\r\n《旧约•创世纪》：亚当和夏娃住在伊甸园中，上帝允许他们食用园中的果子，惟有一棵“知善恶树”上的果子禁止吃。但狡猾的蛇引诱他们吃了禁果。结果心明眼亮，知善恶，辨真假，羞耻之情油然而生，被上帝逐出伊甸园。蛇也受到惩罚：终生用肉躯爬行。比喻因被禁止而更想得到的东西。\r\n\r\n20. 涅槃：\r\n\r\n旧译“泥洹”，意译“灭度”。或称“般涅槃”，意译“入灭”、“圆寂”。佛教全部修习所要达到的最高理想。一般指通过修持断灭“生死”轮回而后获得的一种精神境界。佛教认为，信佛的人，经过长期“修道”，即能“寂（熄）灭”一切烦恼和“圆满”一切“清净功德”。这种境界，名为“涅槃”。在佛教史籍中，通常也作为死亡的代称。后来，人们在写文章时就把“涅槃”作为“死亡”的代称来使用。\r\n\r\n21.沙龙：\r\n\r\n“沙龙”是法语的译音，它原为意大利语，17世纪传入法国，最初为卢浮宫画廊的名称。后来指法国上层人物住宅中的豪华会客厅。当时，巴黎的名人（多半是名媛贵妇）常把客厅变成著名的社会交际场所。进出这里的人，多为小说家、诗人、画家、戏剧家、哲学家、音乐家和评论家等，他们志趣相同，欢聚一堂，或作诗绘画，或欣赏典雅的音乐，或就各种感兴趣的问题促膝长谈，无拘无束，各抒高见。后来，人们就把这种形式的聚会称为“沙龙”。正宗的“沙龙”有以下特点：要定期举行；时间要在晚上；人数不能太多。现在，人们在写文章时就常借“沙龙”一词来表述某项活动，如“文学沙龙”、“音乐沙龙”等。\r\n\r\n22.圆桌会议：\r\n\r\n出自英国古代英雄亚瑟王和他的圆桌骑士的传说。圆桌无首席末席之分，象征围桌而坐的骑士处于平等的地位。在圆桌旁举行的会议称为“圆桌会议”。表示参加谈判的各方一律平等。1.敲吧，门终究会开的：《新约•路加福音》：耶酥曾对门徒说：“你们祈求，就给你们：寻找，就寻得见；叩门，就给你们开门。因为凡祈求的就得着，寻找的就寻见。”意即只要孜孜以求，定能如愿以偿。\r\n\r\n23.种风者收获风暴：《旧约•何西阿书》：以色列先知何西阿看到国内的民众崇拜牛犊，而放弃了对上帝耶和华的信念，就指责他们，说他们必将自食其果。他们所种的是风，所收获的将是风暴。比喻作恶者必将自食其果。\r\n\r\n24.骨中之骨，肉中之肉：\r\n\r\n出自《圣经》。上帝在亚当身上取下一根肋骨造了女人夏娃，并让两人结为夫妻。亚当说：“这是我的骨中之骨，肉中之肉，可以称她为妻，因为她是从夫身上取下来的。因此男人要和妻结合，夫妻成为一体。”后喻指骨肉相连的关系，也比喻耗费了自己很多心血和精力所获得的成果和最心爱的东西。\r\n\r\n25.尘土之身：\r\n\r\n出自《圣经》。亚当、夏娃偷吃了知善恶树的果子，触怒了上帝，被赶出伊甸园。上帝诅咒：人必须遭受土地的折磨。人要从田里收获果实充饥，而田里将长满荆棘和蒺藜，人必须终身劳作，地里才会长出庄稼养活人类，直到归了土；人从泥土而来，本是尘土，死后仍归于尘土。故后常称人为尘土之身。\r\n\r\n26.认识自己：\r\n\r\n出自希腊神话。奥维德的《爱经》里有这样的话：“阿波罗说：”快把你的弟子领到我的殿里来罢，他们可以在那儿念那全世界闻名的铭文：凡人，认识你自己。‘“古希腊人认为”认识自己“才能富于智慧，得福免祸。\r\n\r\n27.喝了忘川的水：\r\n\r\n忘川是希腊神话中阴间的一条河流。人死后亡灵堕入阴间，只要喝了这河里的水，就会忘记过去的一切，故称为忘川。比喻遗忘了不该遗忘的事情。\r\n\r\n28.家可爱，家最好：\r\n\r\n出自《伊索寓言》。宙斯结婚，邀请动物都来参加。惟独乌龟未来。宙斯问他为何不来赴宴。乌龟说：“家可爱，家最好。”宙斯很生气，就罚他驮着自己的家行走。指许多人宁愿在家简朴度日，也不愿做客过豪华的生活。\r\n\r\n29.进来的人们，把一切希望抛弃吧：\r\n\r\n出自意大利诗人但丁《神曲。地狱篇》。诗人描绘了地狱门口的凄惨情景。地狱的门上写着：“你们走进这里的，把一切希望抛在后面吧！”后比喻绝望无助的境地。\r\n\r\n30.吃不到的葡萄总是酸的：\r\n\r\n出自《克雷洛夫寓言》。狐狸看到了成熟的葡萄，眼睛和牙齿都发亮了，可惜吃不到，只好愤愤地说：“算了，虽然看上去挺好的，实际上都没有成熟！没有一颗不是酸的。”讽刺某人得不到某种好东西，就反过来说这东西不好，以求心理平衡。\r\n\r\n31.回到破旧的木盆旁边：\r\n\r\n出自普希金的童话诗《渔夫和金鱼的故事》。渔夫网到一条会说话的金鱼，他把金鱼放回大海，金鱼许下有求必应的诺言。渔夫的老婆便逼迫丈夫不断向金鱼索取，直至要金鱼做自己的侍从，金鱼忍无可忍，终于收回给予老太婆的一切东西，是她又回到原来的破木盆旁边。意义与“竹篮打水一场空”相似。\r\n\r\n32.哪里好，哪里就是祖国：\r\n\r\n出自古希腊作家阿里斯托芬的喜剧《财神》。比喻唯利是图、甚至不惜背弃祖国者。也形容毫无原则的人。\r\n\r\n33.武装到牙齿：\r\n\r\n从前，南美沿海地区，特别是北海岸地区海盗横行。这些海盗凶狠异常，除了两手持武器外，嘴上还咬着一把刀。由此有了这个典故。后形容全副武装的人或武装到极限的国家。\r\n\r\n34.顺着葡萄藤来的消息：\r\n\r\n1844年5月24日，美国的塞缪尔。莫尔斯发明了电报，许多公司开始架设电线，但限于科学水平，电线总是拉得弯弯曲曲，有人开玩笑说像葡萄藤于是产生该语。比喻小道消息，引申为从各种非正规途径传出的秘密消息。\r\n\r\n35.约伯：\r\n\r\n《旧约•约伯记》：约伯是一个敬畏上帝的富人。魔鬼撒旦不相信他对上帝的虔诚，便怂恿上帝允许他考验约伯，上帝默许后，他多次降祸于约伯。面对灾难，约伯伏地跪拜上帝，说：“我赤身而来，当赤身而去；上帝的赐予，当由上帝取回，上帝英名永存。”于是，上帝使他从苦境中转回，并赐给他加倍的恩惠。后用他的名字喻指最有忍耐力的人。约伯的妻子因不堪苦难，曾劝说约伯放弃信仰。后世便以“约伯的妻子”比喻目光短浅的愚顽的妇人。\r\n\r\n36. 缪斯：\r\n\r\n“缪斯”是希腊神话中的九位文艺和科学女神的通称。她们均为主神和记忆女神之女，都在奥林匹斯山的庇厄里亚出生和居住。她们以音乐和诗歌之神阿波罗为首领，分别掌管着历史、悲剧、喜剧、抒情诗、舞蹈、史诗、爱情诗、颂歌和天文。因为她们常去的帕耳那索斯山下有卡斯他利阿神泉，所以古希腊的诗人、歌手都向缪斯呼告，祈求灵感。后来，人们在写文章时就常用“缪斯”来比喻文学、写作和灵感等。\r\n\r\n37.皮格马利翁：\r\n\r\n皮格马利翁是希腊神话中的塞浦路斯国王。他憎恨女性，决定永不结婚。他用神奇的技艺雕刻了一座美丽的象牙女像，并爱上了她。他像对待自己的妻子那样抚爱她，装扮她，并向神乞求让她成为自己的妻子。爱神阿芙洛狄忒被他打动，赐予雕像生命，并让他们结为夫妻。皮格马利翁效应：后来被用在教育心理学上，也称期待效应罗森塔尔效应：比喻教师对学生的期待不同，对他们施加的方法不同，学生受到的影响也不一样。\r\n\r\n38.俄底浦斯：\r\n\r\n希腊神话中英雄忒拜王拉伊俄斯和王后伊俄斯特的儿子。神谕说：“国王的儿子将要杀父娶母。”所以孩子一出生就被扔到山上，但被救活，并长大了。一次，他失手打死一个老人，这正是他的生父。后来，他来到忒拜，为当地人除去人面狮身怪兽，被拥戴为忒拜王，并娶了前王的妻子——正是他的生母。注定的命运还是实现了。母亲悲愤自杀，他也弄瞎了双眼，最后死在雅典附近复仇女神的圣林里。\r\n\r\n39.安泰：\r\n\r\n“安泰”是希腊神话中的巨人和英雄，是海神波塞冬和地神盖娅的儿子。他的力量来源于大地母亲，只要身不离地，就力量无穷，所向无敌；但如果身体离开了大地母亲，就要失去生存能力。后来，安泰被希腊神话中最伟大的英雄赫拉克勒斯举在空中击毙了。因为安泰是个离开大地母亲就失去力量的巨人，所以，后来人们在写文章时就常用“安泰”来比喻作家、诗人以及革命政党不能脱离人民群众。\r\n\r\n40.西西弗斯：\r\n\r\n西西弗受到众神的惩罚，众神让他永不停息地推着一块沉重的巨石上山。当西西弗斯将巨石推至山顶时，石头便会不可阻挡地滚下山去。西西弗斯便这样周而复始地推石头上山。41.美狄亚：希腊神话中科尔喀斯国王的女儿，她帮助伊阿宋取得了金羊毛。当她跟随伊阿宋从亚尔古船上逃走时，看见父亲追来，她便把兄弟的身体砍成碎块，抛入海中。她父亲忙于收尸，没有追上他们。几年后，伊阿宋变了心，娶了新妻。她叫儿子将一件遍染磷火性毒药的新衣送给伊阿宋的新妻，新妻着衣，即被烧死。美狄亚亲手杀死了自己两个孩子，带着他们的尸体到了雅典。雅典国王给了她一个避难所。喻指阴险、毒辣的女人。\r\n\r\n42.堂•吉珂德：\r\n\r\n西班牙作家同名小说的主人公。他是一个上了年纪、瘦弱可笑的乡村小贵族，因看骑士小说入迷，便也想做个骑士，干一番惊天动地的事业。结果做出一系列荒唐的事情。比喻那些脱离实际，耽于幻想，因而做出错误判断、一味蛮干，荒唐可笑的人。这种人的做法成为“堂。吉珂德式的行为”。\r\n\r\n43.当代阿巴贡：\r\n\r\n阿巴贡是莫里哀喜剧《吝啬鬼》（又名《悭吝人》）中的主人公。他生性多疑，视钱如命，就连赠你一个早安也舍不得说，而说借你一个早安。阿巴贡是世界文学中一个著名的典型形象，与葛朗台（巴尔扎克《欧也妮。葛朗台》）、夏洛克（莎士比亚《威尼斯商人》）、乞乞科夫（果戈里《死魂灵》）三个形象合称“四大吝啬鬼”。\r\n\r\n44.哈姆雷特的悲剧：\r\n\r\n哈姆雷特是莎士比亚同名悲剧中的主人公。他父王被其弟弟毒死。为了复仇，他以装疯为掩护。但由于过于审慎，一再延宕，最后落得玉石俱焚的结局。比喻遇事犹豫不决、疑虑重重、迟迟不采取行动而坐失良机、一事无成的人。\r\n\r\n45.豌豆公主：\r\n\r\n出自丹麦安徒生的同名童话。一个公主能觉出在20层垫子和20层鸭绒被下放的一粒豌豆。讽刺那些娇嫩无比，弱不禁风的小姐。\r\n\r\n46.滑铁卢的拿破仑：\r\n\r\n1815年拿破仑亲率12万大军同反法联军在比利时南部的滑铁卢作战，惨败。拿破仑被囚禁在大西洋中的圣赫勒拿岛上。直到1821年病故。正因为滑铁卢战役的失败，拿破仑从此一蹶不振，因此此语比喻英雄末路。\r\n\r\n47.浮士德式的人物：\r\n\r\n浮士德原指15、16世纪德国的炼金术士。传说中的浮士德学识渊博、精通魔法，努力探索。德国诗人歌德创作了长诗剧《浮士德》。在诗人笔下，浮士德战胜了魔鬼摩非斯特的千方百计的引诱，克服挫折，奋斗不止，直到生命最后一刻他仍然渴望争取自由和生存。比喻学识渊博、精通魔法、有奇特本领及永不满足的追求者。\r\n\r\n48.苦行僧：\r\n\r\n原是印度一些宗教中以“苦行”为修行手段的僧人。“苦行”一词，梵文原义为“热”，因为印度气候炎热，宗教徒便把受热作为苦行的主要手段。比喻为实践。\r\n\r\n49.酸小姐：\r\n\r\n出自俄国作家波米亚洛夫斯基的小说《小市民的幸福》。女主人公莲诺奇卡是一个目光短浅，精神空虚的“千金小姐”。由于失恋而成为忧心忡忡，痛苦悲伤的“酸小姐”。后比喻矫揉造作、装腔作势的女子。也泛指目光短浅、思想庸俗或感情脆弱、喜怒无常的人。\r\n\r\n50.套中人：\r\n\r\n出自俄国作家契珂夫的同名小说。小官吏别里科夫性格怪僻，他晴天出门也要穿雨鞋、棉大衣，带雨伞。他害怕变革，凡有新生事物出现，他总是摇头晃脑说：“不要弄出什么事情来。”他犹如生活在套子里，隔绝人世。因此，此语成为墨守成规、因循守旧的同义语。表示害怕一切新鲜事物、害怕变革的人。\r\n\r\n51.超人：\r\n\r\n出自尼采《查拉图什特拉如是说》。尼采认为“超人”是代表统治阶层的理想化的无所不能的全才人物。他说：“一个人是可以使千万年的历史生色的——也就是说，一个充实的、雄厚的、伟大的、完全的人要胜过无数残缺不全、鸡毛蒜皮的人”。比喻那些自己凌驾于一切之上的、自命不凡的利己主义者。也指那些能力卓异、超越常人的人。某种信仰而实行自我节制、自我磨练，拒绝物质和肉体的引诱，忍受恶劣环境压迫的人。\r\n\r\n52.多余的人：\r\n\r\n出自俄国作家小说《多余人的日记》。19世纪俄国贵族知识分子的一种典型。他们不愿与贵族上流社会同流合污，自命清高。但因他们远离人民，无法摆脱贵族立场，所以精神萎靡、情绪消极，缺乏生活目的，不能有所作为。比喻那些饱食终日，无所事事的游手好闲之徒。\r\n\r\n53.出走的娜拉：\r\n\r\n娜拉是挪威戏剧家易卜生《玩偶之家》的主人公。她本是一个思想单纯、满足于家庭幸福的少妇，但丈夫海尔茂仅仅把她当作一个玩偶。后来，娜拉看清了丈夫自私卑鄙的本性。觉醒后的娜拉在圣诞节的深夜毅然离开了“玩偶之家”。后多形容那些反抗丈夫的家庭专制，追求自己独立人格和幸福的女人。\r\n\r\n54.哈洛尔德式的冷漠：\r\n\r\n出自英国诗人拜伦的长诗《恰尔德。哈洛尔德游记》。恰尔德。哈洛尔德是一个具有自由民主思想的英国贵族阶级的叛逆者，他厌恶过去，不满现实，却又没有勇气去斗争，他的心始终是冷冰的。比喻知识分子对腐败的社会现实既不愿调和又不屑抗争的冷漠态度。\r\n\r\n55.鲁滨孙和星期五：\r\n\r\n“鲁滨孙”和“星期五”都是英国作家笛福的长篇小说《鲁滨孙漂流记》中的人物。鲁滨孙乘船去非洲时在海上遇到风暴，漂流到一个孤岛上，为了活下去，他顽强地与大自然抗争，在孤岛上整整生活了28年，并养成了一种对任何事情都不失望的精神。他在孤岛上的第24个年头的一个星期五，还在海里救起了一个“野人”，并为其取名“星期五”。3年后，二人逃离孤岛。鲁滨孙回到英国并成为巨富。后来，人们在写文章时就常用“鲁滨孙和星期五”这一典故来批评那些企图脱离社会、脱离人民的幻想。\r\n\r\n56.山姆大叔：\r\n\r\n山姆大叔是美国的绰号，产生于1812年美英战争时期。纽约州一位诚实能干的肉类包装商被人们亲切地称为山姆大叔。他担任纽约州和新泽西州的军需检验员，负责在供应军队的牛肉桶和酒桶上打戳。人们发现该厂的牛肉桶上都盖有E.A.-U.S.的标记。本来，E.A.是一个军火承包商的名字，U.S.是美国的缩写。碰巧山姆大叔（Uncle Sam）的缩写与美国的缩写（U.S.）相同，人们就管美国叫山姆大叔。美国人把山姆大叔诚实可靠、吃苦耐劳以及爱国主义精神视为自己民族的骄傲和共有的品质。1961年，美国国会正式承认山姆大叔为美国的民族象征。\r\n\r\n57.浮士德式的人物：\r\n\r\n浮士德原指15、16世纪德国的炼金术士。传说中的浮士德学识渊博、精通魔法，努力探索。德国诗人歌德创作了长诗剧《浮士德》。在诗人笔下，浮士德战胜了魔鬼摩非斯特的千方百计的引诱，克服挫折，奋斗不止，直到生命最后一刻他仍然渴望争取自由和生存。比喻学识渊博、精通魔法、有奇特本领及永不满足的追求者。\r\n\r\n58.客里空：\r\n\r\n“客里空”是原苏联作家柯涅楚克的名剧《前线》中的一个新闻记者的形象。客里空以无中生有、瞎编硬造为能事。他不调查了解，坐在指挥部拟稿。他根据听来的消息，即前线总指挥的儿子阵亡，就编造了总指挥的儿子在牺牲前如何发誓、总指挥听说儿子牺牲后如何痛哭流涕等情节。于是，客里空就成了新闻写作中弄虚作假、无中生有、凭空捏造的专用词。人们在写文章时把那些歪曲事实的报道消息称为“客里空”。\r\n\r\n59.和平鸽：\r\n\r\n《旧约•创世纪》：上帝降洪水于大地，大雨下了40昼夜，遍地汪洋，只留下挪亚方舟里的人和动物。雨停后，挪亚放出一只鸽子去探测外面的消息。直到黄昏，鸽子才飞回来。嘴里衔着一枝翠绿的橄榄叶，挪亚洪水已退，平安来到了。后将鸽子和橄榄枝作为和平的象征。\r\n\r\n60.斯芬克斯之迷；\r\n\r\n斯芬克斯是希腊神话中以隐谜害人的怪物。他对俄底浦斯的提问是，有一种生物，早晨用四只脚走路，当午用两只脚走路，傍晚用三只脚走路。这是什么？俄底浦斯回答是“人”，他猜中了，斯芬克斯羞愧地跳下悬崖摔死了。比喻复杂、神秘、难于了解的问题。\r\n\r\n61.奥吉亚斯的牛圈：\r\n\r\n出自希腊神话。奥吉亚斯是海神的儿子，他养了无数的牛，粪秽堆积如山。比喻累积成堆或肮脏腐败的难以解决的问题。\r\n\r\n62.凤凰：\r\n\r\n希腊神话中的一种鸟。据说，凤凰每五百年自焚一次，再从灰烬里恢复青春。故凤凰象征永恒、再生。\r\n\r\n63.布利丹毛驴：\r\n\r\n出自14世纪法国哲学家布利丹的寓言。有一头饥饿毛驴站在两捆同样的干草之间，居然不知吃那边的干草才好，结果饿死了。比喻那些优柔寡断的人。\r\n\r\n64.黑马：\r\n\r\n源于赛马场的俚语，指外表并不起眼，赛马时出人意料地夺魁的马匹，并非指马的毛色。1861年当时既无名气又无资历的阿伯拉罕。林肯当选为美国16任总统，因而曾被人们称为黑马式的总统。比喻实力或价值难以预测的人、物。\r\n\r\n65.鳄鱼的眼泪：\r\n\r\n西方传说，鳄鱼非常阴险狡猾，当它诱捕到猎物时，一边贪婪地吞噬，一边假惺惺地流泪。喻指虚假的眼泪，伪装的同情。后引申为一面伤害别人，一面装出悲天悯人的阴险狡诈之徒。\r\n\r\n66.十字架：\r\n\r\n将人钉死在十字架上是古罗马帝国的一种酷刑。被判处这种刑罚的囚犯，要背着十字架走向刑场。基督教《圣经》称：耶稣被钉死在十字架上，后来基督教便以此作为信仰的标记，称为“苦难像”。迄今，西方文学中一般用十字架比喻苦难。\r\n\r\n67.十诫：\r\n\r\n《旧约•出埃及记》：上帝在西乃山的雷鸣中降临以后，对以色列人的先知摩西说，我将你们从埃及的为奴之家领出来，你们得听从我的指示，必须遵守以下各点：\r\n\r\n1、除耶和华外，不可信别的神；2、不可为自己雕刻偶像，也不可跪拜任何偶像；3、不可妄称上帝耶和华的名字；4、纪念安息日，守为圣日，六日劳动，七日休息；5、孝敬父母；6、不可杀人；7、不可奸淫；8、不可偷盗；9、不可做假见证陷害人；10、不可贪念人家的房屋、妻子、仆婢、牛羊等。摩西于是成为以色列人最早的立法者，“十诫”成为以色列人神圣的律法。\r\n\r\n68.伊甸园\r\n\r\n《旧约•创世纪》：上帝在东方的一片富饶的平原上开辟了一个园子——伊甸园。园子里生长着美丽的并结着甜果的树木，也有各式各样的飞禽走兽。上帝派亚当看守园子，为排除亚当的孤寂，上帝从他的身上取出一根肋骨，造成一个女人——夏娃来陪伴他。他们吃着甜果，漫步林间草地，过着无忧无虑、和谐美满的生活。后世以此喻乐园。\r\n\r\n69.诺亚方舟：\r\n\r\n《旧约•创世纪》：上帝对人类所犯下的罪孽十分忧伤，决定消灭人类。因为挪亚是义人，所以上帝吩咐他造舟避灾。后指灾难时代的救星，或危境中的避难所。\r\n\r\n70.达摩克利斯之剑：\r\n\r\n出自希腊历史传说。达摩克利斯是公元前4世纪叙拉古王迪奥尼修斯的宠臣。迪奥尼修斯感到自己的地位不可靠，有一次他请达摩克利斯到一间富丽堂皇的房间里，在座位上方用马鬃悬挂着一把宝剑。达摩克利斯看到自己头上的剑随时都可能掉下来，心情紧张，如坐针毡。比喻随时可能发生的某种危险。\r\n\r\n71.潘多拉的盒子：\r\n\r\n出自希腊神话。潘多拉是宙斯用来惩罚人类、给人类带来灾难的女人。普罗米修斯将天火盗往人间之后，宙斯命匠神用泥土作成一个女人，取名“潘多拉”。并给了她一个装满灾难、贪婪、疾病、战事、悲愁……的礼盒，然后将她作为赠礼送给普罗米修斯的弟弟。潘多拉在普的弟弟面前突然打开盒子，于是灾难、贪婪、疾病、战事、悲愁……迅速散布到大地、天空和海洋。盒子底下只藏着唯一美好的东西：希望，但在希望未飞出之前，潘多拉就将盒子永远关闭了。比喻带来灾难和祸害的东西，或造成灾害的根由。\r\n\r\n72.特洛伊木马：\r\n\r\n古希腊传说，特洛伊王子帕里斯访问希腊，诱走了王后海伦，希腊人因此远征特洛伊。围攻9年后，到第10年，希腊将领奥德修斯献了一计，就是把一批勇士埋伏在一匹巨大的木马腹内，放在城外后，佯作退兵。特洛伊人以为敌兵已退，就把木马作为战利品搬入城中。到了夜间，埋伏在木马中的勇士跳出来，打开了城门，希腊将士一拥而入攻下了城池。后来，人们在写文章时就常用“特洛伊木马”这一典故，用来比喻在敌方营垒里埋下伏兵里应外合的活动。\r\n\r\n73.阿拉丁神灯：\r\n\r\n出自阿拉伯民间故事《一千零一夜》。阿拉丁是苏丹国一个裁缝的儿子，他得到了一盏神灯，只要擦亮神灯，一个自称是神灯的奴隶的巨魔就会出现，它能满足主人的任何要求。比喻能满足人的一切愿望的东西。\r\n\r\n74.波皮利圈子：\r\n\r\n波皮利是古罗马的一位执政官。一次，罗马元老院委派他去说服叙利亚国王安梯丘放弃掠夺来的部分土地。波皮利仗着自己是大国使者，根本不把这位小国之君放在眼里。他在安梯丘座位的周围画了一个圆圈，说：在未答复罗马元老院的要求之前，安梯丘不可走出圈子半步。由此，波皮利圈子一语就被用来比喻因受某种约束而不能逾越的范围。\r\n\r\n75.光轮：\r\n\r\n神话传说中神和英雄头上的圆光。基督教、佛教等借用了光轮，使之成为神像神圣的标志。\r\n\r\n76.象牙塔：\r\n\r\n19世纪法国诗人、文艺批评家圣佩韦。查理。奥古斯丁的书函《致维尔曼》。奥古斯丁批评同时代的法国作家维尼的作品中的悲观消极的情绪，主张作家从庸俗的资产阶级现实超脱出来，进入一种主观幻想的艺术天地——象牙之塔。比喻与世隔绝的梦幻境地。\r\n\r\n77.红十字：\r\n\r\n19世纪和撒丁与奥地利军队发生战争。瑞士人道主义者杜南目睹战争惨状，提出成立一个中立的战地救护组织。1863年日内瓦伤兵救护委员会终于成立。因其发起人和成员都是瑞士人，于是就把红底白十字的瑞典国旗改为白底红十字的新旗帜，作为标志。此后，红十字就成了中立、人道主义和救死扶伤的标志。\r\n\r\n78.红帆：\r\n\r\n出自苏联作家A.格林的同名小说。小说女主人公阿索莉幻想有一位年轻王子驾着一艘升着红帆的船来接她。常用来比喻美好的理想。\r\n\r\n79.大棒加胡萝卜：\r\n\r\n出自美国总统罗斯福1916年5月间的一次演讲。演讲辞中援引了一句非洲谚语来说明他的外交政策：“语言柔和，手持大棒。”后比喻武力恫吓和物质引诱相结合的政策。\r\n\r\n80.多米诺骨牌：\r\n\r\n是一种西洋游戏，将许多长方形的骨牌竖立排列成行，轻轻推倒第1张牌时，其余骨牌将依次纷纷倒下。用于比喻时，多米诺骨牌效应常指一系列的连锁反应，即牵一发而动全身','词汇的含义','','publish','open','open','','%e8%af%8d%e6%b1%87%e7%9a%84%e5%90%ab%e4%b9%89','','','2013-08-23 13:58:40','2013-08-23 05:58:40','',0,'http://localhost/wordpress-new/?p=92',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (93,1,'2013-08-23 13:58:40','2013-08-23 05:58:40','1、 乌托邦：\r\n\r\n源出希腊文ou（无）和topos（处所），意即“乌有之乡”。1516年，英国空想社会主义者莫尔在其《乌托邦》一书中，描述了一个他所憧憬的美好社会，即乌托邦。那里一切生产资料均归全民所有，生活用品则按需分配；人人都从事生产劳动，并有充足的时间供科学研究和娱乐；那里没有酒店妓院，也没有堕落和罪恶……。故此词喻指根本无法实现的理想或空想的美好社会。\r\n\r\n2. 柏拉图式恋爱：\r\n\r\n柏拉图是古希腊著名的唯心主义哲学家，苏格拉底的弟子，亚里士多德的老师。他在对话体著作《会饮篇》中，阐述了自己对爱情的看法：爱神是人与神之间的中介，他用神秘的激情控制着世界，使人以一种不可遏止的欲望去追求永恒的美。这个追求是一个逐渐上升的认识过程。爱的最低级的形式是热恋中的情人“专注于对方美的形体”，渴望与对方肉体的结合，爱的较高形式则是从沉湎于美的形体升华到爱恋形体所表现出来的美，爱的最高形式是沉思的美，即不带感性形体的美。他由此提出了将真、善、美合为最高理想的看法。后来，人们把男女之间那种与性无涉的、理想化的相互爱慕情谊，称为柏拉图式恋爱，现代语也叫精神恋爱。\r\n\r\n3.犹大的亲吻：\r\n\r\n犹大是《圣经》中耶稣基督的亲信子弟12门徒之一。耶稣传布新道虽然受到了百姓的拥护，却引起犹太教长老司祭们的仇恨。他们用30个银币收买了犹大，要他帮助辨认出耶稣。他们到客马尼园抓耶稣时，犹大假装请安，拥抱和亲吻耶稣。耶稣随即被捕，后被钉死在十字架上。人们用犹大的亲吻比喻可耻的叛卖行为\r\n\r\n4.海妖之歌：\r\n\r\n出自希腊神话。传说在一个岛上住着一些以美妙歌声迷人害人的海妖，名叫塞壬。后奥德赛路经该岛，事先得到瑟西女仙的警告，用蜡封住同伴们的耳朵，又把自己绑在桅杆上，同伴们奋力划桨，终于战胜了迷人的歌声。比喻那种骗人的甜言蜜语。\r\n\r\n5.苹果之争：出自希腊神话。密尔弥多涅斯人的国王珀琉斯和女神西蒂斯邀请众神参加婚礼，惟独忘了争吵之神厄里斯。厄里斯寻衅将一个金苹果扔在宴席中，说是要送给最美丽的女神。天后赫拉、智慧女神雅典娜和爱神阿芙罗狄蒂都争相要这个金苹果，最后苹果判给了阿芙罗狄蒂。并由此引发了特洛伊战争。比喻祸端。或指挑动是非、播弄不合。\r\n\r\n6.阿基里斯之踵：\r\n\r\n希腊神话英雄阿基里斯唯一能被刺伤的地方。他出生后，母亲海洋女神西蒂斯握着他的脚跟在冥河里浸泡，因此他全身除脚踵外其他地方刀枪不入。比喻易受伤害的地方或致命弱点。\r\n\r\n7.忘忧果：\r\n\r\n出自荷马史诗《奥德赛》。奥德赛的船队返乡途中，船被风雨吹到一处海边。同伴们吃了当地特产忘忧果之后，竟然忘记家乡和亲人，忘记自己上岸的目的，也忘记回船上去。后比喻身居异乡，乐不思归。\r\n\r\n8.月桂：\r\n\r\n出自希腊神话。阿波罗爱上了女妖达乎涅，但达乎涅拒绝了他的追求。有一次阿波罗遇见达乎涅，达乎涅立即跑到河边，向他父亲河神呼救，她父亲便将她变成了一棵月桂树。阿波罗抚摩着月桂说：“你既然不能做我的妻子，你至少也得做我的树。月桂树啊，我的头发上、竖琴上、箭囊上要永远缠着你的树枝，我要让罗马大将在凯旋的欢呼中头上戴着你的花冠，你的枝叶永远接受光荣吧。”后来人们遂用月桂树枝编成的花冠赠给优秀的诗人。月桂、桂冠也被用来做胜利和光荣的象征。\r\n\r\n9. 洗礼：\r\n\r\n出自《圣经》。人类的始祖亚当和夏娃因听了神蛇的话偷吃禁果犯下了罪，这个罪过从此代代相传，叫做“原罪”；各人违背上帝旨意也会犯罪，称为“本罪”。所以，凡笃信上帝的人，必须经过洗礼，洗刷原罪和本罪。洗礼时，主洗者口诵经文，受洗者注水额上或头上，也有全身浸入水中的，故洗礼也称“浸洗”。后比喻经受某种锻炼或考验。\r\n\r\n10.卡夫卡式的变形：\r\n\r\n卡夫卡是奥地利作家，他写过一部小说《变形记》。书中主人公格里高尔。萨姆沙是一家公司的推销员。他忠于职守，循规蹈矩，成年累月为推销商品劳碌奔波。一天早晨醒来，他突然发现自己变成了一只“大甲虫”，内心十分恐惧和痛苦，父母对他的变化十分悲伤，妹妹开始同情他。他逐渐失去了人的习性，“虫性”不断加重，他失去了工作，父亲恨他不死，母亲、妹妹也由哀怜转而生厌，邻居耻与为邻。他最后在孤独中死去。此语比喻一个人突遭不幸，成了别人的累赘时，他与周围人的关系也会变化，这种变化撕掉了人与人之间温情脉脉的面纱，暴露出赤裸裸的利害关系。\r\n\r\n11.跨掉的一代：\r\n\r\n原系20世纪五六十年代流行于美国的一种文学流派。该派均为青年作家，他们以虚无主义态度否定一切，要求摆脱一切传统束缚，拒绝承当任何社会和家庭义务，追求所谓“绝对自由”的生活：吸毒、酗酒、偷窃、同性恋等。在艺术上则主张抛弃传统手法，提倡随意发挥。其作品形式上大多支离破碎，内容上消极颓废，但在一定程度上反映了对美国社会的反叛。后指对现实不满而又无所作为、甚至沾有恶习的颓废青年人。\r\n\r\n12.华尔街的“民意”：\r\n\r\n华尔街是美国纽约的一条街。17世纪时，这里就是贸易中心和贩卖黑奴的市场，二战后，这里成了美国重要的金融中心。华尔街便是美国垄断资本的代名词，华尔街的“民意”即指美国垄断资本家的意愿。\r\n\r\n13.A字第一号：\r\n\r\nA是英语的第一个字母，因而常用来表示“第一”的意思。最早出现在英国著名的劳埃德海运保险社的船只登记簿上。凡属最好的船只，都用“A1”在登记簿上作登记；而已沉没的船只则登记在一个黑色封皮的簿子上。后来，人们就把最好的或一流水平的称为“A字第一号”，而把记载不祥消息或为进行某种迫害而开列的名单叫做“黑名单”。\r\n\r\n14.欧•亨利手法：\r\n\r\n欧•亨利是美国20世纪初短篇小说家。他主要写幽默小说，其作品常以“含泪的微笑”抚慰那些小人物在残酷的社会现实的打击的心灵创伤。他善用夸张、嘲讽、双关语等，并尤擅于安排故事结尾，笔锋一转，让主人公命运发生一百八十度的变化，使读者瞠目结舌，却又深信不疑。后泛指这种在结尾处峰回路转、柳暗化明的突变手法。\r\n\r\n15.蒙娜丽莎的微笑：\r\n\r\n《蒙娜丽莎》是意大利达•芬奇的作品。完成于1506年，画中的蒙娜丽莎相传原是佛罗伦萨有名的美女，她性情矜持，郁郁寡欢。为了使蒙娜丽莎发自心扉的微笑，达•芬奇请乐队演奏美人家乡的作品，才使他嫣然一笑。而这一微笑的含义就成为几百年艺术史上的不解之迷。常比喻青年女子迷人的微笑，或转义为神秘的微笑。\r\n\r\n16.极乐世界：\r\n\r\n原为印度佛教名词。又译“安乐国”、“安养国”、“佛国”、“净国”、“净土”等，俗称“西天”。极乐世界是“无有众苦，但受诸乐”的地界。比喻最快乐的地方或虚无飘渺的地方。\r\n\r\n17.护城神像：\r\n\r\n古希腊作为城市保卫者的武装神祗的雕像。当时的人认为，只要护城神像还在，敌人就攻不破。被雕成的神像主要有太阳神阿波罗、爱与美之神阿芙罗狄蒂和智慧女神雅典娜。后转义为有力的保障和支柱。\r\n\r\n18.骑士精神：\r\n\r\n骑士原是中世纪时欧洲封建贵族中等级最低、人数最多的一个阶层。他们通过服骑兵兵役获得国王或大领主的采邑。因当时欧洲各国封建割据，领主们为保存并扩张势力，就得依靠骑射搏击的武功。因此无论国君还是爵爷，实际上都是骑士，这使得骑士的地位大大提高了。由于当时社会崇尚武艺，因而骑士很受人仰慕。骑士周身披着钢甲，头上戴着有蒙面罩的兜帽，腰间插着十字柄的直剑，手执长矛和盾牌，骑膘悍的高头大马，威风凛凛。他们经常比武打斗，与上流社会的妇女谈情说爱。成为当时文学创作的重要题材，出现了历久不衰的“骑士传奇文学”。后来，欧洲人常把崇尚武艺、扶弱抑强、尊重女性、忠贞爱情、捍卫荣誉的品质称为“骑士精神”。另，18世纪意大利有些贵族青年效仿中世纪骑士的做法，甘愿为一些名门贵妇服役，人们嘲讽的称这些贵族青年为“侍从骑士”。由此，此语成了为贵妇人效劳并向她们献殷勤的青年男子同义语。\r\n\r\n19.禁果：\r\n\r\n《旧约•创世纪》：亚当和夏娃住在伊甸园中，上帝允许他们食用园中的果子，惟有一棵“知善恶树”上的果子禁止吃。但狡猾的蛇引诱他们吃了禁果。结果心明眼亮，知善恶，辨真假，羞耻之情油然而生，被上帝逐出伊甸园。蛇也受到惩罚：终生用肉躯爬行。比喻因被禁止而更想得到的东西。\r\n\r\n20. 涅槃：\r\n\r\n旧译“泥洹”，意译“灭度”。或称“般涅槃”，意译“入灭”、“圆寂”。佛教全部修习所要达到的最高理想。一般指通过修持断灭“生死”轮回而后获得的一种精神境界。佛教认为，信佛的人，经过长期“修道”，即能“寂（熄）灭”一切烦恼和“圆满”一切“清净功德”。这种境界，名为“涅槃”。在佛教史籍中，通常也作为死亡的代称。后来，人们在写文章时就把“涅槃”作为“死亡”的代称来使用。\r\n\r\n21.沙龙：\r\n\r\n“沙龙”是法语的译音，它原为意大利语，17世纪传入法国，最初为卢浮宫画廊的名称。后来指法国上层人物住宅中的豪华会客厅。当时，巴黎的名人（多半是名媛贵妇）常把客厅变成著名的社会交际场所。进出这里的人，多为小说家、诗人、画家、戏剧家、哲学家、音乐家和评论家等，他们志趣相同，欢聚一堂，或作诗绘画，或欣赏典雅的音乐，或就各种感兴趣的问题促膝长谈，无拘无束，各抒高见。后来，人们就把这种形式的聚会称为“沙龙”。正宗的“沙龙”有以下特点：要定期举行；时间要在晚上；人数不能太多。现在，人们在写文章时就常借“沙龙”一词来表述某项活动，如“文学沙龙”、“音乐沙龙”等。\r\n\r\n22.圆桌会议：\r\n\r\n出自英国古代英雄亚瑟王和他的圆桌骑士的传说。圆桌无首席末席之分，象征围桌而坐的骑士处于平等的地位。在圆桌旁举行的会议称为“圆桌会议”。表示参加谈判的各方一律平等。1.敲吧，门终究会开的：《新约•路加福音》：耶酥曾对门徒说：“你们祈求，就给你们：寻找，就寻得见；叩门，就给你们开门。因为凡祈求的就得着，寻找的就寻见。”意即只要孜孜以求，定能如愿以偿。\r\n\r\n23.种风者收获风暴：《旧约•何西阿书》：以色列先知何西阿看到国内的民众崇拜牛犊，而放弃了对上帝耶和华的信念，就指责他们，说他们必将自食其果。他们所种的是风，所收获的将是风暴。比喻作恶者必将自食其果。\r\n\r\n24.骨中之骨，肉中之肉：\r\n\r\n出自《圣经》。上帝在亚当身上取下一根肋骨造了女人夏娃，并让两人结为夫妻。亚当说：“这是我的骨中之骨，肉中之肉，可以称她为妻，因为她是从夫身上取下来的。因此男人要和妻结合，夫妻成为一体。”后喻指骨肉相连的关系，也比喻耗费了自己很多心血和精力所获得的成果和最心爱的东西。\r\n\r\n25.尘土之身：\r\n\r\n出自《圣经》。亚当、夏娃偷吃了知善恶树的果子，触怒了上帝，被赶出伊甸园。上帝诅咒：人必须遭受土地的折磨。人要从田里收获果实充饥，而田里将长满荆棘和蒺藜，人必须终身劳作，地里才会长出庄稼养活人类，直到归了土；人从泥土而来，本是尘土，死后仍归于尘土。故后常称人为尘土之身。\r\n\r\n26.认识自己：\r\n\r\n出自希腊神话。奥维德的《爱经》里有这样的话：“阿波罗说：”快把你的弟子领到我的殿里来罢，他们可以在那儿念那全世界闻名的铭文：凡人，认识你自己。‘“古希腊人认为”认识自己“才能富于智慧，得福免祸。\r\n\r\n27.喝了忘川的水：\r\n\r\n忘川是希腊神话中阴间的一条河流。人死后亡灵堕入阴间，只要喝了这河里的水，就会忘记过去的一切，故称为忘川。比喻遗忘了不该遗忘的事情。\r\n\r\n28.家可爱，家最好：\r\n\r\n出自《伊索寓言》。宙斯结婚，邀请动物都来参加。惟独乌龟未来。宙斯问他为何不来赴宴。乌龟说：“家可爱，家最好。”宙斯很生气，就罚他驮着自己的家行走。指许多人宁愿在家简朴度日，也不愿做客过豪华的生活。\r\n\r\n29.进来的人们，把一切希望抛弃吧：\r\n\r\n出自意大利诗人但丁《神曲。地狱篇》。诗人描绘了地狱门口的凄惨情景。地狱的门上写着：“你们走进这里的，把一切希望抛在后面吧！”后比喻绝望无助的境地。\r\n\r\n30.吃不到的葡萄总是酸的：\r\n\r\n出自《克雷洛夫寓言》。狐狸看到了成熟的葡萄，眼睛和牙齿都发亮了，可惜吃不到，只好愤愤地说：“算了，虽然看上去挺好的，实际上都没有成熟！没有一颗不是酸的。”讽刺某人得不到某种好东西，就反过来说这东西不好，以求心理平衡。\r\n\r\n31.回到破旧的木盆旁边：\r\n\r\n出自普希金的童话诗《渔夫和金鱼的故事》。渔夫网到一条会说话的金鱼，他把金鱼放回大海，金鱼许下有求必应的诺言。渔夫的老婆便逼迫丈夫不断向金鱼索取，直至要金鱼做自己的侍从，金鱼忍无可忍，终于收回给予老太婆的一切东西，是她又回到原来的破木盆旁边。意义与“竹篮打水一场空”相似。\r\n\r\n32.哪里好，哪里就是祖国：\r\n\r\n出自古希腊作家阿里斯托芬的喜剧《财神》。比喻唯利是图、甚至不惜背弃祖国者。也形容毫无原则的人。\r\n\r\n33.武装到牙齿：\r\n\r\n从前，南美沿海地区，特别是北海岸地区海盗横行。这些海盗凶狠异常，除了两手持武器外，嘴上还咬着一把刀。由此有了这个典故。后形容全副武装的人或武装到极限的国家。\r\n\r\n34.顺着葡萄藤来的消息：\r\n\r\n1844年5月24日，美国的塞缪尔。莫尔斯发明了电报，许多公司开始架设电线，但限于科学水平，电线总是拉得弯弯曲曲，有人开玩笑说像葡萄藤于是产生该语。比喻小道消息，引申为从各种非正规途径传出的秘密消息。\r\n\r\n35.约伯：\r\n\r\n《旧约•约伯记》：约伯是一个敬畏上帝的富人。魔鬼撒旦不相信他对上帝的虔诚，便怂恿上帝允许他考验约伯，上帝默许后，他多次降祸于约伯。面对灾难，约伯伏地跪拜上帝，说：“我赤身而来，当赤身而去；上帝的赐予，当由上帝取回，上帝英名永存。”于是，上帝使他从苦境中转回，并赐给他加倍的恩惠。后用他的名字喻指最有忍耐力的人。约伯的妻子因不堪苦难，曾劝说约伯放弃信仰。后世便以“约伯的妻子”比喻目光短浅的愚顽的妇人。\r\n\r\n36. 缪斯：\r\n\r\n“缪斯”是希腊神话中的九位文艺和科学女神的通称。她们均为主神和记忆女神之女，都在奥林匹斯山的庇厄里亚出生和居住。她们以音乐和诗歌之神阿波罗为首领，分别掌管着历史、悲剧、喜剧、抒情诗、舞蹈、史诗、爱情诗、颂歌和天文。因为她们常去的帕耳那索斯山下有卡斯他利阿神泉，所以古希腊的诗人、歌手都向缪斯呼告，祈求灵感。后来，人们在写文章时就常用“缪斯”来比喻文学、写作和灵感等。\r\n\r\n37.皮格马利翁：\r\n\r\n皮格马利翁是希腊神话中的塞浦路斯国王。他憎恨女性，决定永不结婚。他用神奇的技艺雕刻了一座美丽的象牙女像，并爱上了她。他像对待自己的妻子那样抚爱她，装扮她，并向神乞求让她成为自己的妻子。爱神阿芙洛狄忒被他打动，赐予雕像生命，并让他们结为夫妻。皮格马利翁效应：后来被用在教育心理学上，也称期待效应罗森塔尔效应：比喻教师对学生的期待不同，对他们施加的方法不同，学生受到的影响也不一样。\r\n\r\n38.俄底浦斯：\r\n\r\n希腊神话中英雄忒拜王拉伊俄斯和王后伊俄斯特的儿子。神谕说：“国王的儿子将要杀父娶母。”所以孩子一出生就被扔到山上，但被救活，并长大了。一次，他失手打死一个老人，这正是他的生父。后来，他来到忒拜，为当地人除去人面狮身怪兽，被拥戴为忒拜王，并娶了前王的妻子——正是他的生母。注定的命运还是实现了。母亲悲愤自杀，他也弄瞎了双眼，最后死在雅典附近复仇女神的圣林里。\r\n\r\n39.安泰：\r\n\r\n“安泰”是希腊神话中的巨人和英雄，是海神波塞冬和地神盖娅的儿子。他的力量来源于大地母亲，只要身不离地，就力量无穷，所向无敌；但如果身体离开了大地母亲，就要失去生存能力。后来，安泰被希腊神话中最伟大的英雄赫拉克勒斯举在空中击毙了。因为安泰是个离开大地母亲就失去力量的巨人，所以，后来人们在写文章时就常用“安泰”来比喻作家、诗人以及革命政党不能脱离人民群众。\r\n\r\n40.西西弗斯：\r\n\r\n西西弗受到众神的惩罚，众神让他永不停息地推着一块沉重的巨石上山。当西西弗斯将巨石推至山顶时，石头便会不可阻挡地滚下山去。西西弗斯便这样周而复始地推石头上山。41.美狄亚：希腊神话中科尔喀斯国王的女儿，她帮助伊阿宋取得了金羊毛。当她跟随伊阿宋从亚尔古船上逃走时，看见父亲追来，她便把兄弟的身体砍成碎块，抛入海中。她父亲忙于收尸，没有追上他们。几年后，伊阿宋变了心，娶了新妻。她叫儿子将一件遍染磷火性毒药的新衣送给伊阿宋的新妻，新妻着衣，即被烧死。美狄亚亲手杀死了自己两个孩子，带着他们的尸体到了雅典。雅典国王给了她一个避难所。喻指阴险、毒辣的女人。\r\n\r\n42.堂•吉珂德：\r\n\r\n西班牙作家同名小说的主人公。他是一个上了年纪、瘦弱可笑的乡村小贵族，因看骑士小说入迷，便也想做个骑士，干一番惊天动地的事业。结果做出一系列荒唐的事情。比喻那些脱离实际，耽于幻想，因而做出错误判断、一味蛮干，荒唐可笑的人。这种人的做法成为“堂。吉珂德式的行为”。\r\n\r\n43.当代阿巴贡：\r\n\r\n阿巴贡是莫里哀喜剧《吝啬鬼》（又名《悭吝人》）中的主人公。他生性多疑，视钱如命，就连赠你一个早安也舍不得说，而说借你一个早安。阿巴贡是世界文学中一个著名的典型形象，与葛朗台（巴尔扎克《欧也妮。葛朗台》）、夏洛克（莎士比亚《威尼斯商人》）、乞乞科夫（果戈里《死魂灵》）三个形象合称“四大吝啬鬼”。\r\n\r\n44.哈姆雷特的悲剧：\r\n\r\n哈姆雷特是莎士比亚同名悲剧中的主人公。他父王被其弟弟毒死。为了复仇，他以装疯为掩护。但由于过于审慎，一再延宕，最后落得玉石俱焚的结局。比喻遇事犹豫不决、疑虑重重、迟迟不采取行动而坐失良机、一事无成的人。\r\n\r\n45.豌豆公主：\r\n\r\n出自丹麦安徒生的同名童话。一个公主能觉出在20层垫子和20层鸭绒被下放的一粒豌豆。讽刺那些娇嫩无比，弱不禁风的小姐。\r\n\r\n46.滑铁卢的拿破仑：\r\n\r\n1815年拿破仑亲率12万大军同反法联军在比利时南部的滑铁卢作战，惨败。拿破仑被囚禁在大西洋中的圣赫勒拿岛上。直到1821年病故。正因为滑铁卢战役的失败，拿破仑从此一蹶不振，因此此语比喻英雄末路。\r\n\r\n47.浮士德式的人物：\r\n\r\n浮士德原指15、16世纪德国的炼金术士。传说中的浮士德学识渊博、精通魔法，努力探索。德国诗人歌德创作了长诗剧《浮士德》。在诗人笔下，浮士德战胜了魔鬼摩非斯特的千方百计的引诱，克服挫折，奋斗不止，直到生命最后一刻他仍然渴望争取自由和生存。比喻学识渊博、精通魔法、有奇特本领及永不满足的追求者。\r\n\r\n48.苦行僧：\r\n\r\n原是印度一些宗教中以“苦行”为修行手段的僧人。“苦行”一词，梵文原义为“热”，因为印度气候炎热，宗教徒便把受热作为苦行的主要手段。比喻为实践。\r\n\r\n49.酸小姐：\r\n\r\n出自俄国作家波米亚洛夫斯基的小说《小市民的幸福》。女主人公莲诺奇卡是一个目光短浅，精神空虚的“千金小姐”。由于失恋而成为忧心忡忡，痛苦悲伤的“酸小姐”。后比喻矫揉造作、装腔作势的女子。也泛指目光短浅、思想庸俗或感情脆弱、喜怒无常的人。\r\n\r\n50.套中人：\r\n\r\n出自俄国作家契珂夫的同名小说。小官吏别里科夫性格怪僻，他晴天出门也要穿雨鞋、棉大衣，带雨伞。他害怕变革，凡有新生事物出现，他总是摇头晃脑说：“不要弄出什么事情来。”他犹如生活在套子里，隔绝人世。因此，此语成为墨守成规、因循守旧的同义语。表示害怕一切新鲜事物、害怕变革的人。\r\n\r\n51.超人：\r\n\r\n出自尼采《查拉图什特拉如是说》。尼采认为“超人”是代表统治阶层的理想化的无所不能的全才人物。他说：“一个人是可以使千万年的历史生色的——也就是说，一个充实的、雄厚的、伟大的、完全的人要胜过无数残缺不全、鸡毛蒜皮的人”。比喻那些自己凌驾于一切之上的、自命不凡的利己主义者。也指那些能力卓异、超越常人的人。某种信仰而实行自我节制、自我磨练，拒绝物质和肉体的引诱，忍受恶劣环境压迫的人。\r\n\r\n52.多余的人：\r\n\r\n出自俄国作家小说《多余人的日记》。19世纪俄国贵族知识分子的一种典型。他们不愿与贵族上流社会同流合污，自命清高。但因他们远离人民，无法摆脱贵族立场，所以精神萎靡、情绪消极，缺乏生活目的，不能有所作为。比喻那些饱食终日，无所事事的游手好闲之徒。\r\n\r\n53.出走的娜拉：\r\n\r\n娜拉是挪威戏剧家易卜生《玩偶之家》的主人公。她本是一个思想单纯、满足于家庭幸福的少妇，但丈夫海尔茂仅仅把她当作一个玩偶。后来，娜拉看清了丈夫自私卑鄙的本性。觉醒后的娜拉在圣诞节的深夜毅然离开了“玩偶之家”。后多形容那些反抗丈夫的家庭专制，追求自己独立人格和幸福的女人。\r\n\r\n54.哈洛尔德式的冷漠：\r\n\r\n出自英国诗人拜伦的长诗《恰尔德。哈洛尔德游记》。恰尔德。哈洛尔德是一个具有自由民主思想的英国贵族阶级的叛逆者，他厌恶过去，不满现实，却又没有勇气去斗争，他的心始终是冷冰的。比喻知识分子对腐败的社会现实既不愿调和又不屑抗争的冷漠态度。\r\n\r\n55.鲁滨孙和星期五：\r\n\r\n“鲁滨孙”和“星期五”都是英国作家笛福的长篇小说《鲁滨孙漂流记》中的人物。鲁滨孙乘船去非洲时在海上遇到风暴，漂流到一个孤岛上，为了活下去，他顽强地与大自然抗争，在孤岛上整整生活了28年，并养成了一种对任何事情都不失望的精神。他在孤岛上的第24个年头的一个星期五，还在海里救起了一个“野人”，并为其取名“星期五”。3年后，二人逃离孤岛。鲁滨孙回到英国并成为巨富。后来，人们在写文章时就常用“鲁滨孙和星期五”这一典故来批评那些企图脱离社会、脱离人民的幻想。\r\n\r\n56.山姆大叔：\r\n\r\n山姆大叔是美国的绰号，产生于1812年美英战争时期。纽约州一位诚实能干的肉类包装商被人们亲切地称为山姆大叔。他担任纽约州和新泽西州的军需检验员，负责在供应军队的牛肉桶和酒桶上打戳。人们发现该厂的牛肉桶上都盖有E.A.-U.S.的标记。本来，E.A.是一个军火承包商的名字，U.S.是美国的缩写。碰巧山姆大叔（Uncle Sam）的缩写与美国的缩写（U.S.）相同，人们就管美国叫山姆大叔。美国人把山姆大叔诚实可靠、吃苦耐劳以及爱国主义精神视为自己民族的骄傲和共有的品质。1961年，美国国会正式承认山姆大叔为美国的民族象征。\r\n\r\n57.浮士德式的人物：\r\n\r\n浮士德原指15、16世纪德国的炼金术士。传说中的浮士德学识渊博、精通魔法，努力探索。德国诗人歌德创作了长诗剧《浮士德》。在诗人笔下，浮士德战胜了魔鬼摩非斯特的千方百计的引诱，克服挫折，奋斗不止，直到生命最后一刻他仍然渴望争取自由和生存。比喻学识渊博、精通魔法、有奇特本领及永不满足的追求者。\r\n\r\n58.客里空：\r\n\r\n“客里空”是原苏联作家柯涅楚克的名剧《前线》中的一个新闻记者的形象。客里空以无中生有、瞎编硬造为能事。他不调查了解，坐在指挥部拟稿。他根据听来的消息，即前线总指挥的儿子阵亡，就编造了总指挥的儿子在牺牲前如何发誓、总指挥听说儿子牺牲后如何痛哭流涕等情节。于是，客里空就成了新闻写作中弄虚作假、无中生有、凭空捏造的专用词。人们在写文章时把那些歪曲事实的报道消息称为“客里空”。\r\n\r\n59.和平鸽：\r\n\r\n《旧约•创世纪》：上帝降洪水于大地，大雨下了40昼夜，遍地汪洋，只留下挪亚方舟里的人和动物。雨停后，挪亚放出一只鸽子去探测外面的消息。直到黄昏，鸽子才飞回来。嘴里衔着一枝翠绿的橄榄叶，挪亚洪水已退，平安来到了。后将鸽子和橄榄枝作为和平的象征。\r\n\r\n60.斯芬克斯之迷；\r\n\r\n斯芬克斯是希腊神话中以隐谜害人的怪物。他对俄底浦斯的提问是，有一种生物，早晨用四只脚走路，当午用两只脚走路，傍晚用三只脚走路。这是什么？俄底浦斯回答是“人”，他猜中了，斯芬克斯羞愧地跳下悬崖摔死了。比喻复杂、神秘、难于了解的问题。\r\n\r\n61.奥吉亚斯的牛圈：\r\n\r\n出自希腊神话。奥吉亚斯是海神的儿子，他养了无数的牛，粪秽堆积如山。比喻累积成堆或肮脏腐败的难以解决的问题。\r\n\r\n62.凤凰：\r\n\r\n希腊神话中的一种鸟。据说，凤凰每五百年自焚一次，再从灰烬里恢复青春。故凤凰象征永恒、再生。\r\n\r\n63.布利丹毛驴：\r\n\r\n出自14世纪法国哲学家布利丹的寓言。有一头饥饿毛驴站在两捆同样的干草之间，居然不知吃那边的干草才好，结果饿死了。比喻那些优柔寡断的人。\r\n\r\n64.黑马：\r\n\r\n源于赛马场的俚语，指外表并不起眼，赛马时出人意料地夺魁的马匹，并非指马的毛色。1861年当时既无名气又无资历的阿伯拉罕。林肯当选为美国16任总统，因而曾被人们称为黑马式的总统。比喻实力或价值难以预测的人、物。\r\n\r\n65.鳄鱼的眼泪：\r\n\r\n西方传说，鳄鱼非常阴险狡猾，当它诱捕到猎物时，一边贪婪地吞噬，一边假惺惺地流泪。喻指虚假的眼泪，伪装的同情。后引申为一面伤害别人，一面装出悲天悯人的阴险狡诈之徒。\r\n\r\n66.十字架：\r\n\r\n将人钉死在十字架上是古罗马帝国的一种酷刑。被判处这种刑罚的囚犯，要背着十字架走向刑场。基督教《圣经》称：耶稣被钉死在十字架上，后来基督教便以此作为信仰的标记，称为“苦难像”。迄今，西方文学中一般用十字架比喻苦难。\r\n\r\n67.十诫：\r\n\r\n《旧约•出埃及记》：上帝在西乃山的雷鸣中降临以后，对以色列人的先知摩西说，我将你们从埃及的为奴之家领出来，你们得听从我的指示，必须遵守以下各点：\r\n\r\n1、除耶和华外，不可信别的神；2、不可为自己雕刻偶像，也不可跪拜任何偶像；3、不可妄称上帝耶和华的名字；4、纪念安息日，守为圣日，六日劳动，七日休息；5、孝敬父母；6、不可杀人；7、不可奸淫；8、不可偷盗；9、不可做假见证陷害人；10、不可贪念人家的房屋、妻子、仆婢、牛羊等。摩西于是成为以色列人最早的立法者，“十诫”成为以色列人神圣的律法。\r\n\r\n68.伊甸园\r\n\r\n《旧约•创世纪》：上帝在东方的一片富饶的平原上开辟了一个园子——伊甸园。园子里生长着美丽的并结着甜果的树木，也有各式各样的飞禽走兽。上帝派亚当看守园子，为排除亚当的孤寂，上帝从他的身上取出一根肋骨，造成一个女人——夏娃来陪伴他。他们吃着甜果，漫步林间草地，过着无忧无虑、和谐美满的生活。后世以此喻乐园。\r\n\r\n69.诺亚方舟：\r\n\r\n《旧约•创世纪》：上帝对人类所犯下的罪孽十分忧伤，决定消灭人类。因为挪亚是义人，所以上帝吩咐他造舟避灾。后指灾难时代的救星，或危境中的避难所。\r\n\r\n70.达摩克利斯之剑：\r\n\r\n出自希腊历史传说。达摩克利斯是公元前4世纪叙拉古王迪奥尼修斯的宠臣。迪奥尼修斯感到自己的地位不可靠，有一次他请达摩克利斯到一间富丽堂皇的房间里，在座位上方用马鬃悬挂着一把宝剑。达摩克利斯看到自己头上的剑随时都可能掉下来，心情紧张，如坐针毡。比喻随时可能发生的某种危险。\r\n\r\n71.潘多拉的盒子：\r\n\r\n出自希腊神话。潘多拉是宙斯用来惩罚人类、给人类带来灾难的女人。普罗米修斯将天火盗往人间之后，宙斯命匠神用泥土作成一个女人，取名“潘多拉”。并给了她一个装满灾难、贪婪、疾病、战事、悲愁……的礼盒，然后将她作为赠礼送给普罗米修斯的弟弟。潘多拉在普的弟弟面前突然打开盒子，于是灾难、贪婪、疾病、战事、悲愁……迅速散布到大地、天空和海洋。盒子底下只藏着唯一美好的东西：希望，但在希望未飞出之前，潘多拉就将盒子永远关闭了。比喻带来灾难和祸害的东西，或造成灾害的根由。\r\n\r\n72.特洛伊木马：\r\n\r\n古希腊传说，特洛伊王子帕里斯访问希腊，诱走了王后海伦，希腊人因此远征特洛伊。围攻9年后，到第10年，希腊将领奥德修斯献了一计，就是把一批勇士埋伏在一匹巨大的木马腹内，放在城外后，佯作退兵。特洛伊人以为敌兵已退，就把木马作为战利品搬入城中。到了夜间，埋伏在木马中的勇士跳出来，打开了城门，希腊将士一拥而入攻下了城池。后来，人们在写文章时就常用“特洛伊木马”这一典故，用来比喻在敌方营垒里埋下伏兵里应外合的活动。\r\n\r\n73.阿拉丁神灯：\r\n\r\n出自阿拉伯民间故事《一千零一夜》。阿拉丁是苏丹国一个裁缝的儿子，他得到了一盏神灯，只要擦亮神灯，一个自称是神灯的奴隶的巨魔就会出现，它能满足主人的任何要求。比喻能满足人的一切愿望的东西。\r\n\r\n74.波皮利圈子：\r\n\r\n波皮利是古罗马的一位执政官。一次，罗马元老院委派他去说服叙利亚国王安梯丘放弃掠夺来的部分土地。波皮利仗着自己是大国使者，根本不把这位小国之君放在眼里。他在安梯丘座位的周围画了一个圆圈，说：在未答复罗马元老院的要求之前，安梯丘不可走出圈子半步。由此，波皮利圈子一语就被用来比喻因受某种约束而不能逾越的范围。\r\n\r\n75.光轮：\r\n\r\n神话传说中神和英雄头上的圆光。基督教、佛教等借用了光轮，使之成为神像神圣的标志。\r\n\r\n76.象牙塔：\r\n\r\n19世纪法国诗人、文艺批评家圣佩韦。查理。奥古斯丁的书函《致维尔曼》。奥古斯丁批评同时代的法国作家维尼的作品中的悲观消极的情绪，主张作家从庸俗的资产阶级现实超脱出来，进入一种主观幻想的艺术天地——象牙之塔。比喻与世隔绝的梦幻境地。\r\n\r\n77.红十字：\r\n\r\n19世纪和撒丁与奥地利军队发生战争。瑞士人道主义者杜南目睹战争惨状，提出成立一个中立的战地救护组织。1863年日内瓦伤兵救护委员会终于成立。因其发起人和成员都是瑞士人，于是就把红底白十字的瑞典国旗改为白底红十字的新旗帜，作为标志。此后，红十字就成了中立、人道主义和救死扶伤的标志。\r\n\r\n78.红帆：\r\n\r\n出自苏联作家A.格林的同名小说。小说女主人公阿索莉幻想有一位年轻王子驾着一艘升着红帆的船来接她。常用来比喻美好的理想。\r\n\r\n79.大棒加胡萝卜：\r\n\r\n出自美国总统罗斯福1916年5月间的一次演讲。演讲辞中援引了一句非洲谚语来说明他的外交政策：“语言柔和，手持大棒。”后比喻武力恫吓和物质引诱相结合的政策。\r\n\r\n80.多米诺骨牌：\r\n\r\n是一种西洋游戏，将许多长方形的骨牌竖立排列成行，轻轻推倒第1张牌时，其余骨牌将依次纷纷倒下。用于比喻时，多米诺骨牌效应常指一系列的连锁反应，即牵一发而动全身','词汇的含义','','inherit','open','open','','92-revision-v1','','','2013-08-23 13:58:40','2013-08-23 05:58:40','',92,'http://localhost/wordpress-new/?p=93',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (94,1,'2013-08-23 13:58:56','2013-08-23 05:58:56','1、炒菜时，不要加冷水，冷水会使菜变老变硬不好吃，而加开水炒出来的菜又脆又嫩。\r\n2、炒藕丝时，一边炒一边加些水，能防止藕变黑。\r\n3、炒鸡蛋时，一个蛋加一汤匙温水搅匀，就不会炒老，而且炒出的蛋量多，松软可口。\r\n4、豆腐下锅前，可先放在开水里浸渍一刻钟，这样可清除泔水味。\r\n5、用冷水炖鱼无腥味，并应一次加足水，若中途再加水，会冲淡原汁的鲜味。\r\n6、蒸鱼或蒸肉时待蒸锅的水开了以后再上屉，能使鱼或肉外部突然遇到高温蒸气而立即收缩，内部鲜汁不外流，熟后味道鲜美，有光泽。\r\n7、熬骨头汤时，中途切莫加生水，以免汤的温度突然下降导致蛋白质和脂肪迅速凝固，影响营养和味道。\r\n8、煎荷包蛋时，在蛋黄即将凝固之际，可浇上一汤匙冷开水，会使蛋熟后又黄又嫩，色味俱佳。\r\n9、熬猪油时，先在锅内放入少量水，再将切好的猪油放入，这样熬出来的油，颜色晶亮而无杂质。\r\n\r\n生活巧用醋\r\n1、外出容易晕车，如喝下不很酸的食醋水，可以清爽精神，减轻晕车症状。\r\n2、失眠，可将一汤匙食醋倒入冷开水中，搅匀喝下，即可迅速入睡。如果加入等量的蜂蜜，则效果更佳。\r\n3、有人发生昏厥，可把手帕浸过食醋后捂在昏厥者的鼻子上，刺激患者清醒。\r\n4、新购的瓷制餐具、茶具、酒具、放入10%的醋水内煮上两三小时后再用，可除去新瓷器所含的微量铝，避免铝毒危害身体。\r\n5、在烹调水产品蟹、是、海蜇时，先用1%的醋液浸泡一小时，可防止嗜盐杆菌引起的食物中毒。\r\n6、醋煮花生米或黄豆，是高血脂、肥胖症和高血压、冠心病患者的佳肴，具有隆脂、隆压的疗效。\r\n7、宴饮进食，如感胸满腹胀，可用醋50毫升加水至100毫升冲淡服下，增加胃酸，促进消化。\r\n8、饮酒过量已有醉意者，可服50%食醋100至200毫升，解酒毒、养肝肾。\r\n9、餐后的食具，如果使用1%食醋液煮沸消毒，可防止病毒性肝炎、痢疾等传染病。\r\n\r\n醋的妙用\r\n1、醋是家庭烹调的必备调味品。 在醋内加上两滴白酒和一点盐，即可成为香醋。在煮肉或马铃薯时，加上少量醋就容易炖烂，味道亦好。煮甜粥时加点醋，可使甜粥更甜。\r\n2、擦皮鞋时，滴上一滴醋，能使皮鞋光亮持久：铜、铝器用旧了，用醋涂擦后清洗，就能恢复光泽；宰鸡杀鸭前20分钟，给鸡鸭灌上一汤匙醋， 拨毛就变得轻而易举了。\r\n3、玻璃上的油漆，用醋浸软后一擦就掉；丝品洗净后，放在加入少量醋的清水中浸泡几分钟，晾干后光泽如新：毛料衣服磨光的地方，用50%浓度的醋水抹，然后用湿布铺垫熨烫，亮斑即可消失。\r\n4、醋还有消毒杀菌作用。用醋拌的凉菜卫生爽口；用醋蒸熏房间，能杀菌防流感；每天用40%的醋水溶液，加热后洗头可防治脱发，头屑过多；用醋调石灰粉，涂敷腋下，每日二次能治疗狐臭。\r\n赶走烦人的水垢\r\n\r\n残茶的妙用\r\n1、湿茶叶可以取掉容器里的鱼腥味和葱味。\r\n2、可以煮茶叶鸡蛋，其味道清香，非常可口。\r\n3、用残茶叶擦洗有油腻的锅碗、木、竹桌椅，可使该物品更为光洁。\r\n4、把残茶叶晒干，铺撒在潮湿处，能够去潮。\r\n5、残茶叶晒干后，还可以装入枕套充当枕芯，枕之非常柔软。\r\n6、把茶叶撒在地毯或路毯上，再用扫帚拂去，茶叶能带走全部尘土。\r\n7、将残茶叶浸入水中数天后，浇在植物根部，可以促进植物生长。\r\n8、残茶叶还可以喂养刚出的小蚕。\r\n9、把残茶叶晒干，放到厕所或沟渠里燃熏，可消除恶臭，具有驱除蚊绳的功能。\r\n\r\n西瓜皮的妙用\r\n1、削去青皮，将其切成小方快或细丝，加上盐、酱油、糖等佐料，与辣椒同炒，清脆、香甜、可口。\r\n2、将去皮切成的小块或小条的瓜条，入水煮沸，再下入番茄、鸡蛋、些汤不仅味佳色艳，而且能消署利尿。\r\n3、把去皮后的瓜皮切成细长小条，用食盐腌2～3小时后，将盐水沥出，再加酱油、醋或麻油等佐料搅拌，即可食用。\r\n4、将去皮瓜皮、切成薄片，入在碗里，上铺火腿片，加上调料，上锅清蒸，其味鲜美，清香四溢。\r\n\r\n淘米水的妙用\r\n1、用淘米水洗浅色衣服易去污，而且颜色鲜亮。\r\n2、沉淀后的淘米水再加热水，可以用来浆衣服。\r\n3、用淘米水洗手，可用滋润皮肤作用。\r\n4、用淘米水漱口，可以治疗口臭或口腔溃疡。\r\n5、将带腥味的菜，放入加盐的淘米水中搓洗，再用清水冲净，可去腥味。\r\n6、把咸肉放在淘米水里浸泡半天，可去些咸味。\r\n7、用淘米水洗腊肉要比用清水洗得干净。\r\n8、用淘米水洗猪肚，比用盐或骨矾搓洗省劲、省事、且干净、节约。\r\n9、常用淘米水洗泡的菜刀不易生锈。生锈的菜刀泡在淘米水中数小时后，容易擦干净。\r\n10、淘米水浇灌花木或蔬菜，可使其长得更茁壮。\r\n11、用淘米水擦洗后的油漆家具，比较明亮。\r\n12、用淘米水擦拭新漆器，4～5次后，能除去臭味。\r\n\r\n食盐的妙用\r\n1、想让花开得更鲜色，在花盆里浇一点点盐水即可。\r\n2、用盐水洗冻疮可止痒。\r\n3、早上喝一杯淡盐水，有助大便通畅。\r\n4、将盐水搽在被开水烫了的皮肤上，可减轻疼痛。\r\n5、用盐可以擦掉铜器上的黑点。\r\n6、洗澡时，水里放点盐，可治疗皮肤病。\r\n7、用油炸食物时，将一点盐放入油锅内，油就不会向外溅了。\r\n8、煮破了壳的鸡蛋时，水里放点盐，蛋白就不会流出来了。\r\n9、将胡萝卜捣碎拌点盐，可以将衣服上血迹擦掉。\r\n10、为防止洗衣服时衣服褪色，可在水中放些盐。\r\n11、每天早晨嘴里含一含淡盐水，可以清洁口腔，消除口臭，减轻牙龈肿痛出血，帮助治疗牙周炎。\r\n12、洗水果时先把水果表面的污渍揉搓掉，然后把水果浸泡在盐水中，半小时后再冲洗干净，即可放心吃。\r\n13、当嗓子内小舌红肿下垂时，用盐末点治，可减轻喉部不适。\r\n14、用淡盐水和绿茶或菊花洗眼，可以使红肿热痛的急性眼结膜炎很快好转。\r\n15、用盐和辣椒或茄子根一起煮水，浸洗双脚，可以治疗脚气病，对手、脚冻疮也有一定的消肿、止痒作用。 16、用热盐汤浸泡双脚，或用炒盐熨贴腰背，对风湿筋骨病，有一定的止痛作用。\r\n17、有虫蔬菜虽无农药污染，但叶上小虫非常难洗，只要将蔬菜拆叶泡在淡盐水中3-5分钟，虫子便会自动掉入水中。\r\n18、清洗平菇表面的粘稠物时，可将平菇放在淡盐水中浸泡5分钟左右，然后用细软净布沿菇纹轻轻擦洗。\r\n19、夏季豆腐很难保存，但将食盐溶解于水后烧沸，冷却后把豆腐浸放于盐水中却能使豆腐保存很长时间。\r\n20、煎鱼前将鱼放在盐水中洗净，鱼就没有泥土味和腥味。\r\n21、新买的碗碟或玻璃杯先放在盐水中煮过，以后就不易破裂。\r\n22、菜刀用钝后，将刀放在盐水中浸泡半小时左右，然后在磨刀石上边磨边浇盐水，能使刀刃锋利，且经久耐用。\r\n\r\n食盐美容法\r\n1、雪肤洗澡时，用干净的纱布装入适量的细盐，在脸上、颈部及全身上下进行摩擦拍打，约五六分钟即可，可除去已殆的角质皮肤，有助血液循环，使皮肤细嫩白皙。\r\n2、祛斑食盐1份，白蓝粉6份、兰花粉3份、白糖半份，加少话水调成糊状，敷抹于斑处，隔日一次，可使斑色变浅至无。\r\n3、除痘食盐一匙、白醋半匙、开水半小标，溶解后以棉花蘸洗患处，每日一次，连续数日即可见效。经常使用粉刺去无踪。\r\n4、嫩肤食盐15克，杏仁粉100克，加冷水调成糊状敷于面部，每周2—3次，可使肌肤爽滑细润有光泽。\r\n5、美齿每日早晚用淡盐水漱口，或在牙膏上洒上少许精盐，可有效地祛除烟茶垢，预防龋齿发生，使牙齿洁白有光泽。\r\n\r\n牛奶的妙用\r\n1、除鱼腥味-炸鱼前先把鱼浸入牛奶中片刻，既能除腥，又能增强佳味。\r\n2、做冻鱼-在做冻过的鱼时，汤中加些牛奶，会使鱼的味道更鲜。\r\n3、除蒜味-喝杯牛奶，可消除留在口中的大蒜味。\r\n4、去酒迹-如果白衬衣上留下了酒迹，可用煮开的奶擦拭，即可去起污迹。\r\n5、去水果迹-变味的牛奶能去掉花衣服上的水果迹，在痕迹处涂上牛奶，过几小时再用清水洗，就能洗干净。 6、去墨水迹-衣服上沾染了墨水迹，先用清水洗，再用牛奶洗，然后用洗洁精洗，即除。\r\n7、去铁锈-衣服挂在钉子上，或沾到了铁锈，是很难洗得掉的，如果先把有铁锈的地方，用沸水浸湿， 涂上发酸的牛奶，在抹上肥皂，就可洗干净了。\r\n8、消除眼肿-早晨起床眼皮肿了，用牛奶加一点醋和开水混合，然后用棉球蘸着在眼皮上反复擦5分钟，再用热毛巾捂一下，很快就会消肿。\r\n9、使硬鞋油变软-打开的鞋油放久了，会变得发硬而不好再用，如向里面加入几滴鲜牛奶，鞋油就会变软，用起来仍然同新鞋油一样。\r\n10、治轻微烧烫伤-在患处敷上点烧开的牛奶，可迅速消除因烧、烫伤的灼痛。\r\n11、贴标签-要使玻璃上的标签贴得牢，可先将标签放在牛奶中泡一泡。\r\n\r\n不可不知牙膏十大妙用\r\n\r\n1．用布蘸点牙膏擦拭水龙头，可使水龙头光亮如新。\r\n2．用海绵蘸点牙膏刷洗脸盆和浴缸，效果很好。\r\n3．用棉布蘸点牙膏后，轻轻擦拭泛黄的白色家具，可使家具颜色还原如新。\r\n4．用温热的湿抹布将灶台上的焦垢润软，然后用尼龙洗碗布蘸牙膏用力刷洗污垢，再用干净的布擦干净即可。\r\n5．烹调完鱼后，手上仍残留有鱼腥味，不妨在手上挤点牙膏搓洗，鱼腥味便能立刻消除。\r\n6．手上沾了食用油、签字笔油、汽车蜡或机油等难洗的油污，用牙膏搓洗就能清除。\r\n7．衣服的袖口和衣领是比较难洗涤的，用牙膏涂在污处，反复搓洗，效果不同凡响。\r\n8．白球鞋穿久后常会泛黄，先用专用清洗剂处理，再用牙刷一刷，清水冲洗，球鞋便可洁白如新。\r\n9．手电筒的反光屏用得太久了会变黄，将牙膏涂在上面，3～5分钟后，用绸布轻轻擦拭，便可使其光亮如新。\r\n10．如果不经意间身体某部位被烫伤，可以涂抹一些牙膏，减轻疼痛','生活小常识','','publish','open','open','','%e7%94%9f%e6%b4%bb%e5%b0%8f%e5%b8%b8%e8%af%86','','','2013-08-23 13:58:56','2013-08-23 05:58:56','',0,'http://localhost/wordpress-new/?p=94',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (95,1,'2013-08-23 13:58:56','2013-08-23 05:58:56','1、炒菜时，不要加冷水，冷水会使菜变老变硬不好吃，而加开水炒出来的菜又脆又嫩。\r\n2、炒藕丝时，一边炒一边加些水，能防止藕变黑。\r\n3、炒鸡蛋时，一个蛋加一汤匙温水搅匀，就不会炒老，而且炒出的蛋量多，松软可口。\r\n4、豆腐下锅前，可先放在开水里浸渍一刻钟，这样可清除泔水味。\r\n5、用冷水炖鱼无腥味，并应一次加足水，若中途再加水，会冲淡原汁的鲜味。\r\n6、蒸鱼或蒸肉时待蒸锅的水开了以后再上屉，能使鱼或肉外部突然遇到高温蒸气而立即收缩，内部鲜汁不外流，熟后味道鲜美，有光泽。\r\n7、熬骨头汤时，中途切莫加生水，以免汤的温度突然下降导致蛋白质和脂肪迅速凝固，影响营养和味道。\r\n8、煎荷包蛋时，在蛋黄即将凝固之际，可浇上一汤匙冷开水，会使蛋熟后又黄又嫩，色味俱佳。\r\n9、熬猪油时，先在锅内放入少量水，再将切好的猪油放入，这样熬出来的油，颜色晶亮而无杂质。\r\n\r\n生活巧用醋\r\n1、外出容易晕车，如喝下不很酸的食醋水，可以清爽精神，减轻晕车症状。\r\n2、失眠，可将一汤匙食醋倒入冷开水中，搅匀喝下，即可迅速入睡。如果加入等量的蜂蜜，则效果更佳。\r\n3、有人发生昏厥，可把手帕浸过食醋后捂在昏厥者的鼻子上，刺激患者清醒。\r\n4、新购的瓷制餐具、茶具、酒具、放入10%的醋水内煮上两三小时后再用，可除去新瓷器所含的微量铝，避免铝毒危害身体。\r\n5、在烹调水产品蟹、是、海蜇时，先用1%的醋液浸泡一小时，可防止嗜盐杆菌引起的食物中毒。\r\n6、醋煮花生米或黄豆，是高血脂、肥胖症和高血压、冠心病患者的佳肴，具有隆脂、隆压的疗效。\r\n7、宴饮进食，如感胸满腹胀，可用醋50毫升加水至100毫升冲淡服下，增加胃酸，促进消化。\r\n8、饮酒过量已有醉意者，可服50%食醋100至200毫升，解酒毒、养肝肾。\r\n9、餐后的食具，如果使用1%食醋液煮沸消毒，可防止病毒性肝炎、痢疾等传染病。\r\n\r\n醋的妙用\r\n1、醋是家庭烹调的必备调味品。 在醋内加上两滴白酒和一点盐，即可成为香醋。在煮肉或马铃薯时，加上少量醋就容易炖烂，味道亦好。煮甜粥时加点醋，可使甜粥更甜。\r\n2、擦皮鞋时，滴上一滴醋，能使皮鞋光亮持久：铜、铝器用旧了，用醋涂擦后清洗，就能恢复光泽；宰鸡杀鸭前20分钟，给鸡鸭灌上一汤匙醋， 拨毛就变得轻而易举了。\r\n3、玻璃上的油漆，用醋浸软后一擦就掉；丝品洗净后，放在加入少量醋的清水中浸泡几分钟，晾干后光泽如新：毛料衣服磨光的地方，用50%浓度的醋水抹，然后用湿布铺垫熨烫，亮斑即可消失。\r\n4、醋还有消毒杀菌作用。用醋拌的凉菜卫生爽口；用醋蒸熏房间，能杀菌防流感；每天用40%的醋水溶液，加热后洗头可防治脱发，头屑过多；用醋调石灰粉，涂敷腋下，每日二次能治疗狐臭。\r\n赶走烦人的水垢\r\n\r\n残茶的妙用\r\n1、湿茶叶可以取掉容器里的鱼腥味和葱味。\r\n2、可以煮茶叶鸡蛋，其味道清香，非常可口。\r\n3、用残茶叶擦洗有油腻的锅碗、木、竹桌椅，可使该物品更为光洁。\r\n4、把残茶叶晒干，铺撒在潮湿处，能够去潮。\r\n5、残茶叶晒干后，还可以装入枕套充当枕芯，枕之非常柔软。\r\n6、把茶叶撒在地毯或路毯上，再用扫帚拂去，茶叶能带走全部尘土。\r\n7、将残茶叶浸入水中数天后，浇在植物根部，可以促进植物生长。\r\n8、残茶叶还可以喂养刚出的小蚕。\r\n9、把残茶叶晒干，放到厕所或沟渠里燃熏，可消除恶臭，具有驱除蚊绳的功能。\r\n\r\n西瓜皮的妙用\r\n1、削去青皮，将其切成小方快或细丝，加上盐、酱油、糖等佐料，与辣椒同炒，清脆、香甜、可口。\r\n2、将去皮切成的小块或小条的瓜条，入水煮沸，再下入番茄、鸡蛋、些汤不仅味佳色艳，而且能消署利尿。\r\n3、把去皮后的瓜皮切成细长小条，用食盐腌2～3小时后，将盐水沥出，再加酱油、醋或麻油等佐料搅拌，即可食用。\r\n4、将去皮瓜皮、切成薄片，入在碗里，上铺火腿片，加上调料，上锅清蒸，其味鲜美，清香四溢。\r\n\r\n淘米水的妙用\r\n1、用淘米水洗浅色衣服易去污，而且颜色鲜亮。\r\n2、沉淀后的淘米水再加热水，可以用来浆衣服。\r\n3、用淘米水洗手，可用滋润皮肤作用。\r\n4、用淘米水漱口，可以治疗口臭或口腔溃疡。\r\n5、将带腥味的菜，放入加盐的淘米水中搓洗，再用清水冲净，可去腥味。\r\n6、把咸肉放在淘米水里浸泡半天，可去些咸味。\r\n7、用淘米水洗腊肉要比用清水洗得干净。\r\n8、用淘米水洗猪肚，比用盐或骨矾搓洗省劲、省事、且干净、节约。\r\n9、常用淘米水洗泡的菜刀不易生锈。生锈的菜刀泡在淘米水中数小时后，容易擦干净。\r\n10、淘米水浇灌花木或蔬菜，可使其长得更茁壮。\r\n11、用淘米水擦洗后的油漆家具，比较明亮。\r\n12、用淘米水擦拭新漆器，4～5次后，能除去臭味。\r\n\r\n食盐的妙用\r\n1、想让花开得更鲜色，在花盆里浇一点点盐水即可。\r\n2、用盐水洗冻疮可止痒。\r\n3、早上喝一杯淡盐水，有助大便通畅。\r\n4、将盐水搽在被开水烫了的皮肤上，可减轻疼痛。\r\n5、用盐可以擦掉铜器上的黑点。\r\n6、洗澡时，水里放点盐，可治疗皮肤病。\r\n7、用油炸食物时，将一点盐放入油锅内，油就不会向外溅了。\r\n8、煮破了壳的鸡蛋时，水里放点盐，蛋白就不会流出来了。\r\n9、将胡萝卜捣碎拌点盐，可以将衣服上血迹擦掉。\r\n10、为防止洗衣服时衣服褪色，可在水中放些盐。\r\n11、每天早晨嘴里含一含淡盐水，可以清洁口腔，消除口臭，减轻牙龈肿痛出血，帮助治疗牙周炎。\r\n12、洗水果时先把水果表面的污渍揉搓掉，然后把水果浸泡在盐水中，半小时后再冲洗干净，即可放心吃。\r\n13、当嗓子内小舌红肿下垂时，用盐末点治，可减轻喉部不适。\r\n14、用淡盐水和绿茶或菊花洗眼，可以使红肿热痛的急性眼结膜炎很快好转。\r\n15、用盐和辣椒或茄子根一起煮水，浸洗双脚，可以治疗脚气病，对手、脚冻疮也有一定的消肿、止痒作用。 16、用热盐汤浸泡双脚，或用炒盐熨贴腰背，对风湿筋骨病，有一定的止痛作用。\r\n17、有虫蔬菜虽无农药污染，但叶上小虫非常难洗，只要将蔬菜拆叶泡在淡盐水中3-5分钟，虫子便会自动掉入水中。\r\n18、清洗平菇表面的粘稠物时，可将平菇放在淡盐水中浸泡5分钟左右，然后用细软净布沿菇纹轻轻擦洗。\r\n19、夏季豆腐很难保存，但将食盐溶解于水后烧沸，冷却后把豆腐浸放于盐水中却能使豆腐保存很长时间。\r\n20、煎鱼前将鱼放在盐水中洗净，鱼就没有泥土味和腥味。\r\n21、新买的碗碟或玻璃杯先放在盐水中煮过，以后就不易破裂。\r\n22、菜刀用钝后，将刀放在盐水中浸泡半小时左右，然后在磨刀石上边磨边浇盐水，能使刀刃锋利，且经久耐用。\r\n\r\n食盐美容法\r\n1、雪肤洗澡时，用干净的纱布装入适量的细盐，在脸上、颈部及全身上下进行摩擦拍打，约五六分钟即可，可除去已殆的角质皮肤，有助血液循环，使皮肤细嫩白皙。\r\n2、祛斑食盐1份，白蓝粉6份、兰花粉3份、白糖半份，加少话水调成糊状，敷抹于斑处，隔日一次，可使斑色变浅至无。\r\n3、除痘食盐一匙、白醋半匙、开水半小标，溶解后以棉花蘸洗患处，每日一次，连续数日即可见效。经常使用粉刺去无踪。\r\n4、嫩肤食盐15克，杏仁粉100克，加冷水调成糊状敷于面部，每周2—3次，可使肌肤爽滑细润有光泽。\r\n5、美齿每日早晚用淡盐水漱口，或在牙膏上洒上少许精盐，可有效地祛除烟茶垢，预防龋齿发生，使牙齿洁白有光泽。\r\n\r\n牛奶的妙用\r\n1、除鱼腥味-炸鱼前先把鱼浸入牛奶中片刻，既能除腥，又能增强佳味。\r\n2、做冻鱼-在做冻过的鱼时，汤中加些牛奶，会使鱼的味道更鲜。\r\n3、除蒜味-喝杯牛奶，可消除留在口中的大蒜味。\r\n4、去酒迹-如果白衬衣上留下了酒迹，可用煮开的奶擦拭，即可去起污迹。\r\n5、去水果迹-变味的牛奶能去掉花衣服上的水果迹，在痕迹处涂上牛奶，过几小时再用清水洗，就能洗干净。 6、去墨水迹-衣服上沾染了墨水迹，先用清水洗，再用牛奶洗，然后用洗洁精洗，即除。\r\n7、去铁锈-衣服挂在钉子上，或沾到了铁锈，是很难洗得掉的，如果先把有铁锈的地方，用沸水浸湿， 涂上发酸的牛奶，在抹上肥皂，就可洗干净了。\r\n8、消除眼肿-早晨起床眼皮肿了，用牛奶加一点醋和开水混合，然后用棉球蘸着在眼皮上反复擦5分钟，再用热毛巾捂一下，很快就会消肿。\r\n9、使硬鞋油变软-打开的鞋油放久了，会变得发硬而不好再用，如向里面加入几滴鲜牛奶，鞋油就会变软，用起来仍然同新鞋油一样。\r\n10、治轻微烧烫伤-在患处敷上点烧开的牛奶，可迅速消除因烧、烫伤的灼痛。\r\n11、贴标签-要使玻璃上的标签贴得牢，可先将标签放在牛奶中泡一泡。\r\n\r\n不可不知牙膏十大妙用\r\n\r\n1．用布蘸点牙膏擦拭水龙头，可使水龙头光亮如新。\r\n2．用海绵蘸点牙膏刷洗脸盆和浴缸，效果很好。\r\n3．用棉布蘸点牙膏后，轻轻擦拭泛黄的白色家具，可使家具颜色还原如新。\r\n4．用温热的湿抹布将灶台上的焦垢润软，然后用尼龙洗碗布蘸牙膏用力刷洗污垢，再用干净的布擦干净即可。\r\n5．烹调完鱼后，手上仍残留有鱼腥味，不妨在手上挤点牙膏搓洗，鱼腥味便能立刻消除。\r\n6．手上沾了食用油、签字笔油、汽车蜡或机油等难洗的油污，用牙膏搓洗就能清除。\r\n7．衣服的袖口和衣领是比较难洗涤的，用牙膏涂在污处，反复搓洗，效果不同凡响。\r\n8．白球鞋穿久后常会泛黄，先用专用清洗剂处理，再用牙刷一刷，清水冲洗，球鞋便可洁白如新。\r\n9．手电筒的反光屏用得太久了会变黄，将牙膏涂在上面，3～5分钟后，用绸布轻轻擦拭，便可使其光亮如新。\r\n10．如果不经意间身体某部位被烫伤，可以涂抹一些牙膏，减轻疼痛','生活小常识','','inherit','open','open','','94-revision-v1','','','2013-08-23 13:58:56','2013-08-23 05:58:56','',94,'http://localhost/wordpress-new/?p=95',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (96,1,'2013-08-23 13:59:13','2013-08-23 05:59:13','做菜时你绝对不知道的123个门道（不转载就会亏了）判官\r\n\r\n1、炒菜时应先把锅烧热，再倒入食油，然后再放菜。\r\n\r\n2、煮牛肉：为了使牛肉炖得快，炖得烂，加一小撮茶叶(约为泡一壶茶的量，用纱布包好)同煮，肉很快就烂且味道鲜美。\r\n\r\n3、煮骨头汤时加一小匙醋，可使骨头中的磷、钙溶解于汤中，并可保存汤中的维生素。\r\n\r\n4、煮牛肉和其他韧、硬肉类以及野味禽类时，加点醋可使其软化。\r\n\r\n5、煮肉汤或排骨汤时，放入几块新鲜桔皮，不仅味道鲜美，还可减少油腻感。\r\n\r\n6、煮咸肉：用十几个钻有许多小孔的核桃同煮，可消除臭味。\r\n\r\n7、煮绿豆[/url]：将绿豆在铁锅中炒10分钟再煮能很快煮烂，但注意不要炒焦。\r\n\r\n8、煮蛋时水里加点醋可防蛋壳裂开，事先加点盐也可。\r\n\r\n9、煮海带时加几滴醋易烂；放几棵波菜也行。\r\n\r\n10、煮火腿之前，将火腿皮上涂些白糖，容易煮烂，味道更鲜美。\r\n\r\n11、煮水饺时，在水里放一颗大葱或在水开后加点盐，再放饺子，饺子味道鲜美不粘连；在和面时，每500克面粉加拌一个鸡蛋，饺子皮挺刮不粘连。\r\n\r\n12、煮水饺时，在锅中加少许食盐，锅开时水也不外溢。\r\n\r\n13、煮面条时加一小汤匙食油，面条不会沾连，并可防止面汤起泡沫、溢出锅外。\r\n\r\n14、煮面条时，在锅中加少许食盐，煮出的面条不易烂糊。\r\n\r\n15、熬粥或煮豆时不要放碱，否则会破坏米、豆中的营养物质。\r\n\r\n16、用开水煮新笋容易熟，且松脆可口；要使笋煮后不缩小，可加几片薄荷叶或盐。\r\n\r\n17、煮猪肚：猪肚煮熟后，切成长块，放在碗内加一些鲜汤再蒸一会儿，猪肚便会加厚一倍。\r\n\r\n18、煮猪肚时，千万不能先放盐，等煮熟后吃时再放盐，否则猪肚会缩得象牛筋一样硬。\r\n\r\n19、炖肉时，在锅里加上几块桔皮，可除异味和油腻并增加汤的鲜味。\r\n\r\n20、炖鸡：洗净切块，倒入热油锅内翻炒，待水分炒干时，倒入适量香醋，再迅速翻炒，至鸡块发出劈劈啪啪的爆响声时，立即 加热水（没过鸡块），再用旺火烧十分钟，即可放入调料，移小火上再炖20分钟，淋上香油即可出锅；应在汤炖好后，温度降至80～90摄氏度时或食用前加盐。因为鸡肉中含水分较高，炖鸡先加盐，鸡肉在盐水中浸泡，组织细胞内水分向外渗透，蛋白质产生凝固作用，使鸡肉明显收缩变紧，影响营养向汤内溶解，且煮熟后的鸡肉趋向硬、老，口感粗糙。\r\n\r\n21、炖老鸡：在锅内加二三十颗黄豆同炖，熟得快且味道鲜；或在杀老鸡之前，先灌给鸡一汤匙食醋，然后再杀，用文火煮炖，就会煮得烂熟；或放３～４枚山楂，鸡肉易烂。\r\n\r\n22、煮老鸡鸭：老鸡鸭用猛火煮，肉硬不好吃；如果先用凉水和少许食醋泡上２小时，再用微火炖，肉就会变得香嫩可口。\r\n\r\n23、煮老鸭：在锅里放几个田螺容易烂熟。\r\n\r\n24、烧鸭子时，把鸭子尾端两侧的臊豆去掉，味道更美。\r\n\r\n25、烧豆腐时，加少许豆腐乳或汁，味道芳香。\r\n\r\n26、红烧牛肉时，加少许雪里红，肉味鲜美。\r\n\r\n27、做红烧肉前，先用少许硼砂把肉腌一下，烧出来的肉肥而不腻，甘香可口。\r\n\r\n28、油炸食物时，锅里放少许食盐，油不会外溅。\r\n\r\n29、在春卷的拌馅中适量加些面粉，能避免炸制过程中馅内菜汁流出糊锅底的现象。\r\n\r\n30、炸土豆之前，先把切好的土豆片放在水里煮一会儿，使土豆皮的表面形成一层薄薄的胶质层，然后再用油炸。\r\n\r\n31、炸猪排时，在有筋的地方割２～３个切口，炸出来的猪排就不会收缩。\r\n\r\n32、炸鸡肉：将鸡肉先腌一会儿，封上护膜放入冰箱，待炸时再取出，炸出的鸡肉酥脆可口。\r\n\r\n33、煎荷包蛋时，在蛋黄即将凝固之际浇一点冷开水，会使蛋又黄又嫩。\r\n\r\n34、煎鸡蛋时，在平底锅放足油，油微热时蛋下锅，鸡蛋慢慢变熟，外观美，不粘锅。\r\n\r\n35、煎鸡蛋时，在热油中撒点面粉，蛋会煎得黄亮好看，油也不易溅出锅外。\r\n\r\n36、羊油炒蛋：用羊油炒鸡蛋，味香无异味。\r\n\r\n37、炒鸡蛋时加入少量的砂糖，会使蛋白质变性的凝固温度上升，从而延缓了加热时间，加上砂糖具有保水性，因而可使蛋制品变得膨松柔软。\r\n\r\n38、炒鸡蛋时加入几滴醋，炒出的蛋松软味香。\r\n\r\n39、炒茄子时，在锅里放点醋，炒出的茄子颜色不会变黑。\r\n\r\n40、炒土豆时加醋，可避免烧焦，又可分解土豆中的毒素，并使色、味相宜。\r\n\r\n41、炒豆芽时，先加点黄油，然后再放盐，能去掉豆腥味。\r\n\r\n42、炒波菜时不宜加盖。\r\n\r\n43、炒肉片：肉切成薄片加酱油、黄油、淀粉，打入一个鸡蛋，拌匀，炒散；等肉片变色后，再加佐料稍炒几下，肉片味美、鲜嫩。\r\n\r\n44、炒牛肉丝：切好，用盐、糖、酒、生粉（或鸡蛋）拌一下，加上生油泡腌，30分钟后再炒，鲜嫩可口 。\r\n\r\n45、炒肉菜时放盐过早熟得慢，宜在将熟时加盐，在出锅前再加上几滴醋，鲜嫩可口。\r\n\r\n46、炒肉丝：肉丝切好后放在小苏打溶液里浸一下再炒，特别疏松可口，不论做什么糖醋菜肴，只要按２份糖１份醋的比例调配，便可做到甜酸适度。\r\n\r\n47、炒糖醋鱼、糖醋菜帮等，应先放糖，后放盐，否则食盐的“脱水”作用会促进菜肴中蛋白质凝固而“吃”不进糖分，造成外甜里淡。\r\n\r\n２\r\n\r\n48、做肉饼和肉丸子时，一公斤肉馅放2小匙盐。\r\n\r\n49、做丸子按50克肉10克淀粉的比例调制，成菜软嫩。\r\n\r\n50、做滑炒肉片或辣子肉丁，按50克肉５克淀粉的比例上浆，成菜鲜嫩味美。\r\n\r\n51、做馒头时，如果在发面里揉进一小块猪油，蒸出来的馒头不仅洁白、松软，而且味香。\r\n\r\n52、蒸馒头时掺入少许桔皮丝，可使馒头增加清香。\r\n\r\n53、蒸馒头碱放多了起黄，如在原蒸锅水里加醋２～３汤匙，再蒸10～15分钟可变白。\r\n\r\n54、蒸煮红薯：将少量明矾和食盐放入清水中，把切开的生红薯浸入十几分钟，洗净后蒸煮，可防止或减轻腹胀。\r\n\r\n55、煮牛奶：牛奶煮糊了，放点盐，冷却后味道更好。\r\n\r\n56、放有辣椒的菜太辣时或炒辣椒时加点醋，辣味大减。\r\n\r\n57、烹调时，放酱油若错倒了食醋，可撒放少许小苏打，醋味即可消除。\r\n\r\n58、菜太酸，将一只松花蛋捣烂放入。\r\n\r\n59、菜太辣，放一只鸡蛋同炒。\r\n\r\n60、菜太辣，放些醋可减低辣味。\r\n\r\n61、菜太苦，滴入少许白醋。\r\n\r\n62、汤太咸又不宜兑水时，可放几块豆腐或土豆或几片蕃茄到汤中；也可将一把米或面粉用布包起来放入汤中。\r\n\r\n63、汤太腻，将少量紫菜在火上烤一下，然后撒入汤中。\r\n\r\n64、花生米用油炸熟，盛入盘中，趁热撒上少许白酒，稍凉后再撒上少许食盐，放置几天几夜都稣脆如初 。\r\n\r\n65、菜籽油有一股异味，可把油烧热后投入适量生姜、蒜、葱、丁香、陈皮同炸片刻，油即可变香。66、用菜油炸一次花生米就没有怪味了，炒出的菜肴香味可口，并可做凉拌菜。\r\n\r\n67、炸完食物后的油留下一些残渣并变得混浊，可将白萝卜切成厚圆片，用筷子把萝卜戳几个洞，放入剩油中炸，残渣会附着在萝卜片上，取出清除残渣，再反复放入锅中炸，混浊的油可变清澈。\r\n\r\n68、当锅内温度达到最高时加入料酒，易使酒蒸发而去除食物中的腥味。\r\n\r\n69、熬猪油：在电饭褒内放一点水或植物油，然后放入猪板油或肥肉，接通电源后，能自动将油炼好，不溅油，不糊油渣，油质清纯。\r\n\r\n70、泡菜坛中放十几粒花椒或少许麦芽糖，可防止产生白花。\r\n\r\n71、开水点菜质增色佳妙青菜时，应用开水点菜，这样炒出的菜，质嫩色佳。若用水点菜，影响脆口。\r\n\r\n72、炒菜巧下盐如果你用动物油炒菜，最好在放菜前下盐，这样可减少动物油中有机氯的残余量，对人体有利。如果用花生油炒菜，也必须在放菜前下盐，这是因为花生油中可能会含有黄曲霉菌，而盐中的碘化物，可以除去这种有害物质。为了使炒菜可口，开始可先少放些盐，菜熟后再调味。如果用豆油、茶油或菜油，应先放菜、后下盐，这样可以减少蔬菜中营养成分的损失。\r\n\r\n73、糖醋汁配比不论做什么糖醋菜看，只要按2份糖、1份醋的比例调配，便可收到甜酸适度的效果。\r\n\r\n74、拔丝糖浆的熬制在熬制拔丝菜糖浆时，每盘加入一粒米大的明矾，能延长结时间，并使糖丝拉得更长。\r\n\r\n75、菜肴放醋的讲究凡需要加醋的热菜，在起锅前将醋沿锅边淋入，比直接淋上香味更加醇厚浓郁。\r\n\r\n76、啤酒调味剂：夏季做各种凉拌菜时，加适量啤酒调拌，可提味增香。\r\n\r\n77、葡萄酒做沙拉：葡萄酒开瓶后，若存放过久，就会变成“醋”。具有芳香味，用来做沙拉非常好吃。\r\n\r\n78、用盐洗菜保洁清洗青菜时，在清水里撤一些盐，这样可把蔬菜里的虫子清洗出来。\r\n\r\n79、洗切蔬菜防营养流失菠菜、白菜等蔬菜要先洗后切，不要切碎了再洗。否则，营养素会流失太多。\r\n\r\n80、盐可使蔬菜黄叶返绿菠菜等青菜的叶，如果有些(轻度)变黄，焯时效一点盐，颜色能由黄返绿。\r\n\r\n81、牛奶菜花更白嫩炒菜花时，加1匙牛奶，会使成品更加白嫩可口。\r\n\r\n82、凉拌西红柿宜放盐。用糖凉拌西红柿时，放少许盐会更甜，因为盐能改变西红柿的酸糖比。\r\n\r\n83、膀豆角新法：选择早晨采摘的新鲜脆嫩的豆角，直接加入适量的盐，在盛器内轻揉，待手感潮湿之后，再入缸(注意避免破损或虫蛀的豆角混入)，层层压紧、压实，并撤上少量盐，加净石压顶层，封口。此法是直接利用豆角本身汁水腌浸，不另加水，避免豆角在水中变腐。成品味正、色泽黄亮、口感松脆，可贮存1年以上。\r\n\r\n84、腌泡菜除霉花腌制泡菜时容易生霉花(白膜)。可取干蚕豆250克；炒熟放凉后，用纱布包好放入坛内，第2天取出。这样，就可钢底除去白膜，蚕豆加工后，还是下酒的好菜。\r\n\r\n85、芥末做泡菜做泡菜时，加上点芥末、芹菜屑和鱿鱼屑，可使泡菜色、味俱佳。\r\n\r\n86、切辣椒、葱防刺限切辣椒和葱时，眼睛往往被辣得流泪、难受。如果把菜放冰箱冷冻一下再切，或者先将菜刀在凉水里浸一下再切，也可在菜板旁放一盆凉水，刀边蘸水边切，均可有效地减轻辣味的散发，使眼睛不受刺激。\r\n\r\n87、炒辣椒减辣味法：辣椒辣味太浓，烹制时将辣椒切成细末或丁，先用油、盐煽熟，再倒入一个鲜鸡蛋液，炒成“蛋包椒丁”，辣味可大大减轻。\r\n\r\n88、鲜姜保存：鲜姜埋在经常保持湿润的黄沙里，随用随取，能保存较长时间不坏。\r\n\r\n89、芥末辣味的去除芥末用水调匀(稠膏状)，盛在容器里，放到火炉上烤，或上笼屉稍蒸一下，可除去部分辣味。\r\n\r\n90、麦饭石泡菜易存放用麦饭石水浸泡蔬菜、瓜果，置于阴凉处，可延长存放时间1倍以上。\r\n\r\n91、汤过咸处置三法如果汤做得太咸，用纱布包一些煮熟了的大米饭放进去，朗吸收盐分，减轻咸味。汤过咸，可切几块马铃薯片下锅一起煮，立即捞起，汤就不那么咸了。汤太咸，可放几块豆腐或番茄片同煮，其减咸功效与放土豆同。\r\n\r\n92、紫菜可除汤中油腻汤过于油腻时，可将少量紫菜置于火上烤一下，然后撒入汤内，可减少油腻感。\r\n\r\n93、菜过威处理三法：菜咸了，可加适量白糖，即可解盐。菜咸了，放些醋，咸味会大大减少。菜咸了，用掺有白酒的水浸泡，有明显的去咸效果。\r\n\r\n94、牛奶可谈化酱汁炒菜时，如果调味酱汁放多了，加上少许牛奶，能调和菜的味道。\r\n\r\n95、酒可解酸：醋放多了，可在菜里加一些米酒，可以减轻酸味。\r\n\r\n96、腌菜咸辣味的谈化腌渍小菜，如过咸或过辣时，可将小菜切好后浸在50%的酒水里，能冲淡咸味或辣味，且味道更鲜美。\r\n\r\n97、.除蔬菜的苦涩味萝卜、苦瓜等带有苦涩味的蔬菜，切好后加少量盐渍一下，滤出汁水再烧，苦涩味会明显减少。菠菜在开水中烫后再炒，可去苦涩味和草酸。\r\n\r\n98、冰冻“萝卜干”把切好的萝卜先放在冰箱里冷冻一段时间，再拿出来置阳光下晒干，就成了可以久存且风味独特的：萝卜干，烧肉时放上一些，味道极好。\r\n\r\n99、除去萝卜异味蒸吃萝卜，应该先将其切碎，按300：1的比例放入食醋，再上锅蒸，就可使异味消失。\r\n\r\n100、萝卜贮藏三法：土坑贮藏法：将新鲜的萝卜削去项，去毛根，严格剔除带有虫伤，机械伤，裂口和过小的萝卜。挖一个l米深，1米见方的土坑，路萝卜根朝上，顶朝下，斜靠坑壁，按顺序码紧。码齐一层萝卜，撤上一层10厘米左右厚的净土，如此交替码放，共码四层。若坑土过于，可适当喷水湿润。最上一层码好后，要根据气候变化逐渐加厚土壤层，天暖少覆土，来强寒流时多覆土，小寒前后覆土完毕，土厚共1米。质量好的萝卜，入坑前不受热，入坑后不受冻，能贮存到来年三月上旬。泥浆贮藏法把萝卜削顶，放到黄泥浆中滚一圈，使萝菠萝卜结一层泥壳，堆放到明凉的地方即可。如果在萝卜堆外再培一层湿土，效果更好。水缸外贮藏法。在室内放一水缸，里面装满水，把萝卜堆放在缸的周围，上面再培15厘米厚的湿土即可。\r\n\r\n101、去皮萝卜的保鲜去皮的胡萝卜，最好放在干燥的器皿中，上盖湿布，但保存时间不要超过3个小时。\r\n\r\n102、食品袋贮藏大白菜若没有菜窖，冬天贮菜采用无毒塑料袋保存，可收到较好的效果。如果室内温度过低，可把食品袋从蔬菜的根部套上去，然后把上口扎上。如果温度在思氏零度以上，可从白菜叶上套上塑料袋，口不用扎，根朝下戳在地上即可。\r\n\r\n103、蒜黄、韭菜的保鲜：买来的蒜黄、青韭、青蒜等青菜，一时吃不完，可用带帮的大白菜叶子把它包捆好，放在阴凉处，不要着水，能保存一段时间不坏。\r\n\r\n104、冻洋葱复鲜：把冷冻过的洋葱放在清水中浸泡；可使洋葱复鲜。\r\n\r\n105、炒洋葱宜放面扮、葡萄酒切好的洋葱蘸点干面粉，炒熟后色泽金黄；质地脆嫩，味美可口；炒洋葱时，加少许白葡萄酒，则不易炒焦。\r\n\r\n106、加工芋头防刺激皮肤剥刮芋头皮时，易使手部皮肤发痒，若将手放在炉火上烘烤一下，或在水中加几滴醋洗一下，即可消痒。搽一点风油精也有效果。\r\n\r\n107、清水抄藕洁白炒藕丝时，往往会变黑，如能边炒边加些清水，就会保持成品洁白。\r\n\r\n108、加工茄子防氧化茄子切开后，应立即浸入水中，否则茄子会被氧化成褐色。\r\n\r\n109、新土豆去皮法把新土豆放入热水浸泡一下，再倒入冷水中，很容易去皮。\r\n\r\n110、土豆去皮越薄越好土豆皮含有较丰富的营养物质；去皮不宜厚。土豆一旦去皮，要存放在冷水中，再向水中滴几滴醋；可使土豆洁白。\r\n\r\n111、做土豆放奶味道好白水煮土豆时，加一点牛奶，不但味道好，也可防止土豆肉质发黄。\r\n\r\n112、烧土豆要后加盐再升温烧土豆时，待变色后再加盐升温。否则；土豆会形成硬皮，的汁液与油混在一起，成菜易碎，影响色香味。\r\n\r\n113、冻土豆怪味的去除先将冻土豆放入冷水中浸泡，再放入加有1汤匙食醋的沸水中，慢慢冷却后，再行制菜。这样烧出的土豆就没有怪味了。\r\n\r\n114、土豆戒红薯土豆不能与红薯存放在一起。否则，不是红薯僵心，便是土豆发芽。\r\n\r\n115、淘米水发于菜效果好用淘米水泡发海带、干菜等于货，易发涨，烹制时易烂。\r\n\r\n116、干海带蒸后再烹好把于海带上锅蒸半个小时，取出后用碱面搓一遍，用清水泡2—3小时再烹制，无论做菜煮汤，都脆嫩可口，且没有海腥味。\r\n\r\n117、煮海带易烂法煮海带时，适当加点碱或小苏打，或者在锅里放适量食醋，易使海带变软；若放几棵菠菜，海带易烂。\r\n\r\n118、泡发木耳二法用烧开的米汤泡发木耳，能使木耳肥大，松软，味道鲜美。用凉水泡发木耳，可使其脆嫩爽口。\r\n\r\n119、木耳泥沙的清洗黑木耳易粘上木渣和泥沙，可用盐水(盐约为于木耳重的洗，轻轻揉匀，待水变浑，即可用清水淘洗。\r\n\r\n120、巧渍蘑菇在1公斤的温水中，加糖25克，把洗净的蘑菇切好浸入泡12个小时。泡蘑菇加糖，既能使蘑菇吃水快，保持香味，又因蘑菇中浸入了糖液，烧好后味道更加鲜美。\r\n\r\n121、蘑菇挑选法有毒蘑菇的特征是，色泽鲜艳好看，采回后容易变色，挤出的浆汁混浊如牛奶。无毒蘑菇多为白色、浅棕色、旧纸色，挤出的浆汁清澈如水。\r\n\r\n122、黄花菜的烹前加工鲜黄花菜(金针菜)中含有秋水仙碱，在人体内被氧化成为氧化二秋水仙碱，有剧毒。因此，要用开水烫后浸泡，除去汁水，彻底炒熟才能吃。\r\n\r\n123、笋干的涨发先将笋干放在铁锅内，加满水煮沸30分钟，再转小火焖煮，捞出，切除老根，洗净。然后浸泡在淘米水或石灰水中待用，隔2—3天换1次水，烹调前切成片状，食之鲜嫩味美。','做菜时你绝对不知道的123个门道','','publish','open','open','','%e5%81%9a%e8%8f%9c%e6%97%b6%e4%bd%a0%e7%bb%9d%e5%af%b9%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84123%e4%b8%aa%e9%97%a8%e9%81%93','','','2013-08-23 13:59:13','2013-08-23 05:59:13','',0,'http://localhost/wordpress-new/?p=96',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (97,1,'2013-08-23 13:59:13','2013-08-23 05:59:13','做菜时你绝对不知道的123个门道（不转载就会亏了）判官\r\n\r\n1、炒菜时应先把锅烧热，再倒入食油，然后再放菜。\r\n\r\n2、煮牛肉：为了使牛肉炖得快，炖得烂，加一小撮茶叶(约为泡一壶茶的量，用纱布包好)同煮，肉很快就烂且味道鲜美。\r\n\r\n3、煮骨头汤时加一小匙醋，可使骨头中的磷、钙溶解于汤中，并可保存汤中的维生素。\r\n\r\n4、煮牛肉和其他韧、硬肉类以及野味禽类时，加点醋可使其软化。\r\n\r\n5、煮肉汤或排骨汤时，放入几块新鲜桔皮，不仅味道鲜美，还可减少油腻感。\r\n\r\n6、煮咸肉：用十几个钻有许多小孔的核桃同煮，可消除臭味。\r\n\r\n7、煮绿豆[/url]：将绿豆在铁锅中炒10分钟再煮能很快煮烂，但注意不要炒焦。\r\n\r\n8、煮蛋时水里加点醋可防蛋壳裂开，事先加点盐也可。\r\n\r\n9、煮海带时加几滴醋易烂；放几棵波菜也行。\r\n\r\n10、煮火腿之前，将火腿皮上涂些白糖，容易煮烂，味道更鲜美。\r\n\r\n11、煮水饺时，在水里放一颗大葱或在水开后加点盐，再放饺子，饺子味道鲜美不粘连；在和面时，每500克面粉加拌一个鸡蛋，饺子皮挺刮不粘连。\r\n\r\n12、煮水饺时，在锅中加少许食盐，锅开时水也不外溢。\r\n\r\n13、煮面条时加一小汤匙食油，面条不会沾连，并可防止面汤起泡沫、溢出锅外。\r\n\r\n14、煮面条时，在锅中加少许食盐，煮出的面条不易烂糊。\r\n\r\n15、熬粥或煮豆时不要放碱，否则会破坏米、豆中的营养物质。\r\n\r\n16、用开水煮新笋容易熟，且松脆可口；要使笋煮后不缩小，可加几片薄荷叶或盐。\r\n\r\n17、煮猪肚：猪肚煮熟后，切成长块，放在碗内加一些鲜汤再蒸一会儿，猪肚便会加厚一倍。\r\n\r\n18、煮猪肚时，千万不能先放盐，等煮熟后吃时再放盐，否则猪肚会缩得象牛筋一样硬。\r\n\r\n19、炖肉时，在锅里加上几块桔皮，可除异味和油腻并增加汤的鲜味。\r\n\r\n20、炖鸡：洗净切块，倒入热油锅内翻炒，待水分炒干时，倒入适量香醋，再迅速翻炒，至鸡块发出劈劈啪啪的爆响声时，立即 加热水（没过鸡块），再用旺火烧十分钟，即可放入调料，移小火上再炖20分钟，淋上香油即可出锅；应在汤炖好后，温度降至80～90摄氏度时或食用前加盐。因为鸡肉中含水分较高，炖鸡先加盐，鸡肉在盐水中浸泡，组织细胞内水分向外渗透，蛋白质产生凝固作用，使鸡肉明显收缩变紧，影响营养向汤内溶解，且煮熟后的鸡肉趋向硬、老，口感粗糙。\r\n\r\n21、炖老鸡：在锅内加二三十颗黄豆同炖，熟得快且味道鲜；或在杀老鸡之前，先灌给鸡一汤匙食醋，然后再杀，用文火煮炖，就会煮得烂熟；或放３～４枚山楂，鸡肉易烂。\r\n\r\n22、煮老鸡鸭：老鸡鸭用猛火煮，肉硬不好吃；如果先用凉水和少许食醋泡上２小时，再用微火炖，肉就会变得香嫩可口。\r\n\r\n23、煮老鸭：在锅里放几个田螺容易烂熟。\r\n\r\n24、烧鸭子时，把鸭子尾端两侧的臊豆去掉，味道更美。\r\n\r\n25、烧豆腐时，加少许豆腐乳或汁，味道芳香。\r\n\r\n26、红烧牛肉时，加少许雪里红，肉味鲜美。\r\n\r\n27、做红烧肉前，先用少许硼砂把肉腌一下，烧出来的肉肥而不腻，甘香可口。\r\n\r\n28、油炸食物时，锅里放少许食盐，油不会外溅。\r\n\r\n29、在春卷的拌馅中适量加些面粉，能避免炸制过程中馅内菜汁流出糊锅底的现象。\r\n\r\n30、炸土豆之前，先把切好的土豆片放在水里煮一会儿，使土豆皮的表面形成一层薄薄的胶质层，然后再用油炸。\r\n\r\n31、炸猪排时，在有筋的地方割２～３个切口，炸出来的猪排就不会收缩。\r\n\r\n32、炸鸡肉：将鸡肉先腌一会儿，封上护膜放入冰箱，待炸时再取出，炸出的鸡肉酥脆可口。\r\n\r\n33、煎荷包蛋时，在蛋黄即将凝固之际浇一点冷开水，会使蛋又黄又嫩。\r\n\r\n34、煎鸡蛋时，在平底锅放足油，油微热时蛋下锅，鸡蛋慢慢变熟，外观美，不粘锅。\r\n\r\n35、煎鸡蛋时，在热油中撒点面粉，蛋会煎得黄亮好看，油也不易溅出锅外。\r\n\r\n36、羊油炒蛋：用羊油炒鸡蛋，味香无异味。\r\n\r\n37、炒鸡蛋时加入少量的砂糖，会使蛋白质变性的凝固温度上升，从而延缓了加热时间，加上砂糖具有保水性，因而可使蛋制品变得膨松柔软。\r\n\r\n38、炒鸡蛋时加入几滴醋，炒出的蛋松软味香。\r\n\r\n39、炒茄子时，在锅里放点醋，炒出的茄子颜色不会变黑。\r\n\r\n40、炒土豆时加醋，可避免烧焦，又可分解土豆中的毒素，并使色、味相宜。\r\n\r\n41、炒豆芽时，先加点黄油，然后再放盐，能去掉豆腥味。\r\n\r\n42、炒波菜时不宜加盖。\r\n\r\n43、炒肉片：肉切成薄片加酱油、黄油、淀粉，打入一个鸡蛋，拌匀，炒散；等肉片变色后，再加佐料稍炒几下，肉片味美、鲜嫩。\r\n\r\n44、炒牛肉丝：切好，用盐、糖、酒、生粉（或鸡蛋）拌一下，加上生油泡腌，30分钟后再炒，鲜嫩可口 。\r\n\r\n45、炒肉菜时放盐过早熟得慢，宜在将熟时加盐，在出锅前再加上几滴醋，鲜嫩可口。\r\n\r\n46、炒肉丝：肉丝切好后放在小苏打溶液里浸一下再炒，特别疏松可口，不论做什么糖醋菜肴，只要按２份糖１份醋的比例调配，便可做到甜酸适度。\r\n\r\n47、炒糖醋鱼、糖醋菜帮等，应先放糖，后放盐，否则食盐的“脱水”作用会促进菜肴中蛋白质凝固而“吃”不进糖分，造成外甜里淡。\r\n\r\n２\r\n\r\n48、做肉饼和肉丸子时，一公斤肉馅放2小匙盐。\r\n\r\n49、做丸子按50克肉10克淀粉的比例调制，成菜软嫩。\r\n\r\n50、做滑炒肉片或辣子肉丁，按50克肉５克淀粉的比例上浆，成菜鲜嫩味美。\r\n\r\n51、做馒头时，如果在发面里揉进一小块猪油，蒸出来的馒头不仅洁白、松软，而且味香。\r\n\r\n52、蒸馒头时掺入少许桔皮丝，可使馒头增加清香。\r\n\r\n53、蒸馒头碱放多了起黄，如在原蒸锅水里加醋２～３汤匙，再蒸10～15分钟可变白。\r\n\r\n54、蒸煮红薯：将少量明矾和食盐放入清水中，把切开的生红薯浸入十几分钟，洗净后蒸煮，可防止或减轻腹胀。\r\n\r\n55、煮牛奶：牛奶煮糊了，放点盐，冷却后味道更好。\r\n\r\n56、放有辣椒的菜太辣时或炒辣椒时加点醋，辣味大减。\r\n\r\n57、烹调时，放酱油若错倒了食醋，可撒放少许小苏打，醋味即可消除。\r\n\r\n58、菜太酸，将一只松花蛋捣烂放入。\r\n\r\n59、菜太辣，放一只鸡蛋同炒。\r\n\r\n60、菜太辣，放些醋可减低辣味。\r\n\r\n61、菜太苦，滴入少许白醋。\r\n\r\n62、汤太咸又不宜兑水时，可放几块豆腐或土豆或几片蕃茄到汤中；也可将一把米或面粉用布包起来放入汤中。\r\n\r\n63、汤太腻，将少量紫菜在火上烤一下，然后撒入汤中。\r\n\r\n64、花生米用油炸熟，盛入盘中，趁热撒上少许白酒，稍凉后再撒上少许食盐，放置几天几夜都稣脆如初 。\r\n\r\n65、菜籽油有一股异味，可把油烧热后投入适量生姜、蒜、葱、丁香、陈皮同炸片刻，油即可变香。66、用菜油炸一次花生米就没有怪味了，炒出的菜肴香味可口，并可做凉拌菜。\r\n\r\n67、炸完食物后的油留下一些残渣并变得混浊，可将白萝卜切成厚圆片，用筷子把萝卜戳几个洞，放入剩油中炸，残渣会附着在萝卜片上，取出清除残渣，再反复放入锅中炸，混浊的油可变清澈。\r\n\r\n68、当锅内温度达到最高时加入料酒，易使酒蒸发而去除食物中的腥味。\r\n\r\n69、熬猪油：在电饭褒内放一点水或植物油，然后放入猪板油或肥肉，接通电源后，能自动将油炼好，不溅油，不糊油渣，油质清纯。\r\n\r\n70、泡菜坛中放十几粒花椒或少许麦芽糖，可防止产生白花。\r\n\r\n71、开水点菜质增色佳妙青菜时，应用开水点菜，这样炒出的菜，质嫩色佳。若用水点菜，影响脆口。\r\n\r\n72、炒菜巧下盐如果你用动物油炒菜，最好在放菜前下盐，这样可减少动物油中有机氯的残余量，对人体有利。如果用花生油炒菜，也必须在放菜前下盐，这是因为花生油中可能会含有黄曲霉菌，而盐中的碘化物，可以除去这种有害物质。为了使炒菜可口，开始可先少放些盐，菜熟后再调味。如果用豆油、茶油或菜油，应先放菜、后下盐，这样可以减少蔬菜中营养成分的损失。\r\n\r\n73、糖醋汁配比不论做什么糖醋菜看，只要按2份糖、1份醋的比例调配，便可收到甜酸适度的效果。\r\n\r\n74、拔丝糖浆的熬制在熬制拔丝菜糖浆时，每盘加入一粒米大的明矾，能延长结时间，并使糖丝拉得更长。\r\n\r\n75、菜肴放醋的讲究凡需要加醋的热菜，在起锅前将醋沿锅边淋入，比直接淋上香味更加醇厚浓郁。\r\n\r\n76、啤酒调味剂：夏季做各种凉拌菜时，加适量啤酒调拌，可提味增香。\r\n\r\n77、葡萄酒做沙拉：葡萄酒开瓶后，若存放过久，就会变成“醋”。具有芳香味，用来做沙拉非常好吃。\r\n\r\n78、用盐洗菜保洁清洗青菜时，在清水里撤一些盐，这样可把蔬菜里的虫子清洗出来。\r\n\r\n79、洗切蔬菜防营养流失菠菜、白菜等蔬菜要先洗后切，不要切碎了再洗。否则，营养素会流失太多。\r\n\r\n80、盐可使蔬菜黄叶返绿菠菜等青菜的叶，如果有些(轻度)变黄，焯时效一点盐，颜色能由黄返绿。\r\n\r\n81、牛奶菜花更白嫩炒菜花时，加1匙牛奶，会使成品更加白嫩可口。\r\n\r\n82、凉拌西红柿宜放盐。用糖凉拌西红柿时，放少许盐会更甜，因为盐能改变西红柿的酸糖比。\r\n\r\n83、膀豆角新法：选择早晨采摘的新鲜脆嫩的豆角，直接加入适量的盐，在盛器内轻揉，待手感潮湿之后，再入缸(注意避免破损或虫蛀的豆角混入)，层层压紧、压实，并撤上少量盐，加净石压顶层，封口。此法是直接利用豆角本身汁水腌浸，不另加水，避免豆角在水中变腐。成品味正、色泽黄亮、口感松脆，可贮存1年以上。\r\n\r\n84、腌泡菜除霉花腌制泡菜时容易生霉花(白膜)。可取干蚕豆250克；炒熟放凉后，用纱布包好放入坛内，第2天取出。这样，就可钢底除去白膜，蚕豆加工后，还是下酒的好菜。\r\n\r\n85、芥末做泡菜做泡菜时，加上点芥末、芹菜屑和鱿鱼屑，可使泡菜色、味俱佳。\r\n\r\n86、切辣椒、葱防刺限切辣椒和葱时，眼睛往往被辣得流泪、难受。如果把菜放冰箱冷冻一下再切，或者先将菜刀在凉水里浸一下再切，也可在菜板旁放一盆凉水，刀边蘸水边切，均可有效地减轻辣味的散发，使眼睛不受刺激。\r\n\r\n87、炒辣椒减辣味法：辣椒辣味太浓，烹制时将辣椒切成细末或丁，先用油、盐煽熟，再倒入一个鲜鸡蛋液，炒成“蛋包椒丁”，辣味可大大减轻。\r\n\r\n88、鲜姜保存：鲜姜埋在经常保持湿润的黄沙里，随用随取，能保存较长时间不坏。\r\n\r\n89、芥末辣味的去除芥末用水调匀(稠膏状)，盛在容器里，放到火炉上烤，或上笼屉稍蒸一下，可除去部分辣味。\r\n\r\n90、麦饭石泡菜易存放用麦饭石水浸泡蔬菜、瓜果，置于阴凉处，可延长存放时间1倍以上。\r\n\r\n91、汤过咸处置三法如果汤做得太咸，用纱布包一些煮熟了的大米饭放进去，朗吸收盐分，减轻咸味。汤过咸，可切几块马铃薯片下锅一起煮，立即捞起，汤就不那么咸了。汤太咸，可放几块豆腐或番茄片同煮，其减咸功效与放土豆同。\r\n\r\n92、紫菜可除汤中油腻汤过于油腻时，可将少量紫菜置于火上烤一下，然后撒入汤内，可减少油腻感。\r\n\r\n93、菜过威处理三法：菜咸了，可加适量白糖，即可解盐。菜咸了，放些醋，咸味会大大减少。菜咸了，用掺有白酒的水浸泡，有明显的去咸效果。\r\n\r\n94、牛奶可谈化酱汁炒菜时，如果调味酱汁放多了，加上少许牛奶，能调和菜的味道。\r\n\r\n95、酒可解酸：醋放多了，可在菜里加一些米酒，可以减轻酸味。\r\n\r\n96、腌菜咸辣味的谈化腌渍小菜，如过咸或过辣时，可将小菜切好后浸在50%的酒水里，能冲淡咸味或辣味，且味道更鲜美。\r\n\r\n97、.除蔬菜的苦涩味萝卜、苦瓜等带有苦涩味的蔬菜，切好后加少量盐渍一下，滤出汁水再烧，苦涩味会明显减少。菠菜在开水中烫后再炒，可去苦涩味和草酸。\r\n\r\n98、冰冻“萝卜干”把切好的萝卜先放在冰箱里冷冻一段时间，再拿出来置阳光下晒干，就成了可以久存且风味独特的：萝卜干，烧肉时放上一些，味道极好。\r\n\r\n99、除去萝卜异味蒸吃萝卜，应该先将其切碎，按300：1的比例放入食醋，再上锅蒸，就可使异味消失。\r\n\r\n100、萝卜贮藏三法：土坑贮藏法：将新鲜的萝卜削去项，去毛根，严格剔除带有虫伤，机械伤，裂口和过小的萝卜。挖一个l米深，1米见方的土坑，路萝卜根朝上，顶朝下，斜靠坑壁，按顺序码紧。码齐一层萝卜，撤上一层10厘米左右厚的净土，如此交替码放，共码四层。若坑土过于，可适当喷水湿润。最上一层码好后，要根据气候变化逐渐加厚土壤层，天暖少覆土，来强寒流时多覆土，小寒前后覆土完毕，土厚共1米。质量好的萝卜，入坑前不受热，入坑后不受冻，能贮存到来年三月上旬。泥浆贮藏法把萝卜削顶，放到黄泥浆中滚一圈，使萝菠萝卜结一层泥壳，堆放到明凉的地方即可。如果在萝卜堆外再培一层湿土，效果更好。水缸外贮藏法。在室内放一水缸，里面装满水，把萝卜堆放在缸的周围，上面再培15厘米厚的湿土即可。\r\n\r\n101、去皮萝卜的保鲜去皮的胡萝卜，最好放在干燥的器皿中，上盖湿布，但保存时间不要超过3个小时。\r\n\r\n102、食品袋贮藏大白菜若没有菜窖，冬天贮菜采用无毒塑料袋保存，可收到较好的效果。如果室内温度过低，可把食品袋从蔬菜的根部套上去，然后把上口扎上。如果温度在思氏零度以上，可从白菜叶上套上塑料袋，口不用扎，根朝下戳在地上即可。\r\n\r\n103、蒜黄、韭菜的保鲜：买来的蒜黄、青韭、青蒜等青菜，一时吃不完，可用带帮的大白菜叶子把它包捆好，放在阴凉处，不要着水，能保存一段时间不坏。\r\n\r\n104、冻洋葱复鲜：把冷冻过的洋葱放在清水中浸泡；可使洋葱复鲜。\r\n\r\n105、炒洋葱宜放面扮、葡萄酒切好的洋葱蘸点干面粉，炒熟后色泽金黄；质地脆嫩，味美可口；炒洋葱时，加少许白葡萄酒，则不易炒焦。\r\n\r\n106、加工芋头防刺激皮肤剥刮芋头皮时，易使手部皮肤发痒，若将手放在炉火上烘烤一下，或在水中加几滴醋洗一下，即可消痒。搽一点风油精也有效果。\r\n\r\n107、清水抄藕洁白炒藕丝时，往往会变黑，如能边炒边加些清水，就会保持成品洁白。\r\n\r\n108、加工茄子防氧化茄子切开后，应立即浸入水中，否则茄子会被氧化成褐色。\r\n\r\n109、新土豆去皮法把新土豆放入热水浸泡一下，再倒入冷水中，很容易去皮。\r\n\r\n110、土豆去皮越薄越好土豆皮含有较丰富的营养物质；去皮不宜厚。土豆一旦去皮，要存放在冷水中，再向水中滴几滴醋；可使土豆洁白。\r\n\r\n111、做土豆放奶味道好白水煮土豆时，加一点牛奶，不但味道好，也可防止土豆肉质发黄。\r\n\r\n112、烧土豆要后加盐再升温烧土豆时，待变色后再加盐升温。否则；土豆会形成硬皮，的汁液与油混在一起，成菜易碎，影响色香味。\r\n\r\n113、冻土豆怪味的去除先将冻土豆放入冷水中浸泡，再放入加有1汤匙食醋的沸水中，慢慢冷却后，再行制菜。这样烧出的土豆就没有怪味了。\r\n\r\n114、土豆戒红薯土豆不能与红薯存放在一起。否则，不是红薯僵心，便是土豆发芽。\r\n\r\n115、淘米水发于菜效果好用淘米水泡发海带、干菜等于货，易发涨，烹制时易烂。\r\n\r\n116、干海带蒸后再烹好把于海带上锅蒸半个小时，取出后用碱面搓一遍，用清水泡2—3小时再烹制，无论做菜煮汤，都脆嫩可口，且没有海腥味。\r\n\r\n117、煮海带易烂法煮海带时，适当加点碱或小苏打，或者在锅里放适量食醋，易使海带变软；若放几棵菠菜，海带易烂。\r\n\r\n118、泡发木耳二法用烧开的米汤泡发木耳，能使木耳肥大，松软，味道鲜美。用凉水泡发木耳，可使其脆嫩爽口。\r\n\r\n119、木耳泥沙的清洗黑木耳易粘上木渣和泥沙，可用盐水(盐约为于木耳重的洗，轻轻揉匀，待水变浑，即可用清水淘洗。\r\n\r\n120、巧渍蘑菇在1公斤的温水中，加糖25克，把洗净的蘑菇切好浸入泡12个小时。泡蘑菇加糖，既能使蘑菇吃水快，保持香味，又因蘑菇中浸入了糖液，烧好后味道更加鲜美。\r\n\r\n121、蘑菇挑选法有毒蘑菇的特征是，色泽鲜艳好看，采回后容易变色，挤出的浆汁混浊如牛奶。无毒蘑菇多为白色、浅棕色、旧纸色，挤出的浆汁清澈如水。\r\n\r\n122、黄花菜的烹前加工鲜黄花菜(金针菜)中含有秋水仙碱，在人体内被氧化成为氧化二秋水仙碱，有剧毒。因此，要用开水烫后浸泡，除去汁水，彻底炒熟才能吃。\r\n\r\n123、笋干的涨发先将笋干放在铁锅内，加满水煮沸30分钟，再转小火焖煮，捞出，切除老根，洗净。然后浸泡在淘米水或石灰水中待用，隔2—3天换1次水，烹调前切成片状，食之鲜嫩味美。','做菜时你绝对不知道的123个门道','','inherit','open','open','','96-revision-v1','','','2013-08-23 13:59:13','2013-08-23 05:59:13','',96,'http://localhost/wordpress-new/?p=97',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (98,1,'2013-08-23 13:59:31','2013-08-23 05:59:31','1、所有的人都会跌倒，伟大的人会再站起来。\r\n\r\n2、如果你想得到你从没有得到过的东西，你就必须做一些你从来就没有做过的事情。\r\n\r\n3、柏拉图：如果，不幸福，如果，不快乐，那就放手吧；如果，舍不得，放不下，那就痛苦吧。\r\n\r\n4、好习惯赢得好人缘：①准时赴约；②用“眼睛”去倾听；③记住别人的姓名；④认认真真去握手；⑤少谈自己，多谈他人；⑥欣赏之感溢于言表；⑦多多鼓励，善于激励；⑧不要抱怨别人；⑨学会交流，与人协作；⑩尊重别人的隐私；⑪宽容是交友之道；⑫用心经营你的家庭；⑬充满爱与感激的小纸条；⑭把他的优点说出来。\r\n\r\n5、给孩子的5句话：\r\n①不要试图什么都争第一。\r\n②不要试图交到一个完美的朋友，也不要交到很多朋友。\r\n③帮助别人，自己也会强大起来。\r\n④学会用真诚的简单，对付虚伪的复杂。\r\n⑤考上大学，你是我的儿女；你扫马路，更是我的儿女；只要保持高贵的人格，扫马路也可以扫出一个光明纯洁的世界。\r\n\r\n6、建立人脉潜规则：①想钓到鱼，就要从鱼的角度思考；②不要总显示比别人聪明；③让对方作主角；④勿目中无人，谦虚是王道；⑤常与人争辩，你永难赢；⑥锋芒太露，下场不好；⑦刺猬原则：保持适当距离；⑧树一个敌，等于立一堵墙；⑨谦虚不虚伪，追求不苛求；⑩失言不如无言。\r\n\r\n7、知足：平生修得随缘性，粗茶淡饭也知足；\r\n安然：万事岂能尽人意，但求无愧吾自心；\r\n时运：十年河东转河西，莫笑穷人穿破衣；\r\n闲静：闲谈莫论人是非，静坐常思自已过。\r\n\r\n8、狄德罗的效应：哲学家丹·狄德罗很喜欢友人送的高级睡袍，但当他穿上之后，开始觉得家里的家具和装饰都显得粗陋庸俗，于是把旧的东西一件件更新，最终也不觉得开心 ，他发现“自己竟然被一条睡袍胁迫了”。欲望是永远不能填满的黑洞，过于追求完美的感觉，只会让不完美的感觉对自己越缠越紧。\r\n\r\n9、消极的人总有理由，积极的人总有计划。消极的人找借口，积极的人找方法。消极的人制造问题，积极的人解决问题。消极的人总在逃避，积极的人总在面对。消极的人爱说：不该我做，积极的人爱说：让我来。\r\n\r\n10、防治虚荣心的心理处方：\r\n①追求真善美，就不会通过不正当的手段来炫耀自己，就不会徒有虚名。\r\n②克服盲目攀比心理，横向地去跟他人比较，心理永远都无法平衡，会促使虚荣心越发强烈，一定要比，就跟自己的过去比，看看各方面有没有进步。\r\n③珍惜自己的人格，崇尚高尚的人格可以使虚荣心没有机会抬头。\r\n\r\n11、九大时间杀手：①不分轻重缓急；②电话与不速之客；③工作环境杂乱；④不会说NO的烂好人；⑤拖延的坏习惯；⑥一次想完成太多事情；⑦事必躬亲，不懂授权；⑧不必要的会议；⑨沉迷于无意义的活动。\r\n\r\n12、谈话时的十大错误：①出现争辩时，把对方逼上绝路；②过于卖弄自己；③喋喋不休发牢骚诉说自己的不幸；④在朋友痛苦无助的时，谈自己得意的事情；⑤用训斥的口吻去说别人；⑥随意触及隐私；⑦谈话时做一些不礼貌的动作；⑧只注重个人而冷落了他人；⑨随便地打断别人的谈话；⑩谈对方不懂的问题。\r\n\r\n13、有助于成功的四个好习惯：\r\n①不要过于谦虚，适度的谦虚，使自己显得更值得尊敬而不娇揉造作。\r\n②敢于承认错误，勇于认错，可以避免许多不必要的误解与麻烦。\r\n③不要过分牺牲自己去讨好别人，想让所有人都喜欢你是不可能的。\r\n④珍惜自己和别人的时间，既要善于安排自己的时间，也要珍惜别人的时间。\r\n\r\n14、人性的弱点：\r\n人之所以痛苦，是因为追求了错误的东西，把单纯的事情看得既复杂有严重；\r\n人之所以郁闷，是心中装进了许多杂质，不但不清理，还越装越多，阻得你喘不过气来；\r\n人之所以愚钝，是听不见别人的心声，总认为自己是世界上最聪明的人。\r\n\r\n15、富不起来的原因之十缺：表面上最缺的是金钱；本质上最缺的是野心；脑袋上最缺的是观念；对机会最缺的是了解；命运里最缺的是选择；骨子里最缺的是勇气 ；改变上最缺的是行动；肚子里最缺的是知识；事业上最缺的是毅力；内心里最缺的是胆色。\r\n\r\n16、心理成熟的13个标志：①不再盲目跟风；②不再犹豫不定；③合理安排时间；④开始关注新闻国事；⑤开始养生；⑥在爱情、友情、亲情之间，首先想到亲情；⑦不再用哭闹来解决问题；⑧重视身边的朋友；⑨让周围的人快乐；⑩在得失方面变得大度；⑪学着尊重每个人；⑫自信地生活；⑬淡忘仇恨。\r\n\r\n17、职场取胜的十大智慧：①融入同事的爱好之中；②不随意泄露个人隐私；③不要让爱情“挡”道；④闲聊应保持距离；⑤远离搬弄是非；⑥低调处理内部纠纷；⑦切忌随意伸手借钱；⑧牢骚怨言要远离嘴边；⑨得意之时莫张扬；⑩不私下向上司争宠。\r\n\r\n18、罗杰斯给宝贝女儿的12个箴言：\r\n①不要让别人影响你；②专注于你所爱；③普通常识并不是那么普通；④将世界纳入你的眼界；⑤研读哲学，学会思考；⑥学习历史；⑦这是中国的世纪，去学中文；⑧真正认识自己；⑨认出改变，拥抱改变；⑩面对未来；⑪反众道而行，不随乌合之众心理起舞；⑫幸运女神只眷顾持续努力的人。\r\n\r\n19、巴菲特教孩子的六点：\r\n①如果你想人生多彩多姿，就试着学所有感兴趣的事；\r\n②感觉迷失时不是你迷路了，而是找到正途前的必然之路；\r\n③对志向的渴望可以引领我们完成引以为傲的成就；\r\n④审视自己的内心是最好的投资；\r\n⑤愿望未能实现时，好好仔细思考什么是自己真的要的；\r\n⑥能力+热情+努力+坚持=成功\r\n\r\n20、苹果CEO乔布斯创业语录：\r\n人一辈子没法做太多事，所以每件都要做得精彩绝伦。\r\n不要被教条所限，要听从自己内心的声音，去做自己想做的事。\r\n只有爱你所做的，你才能成就伟大的事情。如果你没找到自己所爱的，继续找别停下来。\r\n活着就是为了改变世界，难道还有其他原因吗？','活着就是为了改变世界','','publish','open','open','','%e6%b4%bb%e7%9d%80%e5%b0%b1%e6%98%af%e4%b8%ba%e4%ba%86%e6%94%b9%e5%8f%98%e4%b8%96%e7%95%8c','','','2013-08-23 13:59:31','2013-08-23 05:59:31','',0,'http://localhost/wordpress-new/?p=98',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (99,1,'2013-08-23 13:59:31','2013-08-23 05:59:31','1、所有的人都会跌倒，伟大的人会再站起来。\r\n\r\n2、如果你想得到你从没有得到过的东西，你就必须做一些你从来就没有做过的事情。\r\n\r\n3、柏拉图：如果，不幸福，如果，不快乐，那就放手吧；如果，舍不得，放不下，那就痛苦吧。\r\n\r\n4、好习惯赢得好人缘：①准时赴约；②用“眼睛”去倾听；③记住别人的姓名；④认认真真去握手；⑤少谈自己，多谈他人；⑥欣赏之感溢于言表；⑦多多鼓励，善于激励；⑧不要抱怨别人；⑨学会交流，与人协作；⑩尊重别人的隐私；⑪宽容是交友之道；⑫用心经营你的家庭；⑬充满爱与感激的小纸条；⑭把他的优点说出来。\r\n\r\n5、给孩子的5句话：\r\n①不要试图什么都争第一。\r\n②不要试图交到一个完美的朋友，也不要交到很多朋友。\r\n③帮助别人，自己也会强大起来。\r\n④学会用真诚的简单，对付虚伪的复杂。\r\n⑤考上大学，你是我的儿女；你扫马路，更是我的儿女；只要保持高贵的人格，扫马路也可以扫出一个光明纯洁的世界。\r\n\r\n6、建立人脉潜规则：①想钓到鱼，就要从鱼的角度思考；②不要总显示比别人聪明；③让对方作主角；④勿目中无人，谦虚是王道；⑤常与人争辩，你永难赢；⑥锋芒太露，下场不好；⑦刺猬原则：保持适当距离；⑧树一个敌，等于立一堵墙；⑨谦虚不虚伪，追求不苛求；⑩失言不如无言。\r\n\r\n7、知足：平生修得随缘性，粗茶淡饭也知足；\r\n安然：万事岂能尽人意，但求无愧吾自心；\r\n时运：十年河东转河西，莫笑穷人穿破衣；\r\n闲静：闲谈莫论人是非，静坐常思自已过。\r\n\r\n8、狄德罗的效应：哲学家丹·狄德罗很喜欢友人送的高级睡袍，但当他穿上之后，开始觉得家里的家具和装饰都显得粗陋庸俗，于是把旧的东西一件件更新，最终也不觉得开心 ，他发现“自己竟然被一条睡袍胁迫了”。欲望是永远不能填满的黑洞，过于追求完美的感觉，只会让不完美的感觉对自己越缠越紧。\r\n\r\n9、消极的人总有理由，积极的人总有计划。消极的人找借口，积极的人找方法。消极的人制造问题，积极的人解决问题。消极的人总在逃避，积极的人总在面对。消极的人爱说：不该我做，积极的人爱说：让我来。\r\n\r\n10、防治虚荣心的心理处方：\r\n①追求真善美，就不会通过不正当的手段来炫耀自己，就不会徒有虚名。\r\n②克服盲目攀比心理，横向地去跟他人比较，心理永远都无法平衡，会促使虚荣心越发强烈，一定要比，就跟自己的过去比，看看各方面有没有进步。\r\n③珍惜自己的人格，崇尚高尚的人格可以使虚荣心没有机会抬头。\r\n\r\n11、九大时间杀手：①不分轻重缓急；②电话与不速之客；③工作环境杂乱；④不会说NO的烂好人；⑤拖延的坏习惯；⑥一次想完成太多事情；⑦事必躬亲，不懂授权；⑧不必要的会议；⑨沉迷于无意义的活动。\r\n\r\n12、谈话时的十大错误：①出现争辩时，把对方逼上绝路；②过于卖弄自己；③喋喋不休发牢骚诉说自己的不幸；④在朋友痛苦无助的时，谈自己得意的事情；⑤用训斥的口吻去说别人；⑥随意触及隐私；⑦谈话时做一些不礼貌的动作；⑧只注重个人而冷落了他人；⑨随便地打断别人的谈话；⑩谈对方不懂的问题。\r\n\r\n13、有助于成功的四个好习惯：\r\n①不要过于谦虚，适度的谦虚，使自己显得更值得尊敬而不娇揉造作。\r\n②敢于承认错误，勇于认错，可以避免许多不必要的误解与麻烦。\r\n③不要过分牺牲自己去讨好别人，想让所有人都喜欢你是不可能的。\r\n④珍惜自己和别人的时间，既要善于安排自己的时间，也要珍惜别人的时间。\r\n\r\n14、人性的弱点：\r\n人之所以痛苦，是因为追求了错误的东西，把单纯的事情看得既复杂有严重；\r\n人之所以郁闷，是心中装进了许多杂质，不但不清理，还越装越多，阻得你喘不过气来；\r\n人之所以愚钝，是听不见别人的心声，总认为自己是世界上最聪明的人。\r\n\r\n15、富不起来的原因之十缺：表面上最缺的是金钱；本质上最缺的是野心；脑袋上最缺的是观念；对机会最缺的是了解；命运里最缺的是选择；骨子里最缺的是勇气 ；改变上最缺的是行动；肚子里最缺的是知识；事业上最缺的是毅力；内心里最缺的是胆色。\r\n\r\n16、心理成熟的13个标志：①不再盲目跟风；②不再犹豫不定；③合理安排时间；④开始关注新闻国事；⑤开始养生；⑥在爱情、友情、亲情之间，首先想到亲情；⑦不再用哭闹来解决问题；⑧重视身边的朋友；⑨让周围的人快乐；⑩在得失方面变得大度；⑪学着尊重每个人；⑫自信地生活；⑬淡忘仇恨。\r\n\r\n17、职场取胜的十大智慧：①融入同事的爱好之中；②不随意泄露个人隐私；③不要让爱情“挡”道；④闲聊应保持距离；⑤远离搬弄是非；⑥低调处理内部纠纷；⑦切忌随意伸手借钱；⑧牢骚怨言要远离嘴边；⑨得意之时莫张扬；⑩不私下向上司争宠。\r\n\r\n18、罗杰斯给宝贝女儿的12个箴言：\r\n①不要让别人影响你；②专注于你所爱；③普通常识并不是那么普通；④将世界纳入你的眼界；⑤研读哲学，学会思考；⑥学习历史；⑦这是中国的世纪，去学中文；⑧真正认识自己；⑨认出改变，拥抱改变；⑩面对未来；⑪反众道而行，不随乌合之众心理起舞；⑫幸运女神只眷顾持续努力的人。\r\n\r\n19、巴菲特教孩子的六点：\r\n①如果你想人生多彩多姿，就试着学所有感兴趣的事；\r\n②感觉迷失时不是你迷路了，而是找到正途前的必然之路；\r\n③对志向的渴望可以引领我们完成引以为傲的成就；\r\n④审视自己的内心是最好的投资；\r\n⑤愿望未能实现时，好好仔细思考什么是自己真的要的；\r\n⑥能力+热情+努力+坚持=成功\r\n\r\n20、苹果CEO乔布斯创业语录：\r\n人一辈子没法做太多事，所以每件都要做得精彩绝伦。\r\n不要被教条所限，要听从自己内心的声音，去做自己想做的事。\r\n只有爱你所做的，你才能成就伟大的事情。如果你没找到自己所爱的，继续找别停下来。\r\n活着就是为了改变世界，难道还有其他原因吗？','活着就是为了改变世界','','inherit','open','open','','98-revision-v1','','','2013-08-23 13:59:31','2013-08-23 05:59:31','',98,'http://localhost/wordpress-new/?p=99',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (100,1,'2013-08-23 13:59:47','2013-08-23 05:59:47','1、一杯清水因滴入一滴污水而变污浊，一杯污水却不会因一滴清水的存在而变清澈。\r\n\r\n2、这世上有三样东西是别人抢不走的：一是吃进胃里的食物，二是藏在心中的梦想，三是读进大脑的书。\r\n\r\n3、马在松软的土地上易失蹄，人在甜言蜜语中易摔跤。\r\n\r\n4、世界没有悲剧和喜剧之分，如果你能从悲剧中走出来，那就是喜剧，如果你沉缅于喜剧之中，那它就是悲剧。 ­\r\n\r\n5、如果不读书，行万里路也不过是个邮差。\r\n\r\n6、针无两头锋利，人无两副身心。\r\n\r\n7、运气就是机会碰巧撞到了你的努力。\r\n\r\n8、得之坦然，失之淡然，顺其自然，争其必然。\r\n\r\n9、男人有钱就变坏。是的，很多男人是这样，不过，有钱就变坏的男人就算没钱，也好不到哪里去。\r\n\r\n10、当你的邻居在深夜两点弹钢琴是你别气恼，你可以在四点钟时叫醒他，并告诉他你很欣赏他的演奏。\r\n\r\n11、如果你只是等待，发生的事情只会是你变老了。\r\n\r\n12、所谓门槛，过去了就是门，没过去就成了槛。\r\n\r\n13、最小的善行胜过最大的善念。\r\n\r\n14、真正的朋友不是在一起有聊不完的话，而是即使不说一句话也不觉得尴尬。\r\n\r\n15、时间是治疗心灵创伤的大师，但绝不是解决问题的高手。\r\n\r\n16、宁愿做过了后悔，也不要错过了后悔。\r\n\r\n17、所谓永恒的爱，就是从红颜到白发，从花开到花落。\r\n\r\n来源； http://zhichang.umiwi.com/2011/1204/51568.shtml','那些经典的无以复加的句子','','publish','open','open','','%e9%82%a3%e4%ba%9b%e7%bb%8f%e5%85%b8%e7%9a%84%e6%97%a0%e4%bb%a5%e5%a4%8d%e5%8a%a0%e7%9a%84%e5%8f%a5%e5%ad%90','','','2013-08-23 13:59:47','2013-08-23 05:59:47','',0,'http://localhost/wordpress-new/?p=100',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (101,1,'2013-08-23 13:59:47','2013-08-23 05:59:47','1、一杯清水因滴入一滴污水而变污浊，一杯污水却不会因一滴清水的存在而变清澈。\r\n\r\n2、这世上有三样东西是别人抢不走的：一是吃进胃里的食物，二是藏在心中的梦想，三是读进大脑的书。\r\n\r\n3、马在松软的土地上易失蹄，人在甜言蜜语中易摔跤。\r\n\r\n4、世界没有悲剧和喜剧之分，如果你能从悲剧中走出来，那就是喜剧，如果你沉缅于喜剧之中，那它就是悲剧。 ­\r\n\r\n5、如果不读书，行万里路也不过是个邮差。\r\n\r\n6、针无两头锋利，人无两副身心。\r\n\r\n7、运气就是机会碰巧撞到了你的努力。\r\n\r\n8、得之坦然，失之淡然，顺其自然，争其必然。\r\n\r\n9、男人有钱就变坏。是的，很多男人是这样，不过，有钱就变坏的男人就算没钱，也好不到哪里去。\r\n\r\n10、当你的邻居在深夜两点弹钢琴是你别气恼，你可以在四点钟时叫醒他，并告诉他你很欣赏他的演奏。\r\n\r\n11、如果你只是等待，发生的事情只会是你变老了。\r\n\r\n12、所谓门槛，过去了就是门，没过去就成了槛。\r\n\r\n13、最小的善行胜过最大的善念。\r\n\r\n14、真正的朋友不是在一起有聊不完的话，而是即使不说一句话也不觉得尴尬。\r\n\r\n15、时间是治疗心灵创伤的大师，但绝不是解决问题的高手。\r\n\r\n16、宁愿做过了后悔，也不要错过了后悔。\r\n\r\n17、所谓永恒的爱，就是从红颜到白发，从花开到花落。\r\n\r\n来源； http://zhichang.umiwi.com/2011/1204/51568.shtml','那些经典的无以复加的句子','','inherit','open','open','','100-revision-v1','','','2013-08-23 13:59:47','2013-08-23 05:59:47','',100,'http://localhost/wordpress-new/?p=101',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (102,1,'2013-08-23 14:00:05','2013-08-23 06:00:05','一个美国人呱呱落地了\r\n\r\n打从小，美国的教育就告诉他：不要读死书，要创造力，做人要正直、守信、诚实。\r\n\r\n长大以后，他发现这些教育，在美国都是无比正确的，有创造力的美国人创造了互联网、电脑等高科技，领导着世界。做一个美国人必须言行一致，诚实守信，如果有一次不诚实不守信的不良记录，这一辈子都会麻烦不断，甚至无法立足于美国社会。\r\n\r\n这个美国人工作了，他每年为国家缴纳税收，在他暂时失业的时候，每月能领到1500美元的失业救济金，还享受医疗、保险等社会福利。在他无论在任何地方遇到困难和危险的时候，美国的政府派出直升机和救援队来搜救他。假如在国外遇到危险时，美国的军舰和战斗机会来解救他。\r\n\r\n这个美国人经常参加投票，在选票上写下他信任的市长候选人、州长候选人、总统候选人。他发现，凡是选民选出来的各级领导人和政府机关，都重视人民的利益，为人民谋福利，没什么架子，也很清廉。公务员的办公楼看不到奢侈浪费的地方，甚至非常简陋，一个美国白宫也不如某国的一个县政府辉煌气派。公务员对老百姓们打成一片，警察甚至帮他家里修剪园林。\r\n\r\n这个美国人很幸福很自豪的生活着，直到他去世的那一天，他都确信美国是一个世界最好的国家之一，他做为一个美国人感到无比自豪，他希望上帝保佑美国。\r\n\r\n一个中国人也呱呱落地了\r\n\r\n打从小，中国的教育就告诉他：要读死书，不要有创造力，做人要正直、守信、诚实。\r\n\r\n长大以后，他发现这些教育，在中国都是无比错误的，没有创造力的中国人变成了世界工厂，仿制耐克鞋，生产玩具、裤子，为全世界打工，冒着断手断脚的危险，赚钱几美分的微薄利润。做一个言行一致和诚实守信中国人被证明是脑残，弱肉强食的丛林法则，让为非作歹毫无诚信的人一个个发家致富，成为社会的富裕阶层。他成了一个看不到希望的待富者。\r\n\r\n这个中国人工作了，他每年为国家缴纳税收，却发现，他暂时失业的时候，领不到一毛钱失业救济金。看个病需要几万几十万元，买个房子一平米要N万元。在他遇到危险的时候，没有政府的救援，除非是几百几千人遇到巨大的危险，某高层发话，才在几十天后见到救援队，其中救援物资还被贪污了大半。假如在国外遇到危险，就更别指望国家救援了，被恐怖分子关押一两年之后才被释放。\r\n\r\n这个中国人一辈子不知道什么叫民主选举，他发现县长、市长都是上级安排好的，他们只为上级服务，城管是为了上级看到美好的市容而清理做小生意糊口的\"刁民\"，政府的办公楼和汽车一个比一个豪华，出台的政策都是为富人和既得利益服务，没有一个是为老百姓谋幸福。公务员和警察一个个凶神恶煞，甚至警匪一家，蛇鼠一窝。\r\n\r\n这个中国人很哀怨很无语的生活着，直到去世的那一天，他都后悔投错了胎，怎么生在了中国。他的孩子告诉他，他的房子70年到期还要续租，他惨叫一声，口吐鲜血的死去，临死，两眼都不肯合上，死不瞑目。','美国人与中国人','','publish','open','open','','%e7%be%8e%e5%9b%bd%e4%ba%ba%e4%b8%8e%e4%b8%ad%e5%9b%bd%e4%ba%ba','','','2013-08-23 14:00:05','2013-08-23 06:00:05','',0,'http://localhost/wordpress-new/?p=102',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (103,1,'2013-08-23 14:00:05','2013-08-23 06:00:05','一个美国人呱呱落地了\r\n\r\n打从小，美国的教育就告诉他：不要读死书，要创造力，做人要正直、守信、诚实。\r\n\r\n长大以后，他发现这些教育，在美国都是无比正确的，有创造力的美国人创造了互联网、电脑等高科技，领导着世界。做一个美国人必须言行一致，诚实守信，如果有一次不诚实不守信的不良记录，这一辈子都会麻烦不断，甚至无法立足于美国社会。\r\n\r\n这个美国人工作了，他每年为国家缴纳税收，在他暂时失业的时候，每月能领到1500美元的失业救济金，还享受医疗、保险等社会福利。在他无论在任何地方遇到困难和危险的时候，美国的政府派出直升机和救援队来搜救他。假如在国外遇到危险时，美国的军舰和战斗机会来解救他。\r\n\r\n这个美国人经常参加投票，在选票上写下他信任的市长候选人、州长候选人、总统候选人。他发现，凡是选民选出来的各级领导人和政府机关，都重视人民的利益，为人民谋福利，没什么架子，也很清廉。公务员的办公楼看不到奢侈浪费的地方，甚至非常简陋，一个美国白宫也不如某国的一个县政府辉煌气派。公务员对老百姓们打成一片，警察甚至帮他家里修剪园林。\r\n\r\n这个美国人很幸福很自豪的生活着，直到他去世的那一天，他都确信美国是一个世界最好的国家之一，他做为一个美国人感到无比自豪，他希望上帝保佑美国。\r\n\r\n一个中国人也呱呱落地了\r\n\r\n打从小，中国的教育就告诉他：要读死书，不要有创造力，做人要正直、守信、诚实。\r\n\r\n长大以后，他发现这些教育，在中国都是无比错误的，没有创造力的中国人变成了世界工厂，仿制耐克鞋，生产玩具、裤子，为全世界打工，冒着断手断脚的危险，赚钱几美分的微薄利润。做一个言行一致和诚实守信中国人被证明是脑残，弱肉强食的丛林法则，让为非作歹毫无诚信的人一个个发家致富，成为社会的富裕阶层。他成了一个看不到希望的待富者。\r\n\r\n这个中国人工作了，他每年为国家缴纳税收，却发现，他暂时失业的时候，领不到一毛钱失业救济金。看个病需要几万几十万元，买个房子一平米要N万元。在他遇到危险的时候，没有政府的救援，除非是几百几千人遇到巨大的危险，某高层发话，才在几十天后见到救援队，其中救援物资还被贪污了大半。假如在国外遇到危险，就更别指望国家救援了，被恐怖分子关押一两年之后才被释放。\r\n\r\n这个中国人一辈子不知道什么叫民主选举，他发现县长、市长都是上级安排好的，他们只为上级服务，城管是为了上级看到美好的市容而清理做小生意糊口的\"刁民\"，政府的办公楼和汽车一个比一个豪华，出台的政策都是为富人和既得利益服务，没有一个是为老百姓谋幸福。公务员和警察一个个凶神恶煞，甚至警匪一家，蛇鼠一窝。\r\n\r\n这个中国人很哀怨很无语的生活着，直到去世的那一天，他都后悔投错了胎，怎么生在了中国。他的孩子告诉他，他的房子70年到期还要续租，他惨叫一声，口吐鲜血的死去，临死，两眼都不肯合上，死不瞑目。','美国人与中国人','','inherit','open','open','','102-revision-v1','','','2013-08-23 14:00:05','2013-08-23 06:00:05','',102,'http://localhost/wordpress-new/?p=103',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (104,1,'2013-08-23 14:00:46','2013-08-23 06:00:46','引言\r\n\r\n许多门户开发人员已使用 WebSphere Portal 创建用于共享事件和数据以增强用户体验的协作 Portlet。例如，在一个 Portlet 中提交的选择可导致更新的信息在多个相关的 Portlet 中显示，从而有助于这些 Portlet 在其表示中保持同步。此功能在服务器上实现，依赖于 Portlet 将操作请求提交到服务器，以使该服务器可以在页面被刷新之前执行数据传输。\r\n\r\n然而，当您将 Ajax 功能添加到 Portlet 时，此方法就变得无人问津了，因为 Ajax 功能使您可以动态更新由 Portlet 显示的数据，而不用提交操作请求或刷新页面。本文将说明如何使用 Dojo JavaScript 工具包在浏览器中共享 Portlet 之间的数据和事件，该工具包可为动态更新的 Portlet 提供协作支持。\r\n\r\n回页首\r\n\r\n什么是 Dojo？\r\n\r\nDojo 是开源 JavaScript 工具包，可用于开发动态 Web 应用程序。Dojo 的许多库中都包含 Ajax 支持、DOM 操作工具、事件处理系统和可自定义的小部件集。Dojo 将这些库与一个灵活的打包系统组合在一起，这样，您就可以只导入所需的库；Dojo 自动地为您解决了所有库与库之间的依赖关系。\r\n\r\n使用 Dojo\r\n\r\n动态打包系统正是使用 Dojo 库与使用传统 JavaScript 包含的区别所在。执行两个步骤就可以包括 Dojo 库。您将执行以下两个步骤：\r\n包括 Dojo 引导。 &lt;script type=\"text/javascript\" src=\"/path/to/dojo/dojo.js\"&gt;\r\n&lt;/script&gt;\r\n\r\n标识您的应用程序所需要的 Dojo 库。您使用 dojo.require 语句来包括 Dojo 小部件的管理功能 (dojo.widget.*) 和 Button 小部件 (dojo.widget.Button)。 &lt;script type=\"text/javascript\"&gt;\r\ndojo.require(\"dojo.widget.*\");\r\ndojo.require(\"dojo.widget.Button\");\r\n&lt;/script&gt;\r\n\r\ndojo.require 语句可指定您将要在应用程序中使用的 Dojo 资源。Dojo 引导将对页面进行扫描以查找这些 dojo.require 语句，并且将动态包括对应的库以使这些资源可供使用。动态加载进程还处理 Dojo 库之间的所有依赖关系，因此，您只需针对所使用的资源直接添加 require 语句。\r\n\r\n结合使用 Dojo 和 WebSphere Portal\r\n\r\nDojo 的独特加载策略为 Portlet 开发人员出了一道难题。Dojo 引导 dojo.js 只应在 HTML 页面中包括一次。取决于浏览器类型，如果包括 dojo.js 两次或两次以上，则会导致 JavaScript 错误并向最终用户报告这些错误。在 WebSphere Portal 中避免出现该问题的最简单的方式是：在您的主题的 JSP 中包括 dojo.js，然后根据需要在您的主题和 Portlet JSP 中放置 dojo.require 语句。\r\n\r\n然而，我希望读者在学习了示例应用程序后，能够在不需要修改其主题的情况下部署 Portlet。因此，我已在 Portlet 项目中包括 Dojo 库，并且用 JavaScript 编写了条件加载器。\r\n\r\n条件加载器包含在 dojoLoader.jsp 文件中：&lt;script type=\"text/javascript\"&gt;\r\nvar path = \"&lt;%=request.getContextPath() %&gt;/dojo/dojo.js\";\r\nif(typeof dojo==\"undefined\") {\r\ndocument.write(\'&lt;S\');\r\ndocument.write(\'CRIPT type=\\\"text/javascript\\\" src=\\\"\');\r\ndocument.write(path);\r\ndocument.write(\'\\\" &gt;&lt;\\/S\');\r\ndocument.write(\'CRIPT&gt;\');\r\n}\r\n&lt;/script&gt;\r\n\r\n此代码检查 dojo JavaScript 对象是否存在，如果未定义该对象，此代码将插入脚本，以便将 dojo.js 包括在当前 HTML 文档中。用于执行此操作的 JavaScript 代码不太好理解，因此，必须对字符串形式的 &lt;script&gt; 或 &lt;/script&gt; 的所有实例进行拆分；否则，某些浏览器会尝试将其解析为脚本的实际的起始及结束语句。而采用修改主题 JSP 这一解决方案就会简单很多。因此，请只在无法修改主题 JSP 的情况下才使用此条件加载器技术。\r\n\r\n使用 Dojo 事件\r\n\r\nDojo 包括一个事件通信系统，开发人员利用该系统可以连接应用程序的组件。传统 DOM 事件可将事件映射到任何属性、对象或元素，而该功能则超出了此范围；该功能包括了诸如面向方面的编程 (AOP) 或事件发布/订阅之类的高级功能。本文将重点讨论事件发布/订阅系统（称为主题），以及如何使用该系统以便在 Portlet 之间进行通信。\r\n\r\n在 Dojo 事件发布/订阅系统中，可以基于共享主题或队列名称以匿名的方式在组件之间进行通信。JavaScript 组件可使用 Dojo 事件库来发布或订阅主题。发布组件可以使用与事件相关的数据创建对象，然后将所创建的对象发布到主题。此时将调用该主题的任何订阅者，所发布的对象在该调用中以参数的形式进行传递，从而使订阅者对新数据做出反应；例如，订阅者可执行异步调用并（或）更新其显示。\r\n\r\n可以完整地将此设计映射到 Portlet 之间的客户端通信。由于 Portlet 应使用 &lt;portlet:namespace&gt; 标记将其 DOM 元素和 JavaScript 元素区别开来，因此，一个 Portlet 要从另一个 Portlet 的 HTML 页面中侦听 DOM 事件，就会非常困难。要解决此难题，您可以使用 Dojo 事件主题，这样，您就可以使多个 Portlet 对一个 Portlet 中的 DOM 事件做出响应，在此期间，这些 Portlet 仍能保持其各自的独立性。例如，动态 Portlet 可以执行异步调用以检索信息，然后使用事件主题向其他 Portlet 提供已更新的信息。\r\n\r\ndojo.event.topic API 的总结\r\n\r\n下文将概述 Dojo 主题 API，并描述如何使用各种方法以便在 JavaScript 组件之间进行通信。\r\ndojo.event.topic.registerPublisher (String topic, Object obj, String funcName)\r\n将函数注册为主题的发布者。在随后调用该函数时，就会将事件发布到该主题，函数的参数会传递到任何已在该主题上注册的侦听器。\r\ndojo.event.topic.publish(String topic, Object message )\r\n将所传递的对象手动发布到特定主题。然后，该对象将被传递到任何已在该主题上注册的侦听器。\r\ndojo.event.topic.subscribe(String topic, Object obj, String funcName)\r\n订阅特定主题的函数。在随后将事件发布到该主题时，将会创建一个针对已订阅函数的函数调用。侦听器在任何时候都可以订阅主题，即使在发布者未引用该主题的情况下也可以对其进行订阅。Dojo 在订阅者或发布者首次引用主题之时创建该主题。\r\ndojo.event.topic.unsubscribe(String topic, Object obj, String funcName )\r\n取消订阅特定主题的函数。\r\ndojo.event.topic.destroy(String topic)\r\n销毁该主题，并注销该主题的所有侦听器。\r\n\r\n当您引用发布者或订阅者时，主题 API 将指定对象及函数名称。使用此方法的目的是为了使用 Dojo 小部件系统，以便可以注册特定的小部件实例。如果您不打算使用小部件，则可以选择将主题订阅者实现为 JavaScript 对象或实现为简单的函数。\r\n\r\n在示例应用程序中，主题订阅者被实现为 JavaScript 对象。如果您更喜欢使用简单的 JavaScript 函数，将对象指定为 window 就可以使用简单的 JavaScript 函数。\r\n\r\n例如： dojo.event.topic.subscribe( \"/myApp/myTopic\", window, \"myHandler\");\r\n\r\n此代码将会对 \"/myApp/myTopic\" 主题进行订阅。当将事件发布到该主题时，将会调用 JavaScript 函数 myHandler，所发布的事件在该调用中以参数的形式进行传递。\r\n\r\n<a href=\"http://localhost/wordpress/wp-content/uploads/2012/05/dojoC2A.zip\">dojoC2A</a>','使用 Dojo 和 WebSphere Portal 实现客户端 Interportlet Communication','','publish','open','open','','%e4%bd%bf%e7%94%a8-dojo-%e5%92%8c-websphere-portal-%e5%ae%9e%e7%8e%b0%e5%ae%a2%e6%88%b7%e7%ab%af-interportlet-communication','','','2013-08-23 14:00:46','2013-08-23 06:00:46','',0,'http://localhost/wordpress-new/?p=104',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (105,1,'2013-08-23 14:00:46','2013-08-23 06:00:46','引言\r\n\r\n许多门户开发人员已使用 WebSphere Portal 创建用于共享事件和数据以增强用户体验的协作 Portlet。例如，在一个 Portlet 中提交的选择可导致更新的信息在多个相关的 Portlet 中显示，从而有助于这些 Portlet 在其表示中保持同步。此功能在服务器上实现，依赖于 Portlet 将操作请求提交到服务器，以使该服务器可以在页面被刷新之前执行数据传输。\r\n\r\n然而，当您将 Ajax 功能添加到 Portlet 时，此方法就变得无人问津了，因为 Ajax 功能使您可以动态更新由 Portlet 显示的数据，而不用提交操作请求或刷新页面。本文将说明如何使用 Dojo JavaScript 工具包在浏览器中共享 Portlet 之间的数据和事件，该工具包可为动态更新的 Portlet 提供协作支持。\r\n\r\n回页首\r\n\r\n什么是 Dojo？\r\n\r\nDojo 是开源 JavaScript 工具包，可用于开发动态 Web 应用程序。Dojo 的许多库中都包含 Ajax 支持、DOM 操作工具、事件处理系统和可自定义的小部件集。Dojo 将这些库与一个灵活的打包系统组合在一起，这样，您就可以只导入所需的库；Dojo 自动地为您解决了所有库与库之间的依赖关系。\r\n\r\n使用 Dojo\r\n\r\n动态打包系统正是使用 Dojo 库与使用传统 JavaScript 包含的区别所在。执行两个步骤就可以包括 Dojo 库。您将执行以下两个步骤：\r\n包括 Dojo 引导。 &lt;script type=\"text/javascript\" src=\"/path/to/dojo/dojo.js\"&gt;\r\n&lt;/script&gt;\r\n\r\n标识您的应用程序所需要的 Dojo 库。您使用 dojo.require 语句来包括 Dojo 小部件的管理功能 (dojo.widget.*) 和 Button 小部件 (dojo.widget.Button)。 &lt;script type=\"text/javascript\"&gt;\r\ndojo.require(\"dojo.widget.*\");\r\ndojo.require(\"dojo.widget.Button\");\r\n&lt;/script&gt;\r\n\r\ndojo.require 语句可指定您将要在应用程序中使用的 Dojo 资源。Dojo 引导将对页面进行扫描以查找这些 dojo.require 语句，并且将动态包括对应的库以使这些资源可供使用。动态加载进程还处理 Dojo 库之间的所有依赖关系，因此，您只需针对所使用的资源直接添加 require 语句。\r\n\r\n结合使用 Dojo 和 WebSphere Portal\r\n\r\nDojo 的独特加载策略为 Portlet 开发人员出了一道难题。Dojo 引导 dojo.js 只应在 HTML 页面中包括一次。取决于浏览器类型，如果包括 dojo.js 两次或两次以上，则会导致 JavaScript 错误并向最终用户报告这些错误。在 WebSphere Portal 中避免出现该问题的最简单的方式是：在您的主题的 JSP 中包括 dojo.js，然后根据需要在您的主题和 Portlet JSP 中放置 dojo.require 语句。\r\n\r\n然而，我希望读者在学习了示例应用程序后，能够在不需要修改其主题的情况下部署 Portlet。因此，我已在 Portlet 项目中包括 Dojo 库，并且用 JavaScript 编写了条件加载器。\r\n\r\n条件加载器包含在 dojoLoader.jsp 文件中：&lt;script type=\"text/javascript\"&gt;\r\nvar path = \"&lt;%=request.getContextPath() %&gt;/dojo/dojo.js\";\r\nif(typeof dojo==\"undefined\") {\r\ndocument.write(\'&lt;S\');\r\ndocument.write(\'CRIPT type=\\\"text/javascript\\\" src=\\\"\');\r\ndocument.write(path);\r\ndocument.write(\'\\\" &gt;&lt;\\/S\');\r\ndocument.write(\'CRIPT&gt;\');\r\n}\r\n&lt;/script&gt;\r\n\r\n此代码检查 dojo JavaScript 对象是否存在，如果未定义该对象，此代码将插入脚本，以便将 dojo.js 包括在当前 HTML 文档中。用于执行此操作的 JavaScript 代码不太好理解，因此，必须对字符串形式的 &lt;script&gt; 或 &lt;/script&gt; 的所有实例进行拆分；否则，某些浏览器会尝试将其解析为脚本的实际的起始及结束语句。而采用修改主题 JSP 这一解决方案就会简单很多。因此，请只在无法修改主题 JSP 的情况下才使用此条件加载器技术。\r\n\r\n使用 Dojo 事件\r\n\r\nDojo 包括一个事件通信系统，开发人员利用该系统可以连接应用程序的组件。传统 DOM 事件可将事件映射到任何属性、对象或元素，而该功能则超出了此范围；该功能包括了诸如面向方面的编程 (AOP) 或事件发布/订阅之类的高级功能。本文将重点讨论事件发布/订阅系统（称为主题），以及如何使用该系统以便在 Portlet 之间进行通信。\r\n\r\n在 Dojo 事件发布/订阅系统中，可以基于共享主题或队列名称以匿名的方式在组件之间进行通信。JavaScript 组件可使用 Dojo 事件库来发布或订阅主题。发布组件可以使用与事件相关的数据创建对象，然后将所创建的对象发布到主题。此时将调用该主题的任何订阅者，所发布的对象在该调用中以参数的形式进行传递，从而使订阅者对新数据做出反应；例如，订阅者可执行异步调用并（或）更新其显示。\r\n\r\n可以完整地将此设计映射到 Portlet 之间的客户端通信。由于 Portlet 应使用 &lt;portlet:namespace&gt; 标记将其 DOM 元素和 JavaScript 元素区别开来，因此，一个 Portlet 要从另一个 Portlet 的 HTML 页面中侦听 DOM 事件，就会非常困难。要解决此难题，您可以使用 Dojo 事件主题，这样，您就可以使多个 Portlet 对一个 Portlet 中的 DOM 事件做出响应，在此期间，这些 Portlet 仍能保持其各自的独立性。例如，动态 Portlet 可以执行异步调用以检索信息，然后使用事件主题向其他 Portlet 提供已更新的信息。\r\n\r\ndojo.event.topic API 的总结\r\n\r\n下文将概述 Dojo 主题 API，并描述如何使用各种方法以便在 JavaScript 组件之间进行通信。\r\ndojo.event.topic.registerPublisher (String topic, Object obj, String funcName)\r\n将函数注册为主题的发布者。在随后调用该函数时，就会将事件发布到该主题，函数的参数会传递到任何已在该主题上注册的侦听器。\r\ndojo.event.topic.publish(String topic, Object message )\r\n将所传递的对象手动发布到特定主题。然后，该对象将被传递到任何已在该主题上注册的侦听器。\r\ndojo.event.topic.subscribe(String topic, Object obj, String funcName)\r\n订阅特定主题的函数。在随后将事件发布到该主题时，将会创建一个针对已订阅函数的函数调用。侦听器在任何时候都可以订阅主题，即使在发布者未引用该主题的情况下也可以对其进行订阅。Dojo 在订阅者或发布者首次引用主题之时创建该主题。\r\ndojo.event.topic.unsubscribe(String topic, Object obj, String funcName )\r\n取消订阅特定主题的函数。\r\ndojo.event.topic.destroy(String topic)\r\n销毁该主题，并注销该主题的所有侦听器。\r\n\r\n当您引用发布者或订阅者时，主题 API 将指定对象及函数名称。使用此方法的目的是为了使用 Dojo 小部件系统，以便可以注册特定的小部件实例。如果您不打算使用小部件，则可以选择将主题订阅者实现为 JavaScript 对象或实现为简单的函数。\r\n\r\n在示例应用程序中，主题订阅者被实现为 JavaScript 对象。如果您更喜欢使用简单的 JavaScript 函数，将对象指定为 window 就可以使用简单的 JavaScript 函数。\r\n\r\n例如： dojo.event.topic.subscribe( \"/myApp/myTopic\", window, \"myHandler\");\r\n\r\n此代码将会对 \"/myApp/myTopic\" 主题进行订阅。当将事件发布到该主题时，将会调用 JavaScript 函数 myHandler，所发布的事件在该调用中以参数的形式进行传递。\r\n\r\n<a href=\"http://localhost/wordpress/wp-content/uploads/2012/05/dojoC2A.zip\">dojoC2A</a>','使用 Dojo 和 WebSphere Portal 实现客户端 Interportlet Communication','','inherit','open','open','','104-revision-v1','','','2013-08-23 14:00:46','2013-08-23 06:00:46','',104,'http://localhost/wordpress-new/?p=105',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (106,1,'2013-08-23 14:01:13','2013-08-23 06:01:13','在过去三年中，企业面临着信息、流程的整合问题，\"企业门户\"和\"企业应用集成\"一时间成了IT业内热门的课题。国内外IT厂商和开源组织顺时而动，开发了各种企业门户服务器。单是Java阵营，IBM公司发布了WebSphere Portal Server 1.2/2.1/4.x/5.x, Apache Software Foundation推出了JetSpeed、BEA、Oracle、SAP、Sun也推出了各自的Portal服务器。这些Portal服务器各自提供不同的Java API给应用系统开发商开发Portlet，应用系统开发人员不得不为不同的Portal服务器使用互不通用的API开发功能相同的Portlet。人们翘首以待，希望有一天能象编写Java Servlet那样，使用一种API编写能运行在大多数Portal服务器上的Portlet应用。\r\n\r\n经过近两年时间的漫长等待，2003年10月7日，Java Community Process(JCP)发布了JSR168: Portlet Specification 1.0的最终版本。该规范包含如下内容(参见 参考3)\r\n定义了portlet运行环境 - portlet容器\r\n定义了portlet容器和portlet之间的API\r\n提供了portlet存储持久性和非持久性数据的机制\r\n提供了portlet包含servlet和JSP的机制\r\n定义了portlet打包，方便部署\r\n保证了portlet在JSR 168门户中的二进制移植\r\n能够以WSRP协议把JSR 168 portlet作为远程portlet运行。\r\n\r\nJSR 168规范获得了业内的广泛支持，JSR 168专家组包括主要的Portal厂商，包括Apache、BEA、 IBM、 Oracle、 Sun等公司和组织。IBM在Apache以开放源码项目的方式提供了该规范的参考实现pluto，并在WebSphere Portal Server 5.0.2中提供了JSR 168的支持。\r\n\r\n本文以Hello World为例，介绍如何使用JSR 168 API编写portlet，打包成portlet应用 源码包下载，部署portlet应用到portlet容器上。最后给出JSR 168的参考实现－Apache pluto的安装配置。\r\n\r\n现在让我们开始吧。\r\n\r\n一、 创建项目的目录结构\r\n\r\nportlet项目的最基本的几个目录是：\r\nHelloWorld\\JavaSource 放置Java源代码\r\nHelloWorld\\WebContent\\Web-INF\\classes 放置Java Class文件\r\nHelloWorld\\WebContent\\Web-INF\\lib放置jar文件，比如jstl.jar 、standard.jar (JSTL - JSP Standard Tag Library及Apache的JSTL的实现)\r\nHelloWorld\\WebContent\\Web-INF\\tld 放置taglib定义文件，比如portlet.tld或者portlet.tld(portlet JSP tag)这些目录下面的jar文件和tld文件可以从安装好的pluto中找到。\r\n\r\n二、创建Portlet Java代码\r\n\r\n下面是HelloWorldPortlet.java的代码。相关连的另外两个Java源文件，在本文末尾有 源码包下载的链接。\r\n\r\n注意：\r\n\r\n1.import语句，这里使用的全部是java或者javax标准类库，说明这个portlet代码应该是可以运行在支持相应标准的服务器上面。\r\n\r\n2.对于一些常量，使用了public static final修饰符。有助于提供java代码的性能。\r\n\r\n3.processAction方法是Portlet的核心方法之一，例子代码在这里处理jsp中FORM表单提交的数据，并把得到的数据放到一个Java Bean中，该Java Bean又被放到PortletSession中供jsp文件调用。\r\nproccessAction处理完毕后，portlet引擎会运行portlet的doView方法。doView方法根据逻辑、输入数据或者配置，调用不同的jsp文件进行数据展示。 package com.ibm.spc;\r\nimport java.io.*;\r\nimport javax.portlet.*;\r\n/**\r\n*\r\n* A sample portlet based on GenericPortlet\r\n*\r\n*/\r\npublic class HelloWorldPortlet extends GenericPortlet {\r\npublic static final String JSP_FOLDER\r\n= \"/com_ibm_spc/jsp/\"; // JSP folder name\r\npublic static final String VIEW_JSP\r\n= \"HelloWorldPortletView\";\r\n// JSP file name to be rendered on the view mode\r\npublic static final String VIEW_BEAN\r\n= \"HelloWorldPortletBean\";\r\n// Bean name for the view mode request\r\npublic static final String SAY_HELLO_ACTION\r\n= \"Say_Hellow_Action\"; // Action name for submit form\r\npublic static final String YOUR_NAME\r\n= \"YourName\"; // Parameter name for the text input\r\n/**\r\n* Serve up the &lt;code&gt;view&lt;/code&gt; mode.\r\n*\r\n* @see javax.portlet.GenericPortlet\r\n* #doView(javax.portlet.RenderRequest, javax.portlet.RenderResponse)\r\n*/\r\npublic void doView(RenderRequest request,\r\nRenderResponse response)\r\nthrows PortletException, IOException {\r\n// Set the MIME type for the render response\r\nresponse.setContentType(request.getResponseContentType());\r\n// Invoke the JSP to render\r\nPortletRequestDispatcher rd =\r\ngetPortletContext().getRequestDispatcher(getJspFilePath(request,\r\nVIEW_JSP));\r\nrd.include(request,response);\r\n}\r\n/**\r\n* Process an action request.\r\n*\r\n* @see javax.portlet.Portlet#processAction(javax.portlet.ActionRequest,\r\n* javax.portlet.ActionResponse)\r\n*/\r\npublic void processAction(ActionRequest request,\r\nActionResponse response)\r\nthrows PortletException, java.io.IOException {\r\nif( request.getParameter(SAY_HELLO_ACTION) != null ) {\r\n// Make a session bean\r\nPortletSession session = request.getPortletSession();\r\nHelloWorldPortletBean viewBean = new HelloWorldPortletBean();\r\nsession.setAttribute(VIEW_BEAN, viewBean);\r\n\r\nSystem.out.println(\"debug HelloWorld \"\r\n+ request.getParameter(YOUR_NAME));\r\n\r\n// Set form text in the view bean\r\nviewBean.setFormText(request.getParameter(YOUR_NAME));\r\n}\r\n}\r\n/**\r\n* Returns JSP file path.\r\n*\r\n* @param request Render request\r\n* @param jspFile JSP file name\r\n* @return JSP file path\r\n*/\r\nprivate static String\r\ngetJspFilePath(RenderRequest request, String jspFile) {\r\nString markup = request.getProperty(\"wps.markup\");\r\nif( markup == null )\r\nmarkup = getMarkup(request.getResponseContentType());\r\nreturn JSP_FOLDER+markup+\"/\"+jspFile+\".\"+\r\ngetJspExtension(markup);\r\n}\r\n\r\n/**\r\n* Convert MIME type to markup name.\r\n*\r\n* @param contentType MIME type\r\n* @return Markup name\r\n*/\r\nprivate static String getMarkup(String contentType) {\r\nif( \"text/vnd.wap.wml\".equals(contentType) )\r\nreturn \"wml\";\r\nreturn \"html\";\r\n}\r\n/**\r\n* Returns the file extension for the JSP file\r\n*\r\n* @param markupName Markup name\r\n* @return JSP extension\r\n*/\r\nprivate static String getJspExtension(String markupName) {\r\nreturn \"jsp\";\r\n}\r\n}\r\n\r\n三、创建JSP\r\n\r\njsp文件中首先声明它不需要创建新的HTTP Session，返回页面的内容是html页面。然后import声明需要引用标准java类库java.util，javax.portlet，以及我们自己的类库com.ibm.spc。接着声明使用portlet标记库。&lt;portlet:defineObjects/&gt;使用portlet标记库的标记defineObjects，定义了jsp中要使用3个变量：RenderRequest renderRequest\r\nRenderResponse renderResponse\r\nPortletConfig portletConfig\r\n\r\n&lt;%@ page session=\"false\" import=\"java.util.*,javax.portlet.*,com.ibm.spc.*\" %&gt;\r\n&lt;%@taglib uri=\"http://java.sun.com/portlet\" prefix=\"portlet\" %&gt;\r\n&lt;portlet:defineObjects/&gt;\r\n\r\n接下来，从&lt;portlet:defineObjects/&gt;语句定义的变量renderRequest当中获取PortletSession，进而得到session当中保存的数据并显示在JSP页面上。 &lt;%\r\nPortletSession session = renderRequest.getPortletSession();\r\n\r\nHelloWorldPortletBean bean =\r\n(HelloWorldPortletBean)session.getAttribute\r\n(HelloWorldPortlet.VIEW_BEAN);\r\n%&gt;\r\nif (bean != null) {\r\nString formText = bean.getFormText();\r\nif( formText.length()&gt;0 ) {\r\n%&gt;\r\nHello &lt;%=formText%&gt;.\r\n&lt;%\r\n}\r\n}\r\n%&gt;\r\n\r\n最后部分是使用portlet标记库的另一个标记actionURL产生一个URL指向当前页面中的这个portlet，生成的URL能够触发当前portlet的action请求，或者说这个URL能够触发当前portlet的processAction方法。 &lt;FORM method=\"POST\" action=\"&lt;portlet:actionURL/&gt;\"&gt;\r\n&lt;LABEL for=\"&lt;%=HelloWorldPortlet.YOUR_NAME%&gt;\"&gt;Please input your name here, &lt;/LABEL&gt;&lt;BR&gt;\r\n&lt;INPUT name=\"&lt;%=HelloWorldPortlet.YOUR_NAME%&gt;\" type=\"text\"/&gt;\r\n&lt;INPUT name=\"&lt;%=HelloWorldPortlet.SAY_HELLO_ACTION%&gt;\" type=\"submit\" value=\"Submit\"/&gt;\r\n&lt;/FORM&gt;\r\n\r\n五、 创建Web应用的部署描述文件\r\n\r\nPortlet应用也是一个J2EE Web应用，拥有一个Web应用部署描述文件web.xml。web.xml文件中taglib标记部分是关于Portlet Tag Library的定义，在Portlet 应用的jsp文件中可以使用这种Tag Lib。\r\n\r\n下面代码片断声明使用uri是 http://java.sun.com/portlet的tag lib，tag lib的前缀是portlet。关于Portlet Tag Library请参考Java Portlet Specification。\r\n\r\n注意：2004年2月的pluto中portlet部署程序中不能分析处理web.xml文件中welcome-file的标记，相信Apache会在后继的版本中修正这个问题。解决办法是，或者从web.xml文件中去除有关的tag；或者修改pluto代码，为servletdefinitionmapping.xml文件添加welcome-file标记，为org.apache.pluto.portalImpl.om.servlet.impl. WebApplicationDefinitionImpl java类添加一个字段来解决这个问题。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems,\r\nInc.//DTD Web Application 2.3//EN\"\r\n\"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt;\r\n&lt;web-app id=\"WebApp\"&gt;\r\n&lt;display-name&gt;HelloWorld Web Application\r\n&lt;/display-name&gt;\r\n&lt;taglib id=\"PortletTLD\"&gt;\r\n&lt;taglib-uri&gt;http://java.sun.com/portlet\r\n&lt;/taglib-uri&gt;\r\n&lt;taglib-location&gt;/WEB-INF/tld/portlet.tld\r\n&lt;/taglib-location&gt;\r\n&lt;/taglib&gt;\r\n&lt;/web-app&gt;\r\n\r\n六、 创建Portlet部署描述文件\r\n\r\n每个Portlet应用除了Web应用部署描述文件web.xml外，还有一个Portlet部署描述文件 - portlet.xml。该文件中包括该Portlet Application中一个或者多个portlet的定义。\r\n\r\n下面的portlet.xml文件中首先是&lt;portlet-app/&gt;，其中引用了sun公司的关于portlet描述文件的名字空间的定义文件portlet-app_1_0.xsd。然后是各个&lt;portlet/&gt;定义，包括名字和描述信息，国际化的名字和描述信息，portlet的class类名，portlet的初始化参数、国际化用户界面中使用的资源文件。HelloWorld Portlet有一个初始化参数wps.markup，在我们的portlet代码中使用renderRequest.getProperty(\"wps.markup\")获得这个初始化参数的值。\r\n\r\n七、 创建war文件\r\n\r\n我们使用JDK的命令jar把class文件、jsp文件、jar包、JSP标记库、web部署描述文件web.xml、portlet部署描述文件portlet.xml等打包成web archive文件。set JAVA_HOME=C:\\WebSphere\\AppServer\\java\r\nset PATH=%JAVA_HOME%\\bin\r\ncd WebContent\r\njar cf ..\\build\\HelloWorld.war .\r\n\r\n然后可以 使用portal管理器添加到portlet容器就可以测试了 具体的测试这里就不在叙述','Hello World，一个简单的JSR 168 portlet','','publish','open','open','','hello-world%ef%bc%8c%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84jsr-168-portlet','','','2013-08-23 14:01:13','2013-08-23 06:01:13','',0,'http://localhost/wordpress-new/?p=106',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (107,1,'2013-08-23 14:01:13','2013-08-23 06:01:13','在过去三年中，企业面临着信息、流程的整合问题，\"企业门户\"和\"企业应用集成\"一时间成了IT业内热门的课题。国内外IT厂商和开源组织顺时而动，开发了各种企业门户服务器。单是Java阵营，IBM公司发布了WebSphere Portal Server 1.2/2.1/4.x/5.x, Apache Software Foundation推出了JetSpeed、BEA、Oracle、SAP、Sun也推出了各自的Portal服务器。这些Portal服务器各自提供不同的Java API给应用系统开发商开发Portlet，应用系统开发人员不得不为不同的Portal服务器使用互不通用的API开发功能相同的Portlet。人们翘首以待，希望有一天能象编写Java Servlet那样，使用一种API编写能运行在大多数Portal服务器上的Portlet应用。\r\n\r\n经过近两年时间的漫长等待，2003年10月7日，Java Community Process(JCP)发布了JSR168: Portlet Specification 1.0的最终版本。该规范包含如下内容(参见 参考3)\r\n定义了portlet运行环境 - portlet容器\r\n定义了portlet容器和portlet之间的API\r\n提供了portlet存储持久性和非持久性数据的机制\r\n提供了portlet包含servlet和JSP的机制\r\n定义了portlet打包，方便部署\r\n保证了portlet在JSR 168门户中的二进制移植\r\n能够以WSRP协议把JSR 168 portlet作为远程portlet运行。\r\n\r\nJSR 168规范获得了业内的广泛支持，JSR 168专家组包括主要的Portal厂商，包括Apache、BEA、 IBM、 Oracle、 Sun等公司和组织。IBM在Apache以开放源码项目的方式提供了该规范的参考实现pluto，并在WebSphere Portal Server 5.0.2中提供了JSR 168的支持。\r\n\r\n本文以Hello World为例，介绍如何使用JSR 168 API编写portlet，打包成portlet应用 源码包下载，部署portlet应用到portlet容器上。最后给出JSR 168的参考实现－Apache pluto的安装配置。\r\n\r\n现在让我们开始吧。\r\n\r\n一、 创建项目的目录结构\r\n\r\nportlet项目的最基本的几个目录是：\r\nHelloWorld\\JavaSource 放置Java源代码\r\nHelloWorld\\WebContent\\Web-INF\\classes 放置Java Class文件\r\nHelloWorld\\WebContent\\Web-INF\\lib放置jar文件，比如jstl.jar 、standard.jar (JSTL - JSP Standard Tag Library及Apache的JSTL的实现)\r\nHelloWorld\\WebContent\\Web-INF\\tld 放置taglib定义文件，比如portlet.tld或者portlet.tld(portlet JSP tag)这些目录下面的jar文件和tld文件可以从安装好的pluto中找到。\r\n\r\n二、创建Portlet Java代码\r\n\r\n下面是HelloWorldPortlet.java的代码。相关连的另外两个Java源文件，在本文末尾有 源码包下载的链接。\r\n\r\n注意：\r\n\r\n1.import语句，这里使用的全部是java或者javax标准类库，说明这个portlet代码应该是可以运行在支持相应标准的服务器上面。\r\n\r\n2.对于一些常量，使用了public static final修饰符。有助于提供java代码的性能。\r\n\r\n3.processAction方法是Portlet的核心方法之一，例子代码在这里处理jsp中FORM表单提交的数据，并把得到的数据放到一个Java Bean中，该Java Bean又被放到PortletSession中供jsp文件调用。\r\nproccessAction处理完毕后，portlet引擎会运行portlet的doView方法。doView方法根据逻辑、输入数据或者配置，调用不同的jsp文件进行数据展示。 package com.ibm.spc;\r\nimport java.io.*;\r\nimport javax.portlet.*;\r\n/**\r\n*\r\n* A sample portlet based on GenericPortlet\r\n*\r\n*/\r\npublic class HelloWorldPortlet extends GenericPortlet {\r\npublic static final String JSP_FOLDER\r\n= \"/com_ibm_spc/jsp/\"; // JSP folder name\r\npublic static final String VIEW_JSP\r\n= \"HelloWorldPortletView\";\r\n// JSP file name to be rendered on the view mode\r\npublic static final String VIEW_BEAN\r\n= \"HelloWorldPortletBean\";\r\n// Bean name for the view mode request\r\npublic static final String SAY_HELLO_ACTION\r\n= \"Say_Hellow_Action\"; // Action name for submit form\r\npublic static final String YOUR_NAME\r\n= \"YourName\"; // Parameter name for the text input\r\n/**\r\n* Serve up the &lt;code&gt;view&lt;/code&gt; mode.\r\n*\r\n* @see javax.portlet.GenericPortlet\r\n* #doView(javax.portlet.RenderRequest, javax.portlet.RenderResponse)\r\n*/\r\npublic void doView(RenderRequest request,\r\nRenderResponse response)\r\nthrows PortletException, IOException {\r\n// Set the MIME type for the render response\r\nresponse.setContentType(request.getResponseContentType());\r\n// Invoke the JSP to render\r\nPortletRequestDispatcher rd =\r\ngetPortletContext().getRequestDispatcher(getJspFilePath(request,\r\nVIEW_JSP));\r\nrd.include(request,response);\r\n}\r\n/**\r\n* Process an action request.\r\n*\r\n* @see javax.portlet.Portlet#processAction(javax.portlet.ActionRequest,\r\n* javax.portlet.ActionResponse)\r\n*/\r\npublic void processAction(ActionRequest request,\r\nActionResponse response)\r\nthrows PortletException, java.io.IOException {\r\nif( request.getParameter(SAY_HELLO_ACTION) != null ) {\r\n// Make a session bean\r\nPortletSession session = request.getPortletSession();\r\nHelloWorldPortletBean viewBean = new HelloWorldPortletBean();\r\nsession.setAttribute(VIEW_BEAN, viewBean);\r\n\r\nSystem.out.println(\"debug HelloWorld \"\r\n+ request.getParameter(YOUR_NAME));\r\n\r\n// Set form text in the view bean\r\nviewBean.setFormText(request.getParameter(YOUR_NAME));\r\n}\r\n}\r\n/**\r\n* Returns JSP file path.\r\n*\r\n* @param request Render request\r\n* @param jspFile JSP file name\r\n* @return JSP file path\r\n*/\r\nprivate static String\r\ngetJspFilePath(RenderRequest request, String jspFile) {\r\nString markup = request.getProperty(\"wps.markup\");\r\nif( markup == null )\r\nmarkup = getMarkup(request.getResponseContentType());\r\nreturn JSP_FOLDER+markup+\"/\"+jspFile+\".\"+\r\ngetJspExtension(markup);\r\n}\r\n\r\n/**\r\n* Convert MIME type to markup name.\r\n*\r\n* @param contentType MIME type\r\n* @return Markup name\r\n*/\r\nprivate static String getMarkup(String contentType) {\r\nif( \"text/vnd.wap.wml\".equals(contentType) )\r\nreturn \"wml\";\r\nreturn \"html\";\r\n}\r\n/**\r\n* Returns the file extension for the JSP file\r\n*\r\n* @param markupName Markup name\r\n* @return JSP extension\r\n*/\r\nprivate static String getJspExtension(String markupName) {\r\nreturn \"jsp\";\r\n}\r\n}\r\n\r\n三、创建JSP\r\n\r\njsp文件中首先声明它不需要创建新的HTTP Session，返回页面的内容是html页面。然后import声明需要引用标准java类库java.util，javax.portlet，以及我们自己的类库com.ibm.spc。接着声明使用portlet标记库。&lt;portlet:defineObjects/&gt;使用portlet标记库的标记defineObjects，定义了jsp中要使用3个变量：RenderRequest renderRequest\r\nRenderResponse renderResponse\r\nPortletConfig portletConfig\r\n\r\n&lt;%@ page session=\"false\" import=\"java.util.*,javax.portlet.*,com.ibm.spc.*\" %&gt;\r\n&lt;%@taglib uri=\"http://java.sun.com/portlet\" prefix=\"portlet\" %&gt;\r\n&lt;portlet:defineObjects/&gt;\r\n\r\n接下来，从&lt;portlet:defineObjects/&gt;语句定义的变量renderRequest当中获取PortletSession，进而得到session当中保存的数据并显示在JSP页面上。 &lt;%\r\nPortletSession session = renderRequest.getPortletSession();\r\n\r\nHelloWorldPortletBean bean =\r\n(HelloWorldPortletBean)session.getAttribute\r\n(HelloWorldPortlet.VIEW_BEAN);\r\n%&gt;\r\nif (bean != null) {\r\nString formText = bean.getFormText();\r\nif( formText.length()&gt;0 ) {\r\n%&gt;\r\nHello &lt;%=formText%&gt;.\r\n&lt;%\r\n}\r\n}\r\n%&gt;\r\n\r\n最后部分是使用portlet标记库的另一个标记actionURL产生一个URL指向当前页面中的这个portlet，生成的URL能够触发当前portlet的action请求，或者说这个URL能够触发当前portlet的processAction方法。 &lt;FORM method=\"POST\" action=\"&lt;portlet:actionURL/&gt;\"&gt;\r\n&lt;LABEL for=\"&lt;%=HelloWorldPortlet.YOUR_NAME%&gt;\"&gt;Please input your name here, &lt;/LABEL&gt;&lt;BR&gt;\r\n&lt;INPUT name=\"&lt;%=HelloWorldPortlet.YOUR_NAME%&gt;\" type=\"text\"/&gt;\r\n&lt;INPUT name=\"&lt;%=HelloWorldPortlet.SAY_HELLO_ACTION%&gt;\" type=\"submit\" value=\"Submit\"/&gt;\r\n&lt;/FORM&gt;\r\n\r\n五、 创建Web应用的部署描述文件\r\n\r\nPortlet应用也是一个J2EE Web应用，拥有一个Web应用部署描述文件web.xml。web.xml文件中taglib标记部分是关于Portlet Tag Library的定义，在Portlet 应用的jsp文件中可以使用这种Tag Lib。\r\n\r\n下面代码片断声明使用uri是 http://java.sun.com/portlet的tag lib，tag lib的前缀是portlet。关于Portlet Tag Library请参考Java Portlet Specification。\r\n\r\n注意：2004年2月的pluto中portlet部署程序中不能分析处理web.xml文件中welcome-file的标记，相信Apache会在后继的版本中修正这个问题。解决办法是，或者从web.xml文件中去除有关的tag；或者修改pluto代码，为servletdefinitionmapping.xml文件添加welcome-file标记，为org.apache.pluto.portalImpl.om.servlet.impl. WebApplicationDefinitionImpl java类添加一个字段来解决这个问题。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems,\r\nInc.//DTD Web Application 2.3//EN\"\r\n\"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt;\r\n&lt;web-app id=\"WebApp\"&gt;\r\n&lt;display-name&gt;HelloWorld Web Application\r\n&lt;/display-name&gt;\r\n&lt;taglib id=\"PortletTLD\"&gt;\r\n&lt;taglib-uri&gt;http://java.sun.com/portlet\r\n&lt;/taglib-uri&gt;\r\n&lt;taglib-location&gt;/WEB-INF/tld/portlet.tld\r\n&lt;/taglib-location&gt;\r\n&lt;/taglib&gt;\r\n&lt;/web-app&gt;\r\n\r\n六、 创建Portlet部署描述文件\r\n\r\n每个Portlet应用除了Web应用部署描述文件web.xml外，还有一个Portlet部署描述文件 - portlet.xml。该文件中包括该Portlet Application中一个或者多个portlet的定义。\r\n\r\n下面的portlet.xml文件中首先是&lt;portlet-app/&gt;，其中引用了sun公司的关于portlet描述文件的名字空间的定义文件portlet-app_1_0.xsd。然后是各个&lt;portlet/&gt;定义，包括名字和描述信息，国际化的名字和描述信息，portlet的class类名，portlet的初始化参数、国际化用户界面中使用的资源文件。HelloWorld Portlet有一个初始化参数wps.markup，在我们的portlet代码中使用renderRequest.getProperty(\"wps.markup\")获得这个初始化参数的值。\r\n\r\n七、 创建war文件\r\n\r\n我们使用JDK的命令jar把class文件、jsp文件、jar包、JSP标记库、web部署描述文件web.xml、portlet部署描述文件portlet.xml等打包成web archive文件。set JAVA_HOME=C:\\WebSphere\\AppServer\\java\r\nset PATH=%JAVA_HOME%\\bin\r\ncd WebContent\r\njar cf ..\\build\\HelloWorld.war .\r\n\r\n然后可以 使用portal管理器添加到portlet容器就可以测试了 具体的测试这里就不在叙述','Hello World，一个简单的JSR 168 portlet','','inherit','open','open','','106-revision-v1','','','2013-08-23 14:01:13','2013-08-23 06:01:13','',106,'http://localhost/wordpress-new/?p=107',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (108,1,'2013-08-23 14:01:35','2013-08-23 06:01:35','一、 Portlet简介\r\n\r\nPortlet与servlet一样，都是jcr的规范api定义，不同的portlet还比较“年轻”，目前版本还只到2.0，而servlet规范已经相当成熟，发布了多个版本。如果不是十分准确的说，portlet只是另一种开发web程序的api，从这个方面说，开发portlet并没有什么神秘的地方，但是之所以有portlet这个规范，portlet适用的场景肯定与servlet是不同的，比如开发portlet不但要与portlet容器打交道，还要与portal打交道。读者在学习portlet开发的过程中，可以不时的用servlet的概念与portlet相比较，比较两者的异同，可以达到事半功倍的效果。\r\n\r\n刚才说到portlet规范已经出到2.0，分别是jsr168，jsr286。JSR 168 目前在业界受到广泛支持，目前我们开发的大部分代码都是基于jsr168的，jsr168规范支持基本的开发方式，虽然提供的功能比较少，但是已经基本可以满足日常需要。Jsr168发布三年之后，大多数支持 Java Portlet Specification V1.0 的门户产品都提供一些附加扩展，以支持更高级的用例，这些附加的扩展造成了各个门户产品的标准不统一，彼此间的交互协作成了不可避免的问题。为了更好地规范 portlet 开发，以适应业界发展，并提供适应于最高级别用例的标准解决方案，从而为这些高级功能提供互操作性，在 2005 年 11 月开始了 Java Portlet Specification V2.0（称为 JSR 286）的开发，在2008年1月Java Portlet Specification V2.0 目前已经正式发布。JSR 286规范兼容了 JSR 168，并完善了 JSR 168 的部分功能，并提供了诸多 JSR 168 所没有的新特性，例如资源服务、事件、portlet 过滤器、共享呈现参数及 portlet 窗口等。与 V1.0 类似，V2.0 也将基于 J2EE 1.4，因此可让 Portlet 使用 J2EE 1.4 增强（如 JSP 2.0）。下面是该新规范的一些主要功能及特性：\r\n资源服务：一种新的通过 portlet 呈现资源的方式。\r\n事件：通过发送事件和接收事件来实现 portlet 之间的通信。\r\nPortlet 过滤器：与 servlet 过滤器类似，根据 Portlet 请求和响应动态的呈现内容的变换。存在以下四种类型的 portlet 过滤器：\r\nAction 过滤器\r\nRender 过滤器\r\nResource 过滤器\r\nEvent 过滤器\r\n共享呈现参数：除了 portlet 私有的呈现参数之外，新增了可以在 portlet 之间共享的呈现参数。\r\nPortlet 窗口：提供 portlet 窗口 ID 供 portlet 使用\r\n\r\n要讲解portlet，首先要明确三个概念：portal、portlet、portlet容器。Portlet与portlet容器的关系可以比较servlet与servlet容器的关系，两者是完全一致的，开发者按照portlet规范开发portlet，部署在中间件提供商（ibm、oracle、apache）提供的portlet容器中运行，比较难理解的是portal，首先portal是一个JEE的application，portal负责提供页面给客户，其次portal里面的内容是portlet生成出来的。一般的过程是，用户通过web客户端向portal发起http请求，portal解析这些请求，把请求“下发”给portlet容器，portlet容器来调用portlet，由portlet产生输出返回给portlet容器，portlet容器再把输出返回给portal，portal负责把这些portlet的输出聚集起来，把内容返回给web客户端。下面来具体描述一下portal、portlet、portlet容器三个概念。\r\n什么是portal\r\n\r\nPortlet规范中是这样定义portal的：\r\nA portal is a web based application that –commonly- provides personalization, authentication,, content aggregation from different sources and hosts the presentation layer of Information Systems.\r\n\r\nPortal是一个基于web的提供个性化、登录授权、从不同的数据源聚集内容基于展现层的信息系统。具体到J2EE领域，portal大多数情况是一个符合J2EE标准的ear包工程。\r\n什么是portlet\r\n\r\n规范中式这样定义portlet的：\r\nA portlet is an application that provides a specific piece of content (information or service) to be included as part of a portal page. It is managed by a portlet container, that processes requests and generates dynamic content\r\n\r\n一个Portlet是一个基于java技术的被portlet容器管理的web组建，它可以处理requests、生成动态的内容输出，一个portlet负责提供portal 页面中的某个特定部位的展现内容。\r\n\r\n与servlet同样，portlet的生命周期是被portlet容器来管理的。Portlet生成的内容也可以称作fragment，这些多个portlet生成的多个fragment会被portal聚集（aggregate）在一起展现。不同用户看到的portlet可能不同，这依赖于不同用户对使用portlet的配置。\r\n什么是portlet容器\r\n\r\n规范中式这样定义portlet容器的\r\nA portlet container runs portlets and provides them with the required runtime environment. A portlet container contains portlets and manages their lifecycle. It also provides persistent storage for portlet preferences. A portlet container receives requests from the portal to execute requests on the portlets hosted by it.\r\n\r\nPortlet容器提供portlet生命周期环境，管理portlet的生命周期，还提供portlet preferences的持久化支持，portlet从portal接受请求，然后分发给运行其上的portlet。\r\n\r\nPortlet不负责聚集portlet生成的内容，这是portal责任。根据中间件厂商的实现方式portlet容器与portal可以放在一个application中实现，也可以放在两个不同的application中实现。\r\n三者关系\r\n\r\n下面是以一个用户使用web客户端来与portal交互的用力，描述portlet、portlet容器、portal三者关系、责任：\r\n\r\n1. web客户端通过http 来对portal发起request请求\r\n\r\n2. request请求被portal就收到\r\n\r\n3. portal分析这个请求是否需要与portlet进行交互\r\n\r\n4. 如果需要，则portal通知portlet容器调用portlet处理交互\r\n\r\n5. Portal通过portlet容器得到portlet返回的fragments\r\n\r\n6. Portal聚集portlet产生的fragments，生成最终的页面，返回给web客户端\r\n版本兼容性\r\n\r\nJsr286规范是向后兼容的，所以所有基于jsr168写的代码生成的war都可以在jsr286容器里面运行。不过下面罗列出一些特例，这些特例会在具体章节说明。\r\n\r\n1. RenderResponse.setContentType已经不再需要在getWriter 或者getOutputstream之前调用了，已经不会产生IllegalStateException\r\n\r\n2. 对于在portlet工程中嵌入servlet、jsp调用getProtocol，jsr168中返回时null，jsr286中返回时HTTP/1.1\r\nJSR286的主要新特性\r\n\r\nJsr286对Jsr168是向后兼容的，jsr286主要增加了如下新特性：\r\n\r\nØ 事件Events，可以是portlet可以接受、发送事件\r\n\r\nØ 公共展现参数public render parameters，容许portlet之间共享参数\r\n\r\nØ 资源服务 resource serving ，提供portlet服务资源的能力\r\n\r\nØ Portlet 拦截器 portlet filter，容许在portlet的request、response之间建立拦截器\r\n\r\n二、 与servlet规范的关系\r\n\r\nServlet规范中是这样定义的：\r\nA servlet is a Java technology based web component, managed by a container, that generates dynamic content. Like other Java-based components, servlets are platform independent Java classes that are compiled to platform neutral bytecode that can be loaded dynamically into and run by a Java enabled web server. Containers, sometimes called servlet engines, are web server extensions that provide servlet functionality. Servlets interact with web clients via a request/response paradigm implemented by the servlet container.\r\n\r\nServetl是居于java技术的web组件，被servlet容器管理，生成动态内容。Servlet通过servlet容器与web客户端展开request、response交互。\r\n\r\n其实很难说出Portlet与servelt之间的关系，从某个层面说portlet与servlet之间没有任何关系，但是从另一个层面来说又有个千丝万缕的关系，就像马和牛一样，所以这里只是做一些技术上的比较\r\n\r\nPortlets与 servlets的相同点：\r\n\r\n• 都是基于java技术的web 组件\r\n\r\n• 都被专门的容器管理\r\n\r\n• 都生成动态内容\r\n\r\n• 生命周期都被容器管理\r\n\r\n• 都是与web客户端通过request/response的方式交互\r\n\r\nPortlets与 servlets的不同点：\r\n\r\n• portlet只生成内容片断，portal来负责把这些片断聚集在一个页面中。\r\n\r\n• portlet不能直接映射成一个url\r\n\r\n• Web 客户端同portlet交互需要通过portal system\r\n\r\n• Portlets 有多种request, action requests 和 render requests\r\n\r\n• Portlets 定义了 portlet modes and window states\r\n\r\n• Portlets可以离开多次在portal 页面\r\n\r\nPortlet提供的附加功能但是servlet没有提供\r\n\r\n• Portlets 可以持久化存储和访问数据\r\n\r\n• Portlets可以访问用户的信息\r\n\r\n• Portlets 具有url重写功能，可以让portal来生成访问portlet的链接和action。\r\n\r\n• Portlets 可以在session的两个范围中存储数据，application-wide scope 和 the portlet private scope.\r\n\r\n• Portlet可以互相接受、发送事件\r\n\r\nPortlets 不具备的servlet提供的功能\r\n\r\n• 在response中设置字符编码\r\n\r\n• 直接通过url访问\r\n\r\nJsr286中新提供的serveResource具有完全的response控制。\r\n\r\n就是由于上述的不同，才定义了这个新的web组件规范。Portlet重用了很多servlet中基础的、重要的概念，比如部署方式、类加载、生命周期管理、session管理、request分发。在同一个portlet 应用中的portlet、servlet、jsp共享类加载、应用上下文、session。\r\nPortlet与servlet/jsp中的桥梁\r\n\r\nPortlet可以利用servlet、jsp生成内容，一个portlet可以使用request分发调用servlet、jsp，就像一个servlet可以调用servlet、jsp。当一个servlet被portlet调用，servlet的request基于portlet的request，servlet的response基于portlet的response。比如：\r\n\r\n• 在portlet中request设置的属性，servlet可以获得。\r\n\r\n• Portlet、servlet、jsp共享一个输出流。\r\n\r\n• 使在portlet中session设置的属性，servlet可以获得。\r\n用servlet生命周期事件\r\n\r\nPortlet中的PortletContext 、PortletSession与servlet中的SevletContext、HttpSession是有关联关系的，所有这对servlet生命周期的listener同样对portlet有效\r\nServlet容器与portlet容器之间的关系\r\n\r\nPortlet的容器是servlet容器的扩展，根据中间件厂商的实现方式portlet容器可以单独实现也可以基于servlet扩展','Portlet 介绍','','publish','open','open','','portlet-%e4%bb%8b%e7%bb%8d','','','2013-08-23 14:01:35','2013-08-23 06:01:35','',0,'http://localhost/wordpress-new/?p=108',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (109,1,'2013-08-23 14:01:35','2013-08-23 06:01:35','一、 Portlet简介\r\n\r\nPortlet与servlet一样，都是jcr的规范api定义，不同的portlet还比较“年轻”，目前版本还只到2.0，而servlet规范已经相当成熟，发布了多个版本。如果不是十分准确的说，portlet只是另一种开发web程序的api，从这个方面说，开发portlet并没有什么神秘的地方，但是之所以有portlet这个规范，portlet适用的场景肯定与servlet是不同的，比如开发portlet不但要与portlet容器打交道，还要与portal打交道。读者在学习portlet开发的过程中，可以不时的用servlet的概念与portlet相比较，比较两者的异同，可以达到事半功倍的效果。\r\n\r\n刚才说到portlet规范已经出到2.0，分别是jsr168，jsr286。JSR 168 目前在业界受到广泛支持，目前我们开发的大部分代码都是基于jsr168的，jsr168规范支持基本的开发方式，虽然提供的功能比较少，但是已经基本可以满足日常需要。Jsr168发布三年之后，大多数支持 Java Portlet Specification V1.0 的门户产品都提供一些附加扩展，以支持更高级的用例，这些附加的扩展造成了各个门户产品的标准不统一，彼此间的交互协作成了不可避免的问题。为了更好地规范 portlet 开发，以适应业界发展，并提供适应于最高级别用例的标准解决方案，从而为这些高级功能提供互操作性，在 2005 年 11 月开始了 Java Portlet Specification V2.0（称为 JSR 286）的开发，在2008年1月Java Portlet Specification V2.0 目前已经正式发布。JSR 286规范兼容了 JSR 168，并完善了 JSR 168 的部分功能，并提供了诸多 JSR 168 所没有的新特性，例如资源服务、事件、portlet 过滤器、共享呈现参数及 portlet 窗口等。与 V1.0 类似，V2.0 也将基于 J2EE 1.4，因此可让 Portlet 使用 J2EE 1.4 增强（如 JSP 2.0）。下面是该新规范的一些主要功能及特性：\r\n资源服务：一种新的通过 portlet 呈现资源的方式。\r\n事件：通过发送事件和接收事件来实现 portlet 之间的通信。\r\nPortlet 过滤器：与 servlet 过滤器类似，根据 Portlet 请求和响应动态的呈现内容的变换。存在以下四种类型的 portlet 过滤器：\r\nAction 过滤器\r\nRender 过滤器\r\nResource 过滤器\r\nEvent 过滤器\r\n共享呈现参数：除了 portlet 私有的呈现参数之外，新增了可以在 portlet 之间共享的呈现参数。\r\nPortlet 窗口：提供 portlet 窗口 ID 供 portlet 使用\r\n\r\n要讲解portlet，首先要明确三个概念：portal、portlet、portlet容器。Portlet与portlet容器的关系可以比较servlet与servlet容器的关系，两者是完全一致的，开发者按照portlet规范开发portlet，部署在中间件提供商（ibm、oracle、apache）提供的portlet容器中运行，比较难理解的是portal，首先portal是一个JEE的application，portal负责提供页面给客户，其次portal里面的内容是portlet生成出来的。一般的过程是，用户通过web客户端向portal发起http请求，portal解析这些请求，把请求“下发”给portlet容器，portlet容器来调用portlet，由portlet产生输出返回给portlet容器，portlet容器再把输出返回给portal，portal负责把这些portlet的输出聚集起来，把内容返回给web客户端。下面来具体描述一下portal、portlet、portlet容器三个概念。\r\n什么是portal\r\n\r\nPortlet规范中是这样定义portal的：\r\nA portal is a web based application that –commonly- provides personalization, authentication,, content aggregation from different sources and hosts the presentation layer of Information Systems.\r\n\r\nPortal是一个基于web的提供个性化、登录授权、从不同的数据源聚集内容基于展现层的信息系统。具体到J2EE领域，portal大多数情况是一个符合J2EE标准的ear包工程。\r\n什么是portlet\r\n\r\n规范中式这样定义portlet的：\r\nA portlet is an application that provides a specific piece of content (information or service) to be included as part of a portal page. It is managed by a portlet container, that processes requests and generates dynamic content\r\n\r\n一个Portlet是一个基于java技术的被portlet容器管理的web组建，它可以处理requests、生成动态的内容输出，一个portlet负责提供portal 页面中的某个特定部位的展现内容。\r\n\r\n与servlet同样，portlet的生命周期是被portlet容器来管理的。Portlet生成的内容也可以称作fragment，这些多个portlet生成的多个fragment会被portal聚集（aggregate）在一起展现。不同用户看到的portlet可能不同，这依赖于不同用户对使用portlet的配置。\r\n什么是portlet容器\r\n\r\n规范中式这样定义portlet容器的\r\nA portlet container runs portlets and provides them with the required runtime environment. A portlet container contains portlets and manages their lifecycle. It also provides persistent storage for portlet preferences. A portlet container receives requests from the portal to execute requests on the portlets hosted by it.\r\n\r\nPortlet容器提供portlet生命周期环境，管理portlet的生命周期，还提供portlet preferences的持久化支持，portlet从portal接受请求，然后分发给运行其上的portlet。\r\n\r\nPortlet不负责聚集portlet生成的内容，这是portal责任。根据中间件厂商的实现方式portlet容器与portal可以放在一个application中实现，也可以放在两个不同的application中实现。\r\n三者关系\r\n\r\n下面是以一个用户使用web客户端来与portal交互的用力，描述portlet、portlet容器、portal三者关系、责任：\r\n\r\n1. web客户端通过http 来对portal发起request请求\r\n\r\n2. request请求被portal就收到\r\n\r\n3. portal分析这个请求是否需要与portlet进行交互\r\n\r\n4. 如果需要，则portal通知portlet容器调用portlet处理交互\r\n\r\n5. Portal通过portlet容器得到portlet返回的fragments\r\n\r\n6. Portal聚集portlet产生的fragments，生成最终的页面，返回给web客户端\r\n版本兼容性\r\n\r\nJsr286规范是向后兼容的，所以所有基于jsr168写的代码生成的war都可以在jsr286容器里面运行。不过下面罗列出一些特例，这些特例会在具体章节说明。\r\n\r\n1. RenderResponse.setContentType已经不再需要在getWriter 或者getOutputstream之前调用了，已经不会产生IllegalStateException\r\n\r\n2. 对于在portlet工程中嵌入servlet、jsp调用getProtocol，jsr168中返回时null，jsr286中返回时HTTP/1.1\r\nJSR286的主要新特性\r\n\r\nJsr286对Jsr168是向后兼容的，jsr286主要增加了如下新特性：\r\n\r\nØ 事件Events，可以是portlet可以接受、发送事件\r\n\r\nØ 公共展现参数public render parameters，容许portlet之间共享参数\r\n\r\nØ 资源服务 resource serving ，提供portlet服务资源的能力\r\n\r\nØ Portlet 拦截器 portlet filter，容许在portlet的request、response之间建立拦截器\r\n\r\n二、 与servlet规范的关系\r\n\r\nServlet规范中是这样定义的：\r\nA servlet is a Java technology based web component, managed by a container, that generates dynamic content. Like other Java-based components, servlets are platform independent Java classes that are compiled to platform neutral bytecode that can be loaded dynamically into and run by a Java enabled web server. Containers, sometimes called servlet engines, are web server extensions that provide servlet functionality. Servlets interact with web clients via a request/response paradigm implemented by the servlet container.\r\n\r\nServetl是居于java技术的web组件，被servlet容器管理，生成动态内容。Servlet通过servlet容器与web客户端展开request、response交互。\r\n\r\n其实很难说出Portlet与servelt之间的关系，从某个层面说portlet与servlet之间没有任何关系，但是从另一个层面来说又有个千丝万缕的关系，就像马和牛一样，所以这里只是做一些技术上的比较\r\n\r\nPortlets与 servlets的相同点：\r\n\r\n• 都是基于java技术的web 组件\r\n\r\n• 都被专门的容器管理\r\n\r\n• 都生成动态内容\r\n\r\n• 生命周期都被容器管理\r\n\r\n• 都是与web客户端通过request/response的方式交互\r\n\r\nPortlets与 servlets的不同点：\r\n\r\n• portlet只生成内容片断，portal来负责把这些片断聚集在一个页面中。\r\n\r\n• portlet不能直接映射成一个url\r\n\r\n• Web 客户端同portlet交互需要通过portal system\r\n\r\n• Portlets 有多种request, action requests 和 render requests\r\n\r\n• Portlets 定义了 portlet modes and window states\r\n\r\n• Portlets可以离开多次在portal 页面\r\n\r\nPortlet提供的附加功能但是servlet没有提供\r\n\r\n• Portlets 可以持久化存储和访问数据\r\n\r\n• Portlets可以访问用户的信息\r\n\r\n• Portlets 具有url重写功能，可以让portal来生成访问portlet的链接和action。\r\n\r\n• Portlets 可以在session的两个范围中存储数据，application-wide scope 和 the portlet private scope.\r\n\r\n• Portlet可以互相接受、发送事件\r\n\r\nPortlets 不具备的servlet提供的功能\r\n\r\n• 在response中设置字符编码\r\n\r\n• 直接通过url访问\r\n\r\nJsr286中新提供的serveResource具有完全的response控制。\r\n\r\n就是由于上述的不同，才定义了这个新的web组件规范。Portlet重用了很多servlet中基础的、重要的概念，比如部署方式、类加载、生命周期管理、session管理、request分发。在同一个portlet 应用中的portlet、servlet、jsp共享类加载、应用上下文、session。\r\nPortlet与servlet/jsp中的桥梁\r\n\r\nPortlet可以利用servlet、jsp生成内容，一个portlet可以使用request分发调用servlet、jsp，就像一个servlet可以调用servlet、jsp。当一个servlet被portlet调用，servlet的request基于portlet的request，servlet的response基于portlet的response。比如：\r\n\r\n• 在portlet中request设置的属性，servlet可以获得。\r\n\r\n• Portlet、servlet、jsp共享一个输出流。\r\n\r\n• 使在portlet中session设置的属性，servlet可以获得。\r\n用servlet生命周期事件\r\n\r\nPortlet中的PortletContext 、PortletSession与servlet中的SevletContext、HttpSession是有关联关系的，所有这对servlet生命周期的listener同样对portlet有效\r\nServlet容器与portlet容器之间的关系\r\n\r\nPortlet的容器是servlet容器的扩展，根据中间件厂商的实现方式portlet容器可以单独实现也可以基于servlet扩展','Portlet 介绍','','inherit','open','open','','108-revision-v1','','','2013-08-23 14:01:35','2013-08-23 06:01:35','',108,'http://localhost/wordpress-new/?p=109',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (110,1,'2013-08-23 14:02:05','2013-08-23 06:02:05','概述\r\n\r\nPortal 是一种 web 应用，它提供了一种将不同来源的数据和内容聚集和整合的方式，使各个信息源的内容可以集成到一个 web 页面里。而 Portlet 则是它的核心，一个 Portlet 可以生成一个内容片段，并和其他 Portlets 所生成的内容片段组合在一起共同生成一个 Portal 页面。因此通常我们访问一个 Portal 页面就会触发多个 portlet 被调用。Portlet 间经常需要彼此通信，以共享信息，如何在 Portlet 间通信，进行数据的传递和信息共享就成为开发人员经常会遇到的问题。\r\n\r\nWebSphere Portal V7 的面世具有革命性的意义，它以服务器端和客户端的双重聚合能力为支撑，使 WebSphere Portal 用户能够享受到更出色 Web 体验。同时，WebSphere Portal V7 对于 portlet、widget 等多种多样的应用组件支持，也为门户系统中的内容多样性提供了强大基础。\r\n\r\n本系列文章主要介绍在 WebSphere Portal V7 中形形色色的实现 portlet（widget）间通信的方式。包括通过使用传统的服务器端进行数据交互的方式，以及全新的在客户端直接传递数据和信息的方式。最后还会讨论到目前客户中普遍反映的若干 portlet 之间通信的难题解决。例如如何使嵌套的 iframe 实现 portlet 间通信；以及如何实现跨页面的 portlet 间通信等。\r\n\r\n首先在第一部分，我们一起来探讨一下传统的 JSR168 和 JSR286 portlet 通信过程的实现。\r\n\r\nJSR168 通信的实现\r\n\r\nJSR168\r\n\r\nPortal 是一个基于 web 的应用程序，它主要提供个性化、单点登录、不同来源的内容整合以及存放信息系统的表示层。\r\n\r\nPortlet 是基于 java 技术的 web 组件，它由 portlet 容器管理、并处理请求，并动态生成输出内容。通常请求一个 portal 页面会引发多个 portlets 被调用。每个 portlet 都会生成标记段，并与别的 portlets 生成的标记段组合在一起嵌入到 portal 页面的标记内。\r\n\r\nJSR168 则是 Java 标准化组织（Java Community Process）于 2003 年底所发布定义的 Java Portlet 规范，提供了 portlet 和 portal 之间的互操作性的基本标准。\r\n\r\n根据 JSR168 规范，Portlet 由容器管理，它们之间是相互独立的，并不共享 Session 对象。但是在实际使用过程中 Portlet 经常需要彼此进行通信，以共享信息。在 JSR168 中则没有针对 portlet 间通信提出一个标准化规范，因此并没有规范的 168 Portlet 通信模式可以应用不同的 Portal 平台上。在 WebSphere Portal 平台，从版本 5.1 开始可以通过协作 Portlet 来进行 portlet 间数据和信息的传递。\r\n\r\nJSR168 协作 Portlet\r\n\r\n协作 Portlet 提供了不同 Portlet 间彼此通信的能力，不同页面之间的数据也可以共享信息。在一个 Portal 页面上的一个或者多个 Portlet 可以同时接收另一个页面上的 Portlet 发送过来的信息，可以通过源 Portlet 的一个操作或者一个事件来触发。\r\n\r\n协作 Portlet 是由 WebSphere Portal 中属性代理提供支持的。每一个 Portlet 都会和一系列的数量类型相联系，这些数据类型我们称之为属性，在源 Portlet 和目标 Portlet 之间可以发送和接收。协作 Portlet 通过采用 Web 服务描述语言（Web Services Definition Language，WSDL）格式声明属性（希望共享的信息）来订阅属性代理。管理员将协作 Portlet 的源 Portlet 和目标 Portlet 连接后，在 Portal 运行时，属性代理会对这些 Portlet 间的共享属性进行匹配，并将相应源 Portlet 的属性值传递到目标 Portlet。\r\n\r\nJSR286\r\n\r\nJSR168 发布后受到了广泛的支持，但它只支持最基本的用例，在功能上有一定的缺陷。因此在它发布三年后，JSR 168 的下一个版本 JSR 286 开始了研发，并于 2008 年正式发布。\r\n\r\n在新的 JSR286 规范中，新增了资源服务，事件，portlet 过滤器，共享呈现参数以及 Portlet 窗口等功能和特性。其中在 portlet 通信机制上，主要是事件和共享呈现参数这两种方式。\r\n\r\n事件：通过发送事件和接收事件来实现 portlet 之间的通信。\r\n\r\n共享呈现参数：除了 portlet 私有的呈现参数之外，新增了可以在 portlet 之间共享的呈现参数。\r\n\r\nIBM WebSphere Portal 从版本 6.1 开始，提供了对 JSR286 Portlet 的支持。\r\n\r\nJSR286 事件\r\n\r\n从概念上来说，JSR286 Portlet 事件和 JSR 168 的协作事件是类似的，都是松散耦合发布 / 订阅通信模型。其中某个 Portlet 发出事件，然后运行在门户中的代理组件将该事件传递到其他相关 Portlet。\r\n\r\n在 WebSphere Portal 平台，JSR286 的源 Portlet 和目标 Portlet 也是通过 Portal 的连接工具来管理，其中的连接定义为从一个 Portlet 的已发布信息（某个发布事件）指向另一个 Portlet 中的处理逻辑（某个处理）。连接工具需要了解 Portlet 能够发布和接收的事件类型。在 JSR168 portlet 中这个声明是有 WSDL 部署描述文件来完成的，而在 JSR286 中直接可以在 Portlet 的 portlet.xml 部署描述符中声明该 Portlet 支持的所有事件。\r\n\r\n1.事件声明\r\n\r\n在 JSR168 协作 Portlet 中，通过采用 Web 服务描述语言（Web Services Definition Language，WSDL）格式声明属性（希望共享的信息）来订阅属性代理。\r\n\r\n在 JSR286 Portlet 中，我们需要在 portlet.xml 对一个事件进行声明。一个事件的声明包括三部分，分别是事件的定义声明、事件的发布载体声明也就是发布该事件的 Portlet 声明、事件接收载体的 Portlet 声明。\r\n\r\n事件的定义声明：使用 &lt;event-definition&gt; 元素对事件进行声明，并且该元素与 &lt;portlet&gt; 元素并列作为 &lt;portlent-app&gt; 的子元素。对一个事件的声明主要有两点事件的名称和值的类型。对于事件名称，既可以为事件定义默认的命名空间，也可以为事件单独定义自己的命名空间。对于事件值的类型，既可以是简单的 Java 对象，例如 Integer，String 等，也可以是预先定义的 Java 复杂对象，但是前提是该对象必须实现 Serializable 接口。\r\n\r\n事件的发布载体声明：事件的发布载体声明在 portlet.xml 的 &lt;portlet&gt; 元素中用 &lt;supported-publishing-event&gt; 关键字定义。发布载体声明用来声明支持发布的事件，对应事件声明格式，事件发布载体 Portlet 声明亦有默认命名空间和自定义命名空间以及简单对象和复杂对象的情况。\r\n\r\n事件接收载体声明：和事件的发布载体声明类似，事件的接收载体声明需要在 portlet.xml 的 &lt;portlet&gt; 元素中用 &lt;supported-processing-event&gt; 关键字定义。接收载体声明用来声明支持接收的事件。\r\n\r\n2.事件发送\r\n\r\nJSR286 的事件发送可以和 JSR168 portlet 一样在操作处理中完成，通过调用 ActionResponse 的 setEvent() 进行事件发布，setEvent() 方法的输入参数为事件的名称和对应的值，这些参数必须与前面在 portlet.xml 中的事件声明一致。\r\n\r\n3.事件接收处理\r\n\r\nJSR286 增加了 javax.Portlet.EventPortlet 接口来处理事件，GenericPortlet 增加了 javax.portlet.EventPortlet 借口的实现，从而增加了事件处理的功能。JSR 286 定义该方法提供了两个输入参数 : EventRequest 和 EventResponse，我们可以通过调用 EventRequest 实例的 getEvent() 方法来获得当前事件，该方法返回一个事件对象的实例，该实例封装了事件的唯一标识和对应的值。获得事件对象后，我们可以通过 getQNames() 方法或者 getName() 获得事件的名称。两种获得事件方法的区别是 getQNames() 可以得到事件的全称标识，而 getName() 只是取得本地标识名。而取得事件的值则可以通过事件的 getValue() 方法获得。\r\n\r\n具体更详细的内容请查看ibm网站\r\n\r\n<a title=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1107_jiacq_Portletcommunication/1107_jiacq_Portletcommunication.html\" href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1107_jiacq_Portletcommunication/1107_jiacq_Portletcommunication.html\" target=\"_blank\">http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1107_jiacq_Portletcommunication/1107_jiacq_Portletcommunication.html </a>','WebSphere Portal V7 中的 Portlet 通信方式，传统的 JSR168 和 JSR286 Portlet 通信的实现','','publish','open','open','','websphere-portal-v7-%e4%b8%ad%e7%9a%84-portlet-%e9%80%9a%e4%bf%a1%e6%96%b9%e5%bc%8f%ef%bc%8c%e4%bc%a0%e7%bb%9f%e7%9a%84-jsr168-%e5%92%8c-jsr286-portlet-%e9%80%9a%e4%bf%a1%e7%9a%84%e5%ae%9e%e7%8e%b0','','','2013-08-23 14:02:05','2013-08-23 06:02:05','',0,'http://localhost/wordpress-new/?p=110',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (111,1,'2013-08-23 14:02:05','2013-08-23 06:02:05','概述\r\n\r\nPortal 是一种 web 应用，它提供了一种将不同来源的数据和内容聚集和整合的方式，使各个信息源的内容可以集成到一个 web 页面里。而 Portlet 则是它的核心，一个 Portlet 可以生成一个内容片段，并和其他 Portlets 所生成的内容片段组合在一起共同生成一个 Portal 页面。因此通常我们访问一个 Portal 页面就会触发多个 portlet 被调用。Portlet 间经常需要彼此通信，以共享信息，如何在 Portlet 间通信，进行数据的传递和信息共享就成为开发人员经常会遇到的问题。\r\n\r\nWebSphere Portal V7 的面世具有革命性的意义，它以服务器端和客户端的双重聚合能力为支撑，使 WebSphere Portal 用户能够享受到更出色 Web 体验。同时，WebSphere Portal V7 对于 portlet、widget 等多种多样的应用组件支持，也为门户系统中的内容多样性提供了强大基础。\r\n\r\n本系列文章主要介绍在 WebSphere Portal V7 中形形色色的实现 portlet（widget）间通信的方式。包括通过使用传统的服务器端进行数据交互的方式，以及全新的在客户端直接传递数据和信息的方式。最后还会讨论到目前客户中普遍反映的若干 portlet 之间通信的难题解决。例如如何使嵌套的 iframe 实现 portlet 间通信；以及如何实现跨页面的 portlet 间通信等。\r\n\r\n首先在第一部分，我们一起来探讨一下传统的 JSR168 和 JSR286 portlet 通信过程的实现。\r\n\r\nJSR168 通信的实现\r\n\r\nJSR168\r\n\r\nPortal 是一个基于 web 的应用程序，它主要提供个性化、单点登录、不同来源的内容整合以及存放信息系统的表示层。\r\n\r\nPortlet 是基于 java 技术的 web 组件，它由 portlet 容器管理、并处理请求，并动态生成输出内容。通常请求一个 portal 页面会引发多个 portlets 被调用。每个 portlet 都会生成标记段，并与别的 portlets 生成的标记段组合在一起嵌入到 portal 页面的标记内。\r\n\r\nJSR168 则是 Java 标准化组织（Java Community Process）于 2003 年底所发布定义的 Java Portlet 规范，提供了 portlet 和 portal 之间的互操作性的基本标准。\r\n\r\n根据 JSR168 规范，Portlet 由容器管理，它们之间是相互独立的，并不共享 Session 对象。但是在实际使用过程中 Portlet 经常需要彼此进行通信，以共享信息。在 JSR168 中则没有针对 portlet 间通信提出一个标准化规范，因此并没有规范的 168 Portlet 通信模式可以应用不同的 Portal 平台上。在 WebSphere Portal 平台，从版本 5.1 开始可以通过协作 Portlet 来进行 portlet 间数据和信息的传递。\r\n\r\nJSR168 协作 Portlet\r\n\r\n协作 Portlet 提供了不同 Portlet 间彼此通信的能力，不同页面之间的数据也可以共享信息。在一个 Portal 页面上的一个或者多个 Portlet 可以同时接收另一个页面上的 Portlet 发送过来的信息，可以通过源 Portlet 的一个操作或者一个事件来触发。\r\n\r\n协作 Portlet 是由 WebSphere Portal 中属性代理提供支持的。每一个 Portlet 都会和一系列的数量类型相联系，这些数据类型我们称之为属性，在源 Portlet 和目标 Portlet 之间可以发送和接收。协作 Portlet 通过采用 Web 服务描述语言（Web Services Definition Language，WSDL）格式声明属性（希望共享的信息）来订阅属性代理。管理员将协作 Portlet 的源 Portlet 和目标 Portlet 连接后，在 Portal 运行时，属性代理会对这些 Portlet 间的共享属性进行匹配，并将相应源 Portlet 的属性值传递到目标 Portlet。\r\n\r\nJSR286\r\n\r\nJSR168 发布后受到了广泛的支持，但它只支持最基本的用例，在功能上有一定的缺陷。因此在它发布三年后，JSR 168 的下一个版本 JSR 286 开始了研发，并于 2008 年正式发布。\r\n\r\n在新的 JSR286 规范中，新增了资源服务，事件，portlet 过滤器，共享呈现参数以及 Portlet 窗口等功能和特性。其中在 portlet 通信机制上，主要是事件和共享呈现参数这两种方式。\r\n\r\n事件：通过发送事件和接收事件来实现 portlet 之间的通信。\r\n\r\n共享呈现参数：除了 portlet 私有的呈现参数之外，新增了可以在 portlet 之间共享的呈现参数。\r\n\r\nIBM WebSphere Portal 从版本 6.1 开始，提供了对 JSR286 Portlet 的支持。\r\n\r\nJSR286 事件\r\n\r\n从概念上来说，JSR286 Portlet 事件和 JSR 168 的协作事件是类似的，都是松散耦合发布 / 订阅通信模型。其中某个 Portlet 发出事件，然后运行在门户中的代理组件将该事件传递到其他相关 Portlet。\r\n\r\n在 WebSphere Portal 平台，JSR286 的源 Portlet 和目标 Portlet 也是通过 Portal 的连接工具来管理，其中的连接定义为从一个 Portlet 的已发布信息（某个发布事件）指向另一个 Portlet 中的处理逻辑（某个处理）。连接工具需要了解 Portlet 能够发布和接收的事件类型。在 JSR168 portlet 中这个声明是有 WSDL 部署描述文件来完成的，而在 JSR286 中直接可以在 Portlet 的 portlet.xml 部署描述符中声明该 Portlet 支持的所有事件。\r\n\r\n1.事件声明\r\n\r\n在 JSR168 协作 Portlet 中，通过采用 Web 服务描述语言（Web Services Definition Language，WSDL）格式声明属性（希望共享的信息）来订阅属性代理。\r\n\r\n在 JSR286 Portlet 中，我们需要在 portlet.xml 对一个事件进行声明。一个事件的声明包括三部分，分别是事件的定义声明、事件的发布载体声明也就是发布该事件的 Portlet 声明、事件接收载体的 Portlet 声明。\r\n\r\n事件的定义声明：使用 &lt;event-definition&gt; 元素对事件进行声明，并且该元素与 &lt;portlet&gt; 元素并列作为 &lt;portlent-app&gt; 的子元素。对一个事件的声明主要有两点事件的名称和值的类型。对于事件名称，既可以为事件定义默认的命名空间，也可以为事件单独定义自己的命名空间。对于事件值的类型，既可以是简单的 Java 对象，例如 Integer，String 等，也可以是预先定义的 Java 复杂对象，但是前提是该对象必须实现 Serializable 接口。\r\n\r\n事件的发布载体声明：事件的发布载体声明在 portlet.xml 的 &lt;portlet&gt; 元素中用 &lt;supported-publishing-event&gt; 关键字定义。发布载体声明用来声明支持发布的事件，对应事件声明格式，事件发布载体 Portlet 声明亦有默认命名空间和自定义命名空间以及简单对象和复杂对象的情况。\r\n\r\n事件接收载体声明：和事件的发布载体声明类似，事件的接收载体声明需要在 portlet.xml 的 &lt;portlet&gt; 元素中用 &lt;supported-processing-event&gt; 关键字定义。接收载体声明用来声明支持接收的事件。\r\n\r\n2.事件发送\r\n\r\nJSR286 的事件发送可以和 JSR168 portlet 一样在操作处理中完成，通过调用 ActionResponse 的 setEvent() 进行事件发布，setEvent() 方法的输入参数为事件的名称和对应的值，这些参数必须与前面在 portlet.xml 中的事件声明一致。\r\n\r\n3.事件接收处理\r\n\r\nJSR286 增加了 javax.Portlet.EventPortlet 接口来处理事件，GenericPortlet 增加了 javax.portlet.EventPortlet 借口的实现，从而增加了事件处理的功能。JSR 286 定义该方法提供了两个输入参数 : EventRequest 和 EventResponse，我们可以通过调用 EventRequest 实例的 getEvent() 方法来获得当前事件，该方法返回一个事件对象的实例，该实例封装了事件的唯一标识和对应的值。获得事件对象后，我们可以通过 getQNames() 方法或者 getName() 获得事件的名称。两种获得事件方法的区别是 getQNames() 可以得到事件的全称标识，而 getName() 只是取得本地标识名。而取得事件的值则可以通过事件的 getValue() 方法获得。\r\n\r\n具体更详细的内容请查看ibm网站\r\n\r\n<a title=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1107_jiacq_Portletcommunication/1107_jiacq_Portletcommunication.html\" href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1107_jiacq_Portletcommunication/1107_jiacq_Portletcommunication.html\" target=\"_blank\">http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1107_jiacq_Portletcommunication/1107_jiacq_Portletcommunication.html </a>','WebSphere Portal V7 中的 Portlet 通信方式，传统的 JSR168 和 JSR286 Portlet 通信的实现','','inherit','open','open','','110-revision-v1','','','2013-08-23 14:02:05','2013-08-23 06:02:05','',110,'http://localhost/wordpress-new/?p=111',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (112,1,'2013-08-23 14:02:35','2013-08-23 06:02:35','通过puma获取用户的基础信息。下面的代码阐述了如何通过puma获取用户的信息，要获取用户首选需要获取puma服务。在portlet初始化时加入以下代码\r\n\r\nprivate PortletServiceHome psh = null;\r\nprivate PumaHome service = null;\r\n\r\njavax.naming.Context ctx;\r\ntry {\r\nctx = new javax.naming.InitialContext();\r\npsh = (PortletServiceHome) ctx.lookup(\"portletservice/com.ibm.portal.um.portletservice.PumaHome\");\r\nif(psh != null){\r\nservice = (PumaHome)psh.getPortletService(PumaHome.class);\r\n}\r\n} catch (Exception e) {\r\n// TODO 自动生成 catch 块\r\ne.printStackTrace();\r\n}\r\n\r\n然后通过该服务 service 获取用户信息\r\n\r\nPumaProfile pp = this.service.getProfile(request);\r\n\r\nUser loginUser = pp.getCurrentUser();\r\npp.getIdentifier(loginUser);\r\njava.util.List list=new java.util.ArrayList();\r\nlist.add(\"givenName\");\r\nlist.add(\"cn\");\r\nlist.add(\"uid\");\r\nlist.add(\"ibm-primaryEmail\");\r\njava.util.Map map = pp.getAttributes(loginUser, list);\r\npp.getGroupDefaultSearchAttributeName();\r\n\r\n// show all user attributes\r\nList&lt;String&gt; userAttrs = pp.getDefinedUserAttributeNames();\r\njava.util.Map map2 = pp.getAttributes(loginUser, userAttrs);\r\nsessionBean.setUserAttrsMap(map2);\r\n\r\n/*\r\n* User PumaLocator to search users\r\n*/\r\nPumaLocator pLoc = this.service.getLocator(request);\r\nList&lt;Group&gt; groups = pLoc.findGroupsByPrincipal(loginUser, true);\r\nList&lt;String&gt; groupNames = new ArrayList&lt;String&gt;(10);\r\nList gAttr = new ArrayList();\r\ngAttr.add(\"cn\");//用于从Group对象中获得cn属性\r\nif(groups != null &amp;&amp; groups.size() &gt; 0){\r\nfor (Group g : groups) {\r\nMap&lt;String,Object&gt; results = pp.getAttributes(g, gAttr);\r\nString groupName = this.getUserAttr(\"cn\", results);\r\ngroupNames.add(groupName);\r\n}\r\n}\r\n\r\n&nbsp;\r\n\r\n另外一个中 获取puma 服务的方法是\r\n\r\njavax.naming.Context ctx = new javax.naming.InitialContext();\r\ncom.ibm.portal.um.PumaHome pumaHome = (PumaHome) ctx.lookup(PumaHome.JNDI_NAME);\r\n\r\nPumaProfile profile = pumaHome.getProfile();\r\n\r\nUser user = profile.getCurrentUser() ;\r\n\r\n通过puma你可以实现对用户以及用户组 以及属性的增删改查等所有功能下面的文档涵盖了所需的内容\r\n\r\nhttp://www.ibm.com/developerworks/websphere/zones/portal/proddoc/dw-w-pumascenarios/index.html\r\n\r\npuma还提供了rest的api供第三方应用\r\n\r\n<a href=\"http://localhost/wordpress/wp-content/uploads/2012/05/Puma-REST-Samples-V1.0.pdf\">Puma-REST-Samples-V1.0</a>\r\n\r\n&nbsp;','puma 介绍','','publish','open','open','','puma-%e4%bb%8b%e7%bb%8d','','','2013-08-23 14:02:35','2013-08-23 06:02:35','',0,'http://localhost/wordpress-new/?p=112',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (113,1,'2013-08-23 14:02:35','2013-08-23 06:02:35','通过puma获取用户的基础信息。下面的代码阐述了如何通过puma获取用户的信息，要获取用户首选需要获取puma服务。在portlet初始化时加入以下代码\r\n\r\nprivate PortletServiceHome psh = null;\r\nprivate PumaHome service = null;\r\n\r\njavax.naming.Context ctx;\r\ntry {\r\nctx = new javax.naming.InitialContext();\r\npsh = (PortletServiceHome) ctx.lookup(\"portletservice/com.ibm.portal.um.portletservice.PumaHome\");\r\nif(psh != null){\r\nservice = (PumaHome)psh.getPortletService(PumaHome.class);\r\n}\r\n} catch (Exception e) {\r\n// TODO 自动生成 catch 块\r\ne.printStackTrace();\r\n}\r\n\r\n然后通过该服务 service 获取用户信息\r\n\r\nPumaProfile pp = this.service.getProfile(request);\r\n\r\nUser loginUser = pp.getCurrentUser();\r\npp.getIdentifier(loginUser);\r\njava.util.List list=new java.util.ArrayList();\r\nlist.add(\"givenName\");\r\nlist.add(\"cn\");\r\nlist.add(\"uid\");\r\nlist.add(\"ibm-primaryEmail\");\r\njava.util.Map map = pp.getAttributes(loginUser, list);\r\npp.getGroupDefaultSearchAttributeName();\r\n\r\n// show all user attributes\r\nList&lt;String&gt; userAttrs = pp.getDefinedUserAttributeNames();\r\njava.util.Map map2 = pp.getAttributes(loginUser, userAttrs);\r\nsessionBean.setUserAttrsMap(map2);\r\n\r\n/*\r\n* User PumaLocator to search users\r\n*/\r\nPumaLocator pLoc = this.service.getLocator(request);\r\nList&lt;Group&gt; groups = pLoc.findGroupsByPrincipal(loginUser, true);\r\nList&lt;String&gt; groupNames = new ArrayList&lt;String&gt;(10);\r\nList gAttr = new ArrayList();\r\ngAttr.add(\"cn\");//用于从Group对象中获得cn属性\r\nif(groups != null &amp;&amp; groups.size() &gt; 0){\r\nfor (Group g : groups) {\r\nMap&lt;String,Object&gt; results = pp.getAttributes(g, gAttr);\r\nString groupName = this.getUserAttr(\"cn\", results);\r\ngroupNames.add(groupName);\r\n}\r\n}\r\n\r\n&nbsp;\r\n\r\n另外一个中 获取puma 服务的方法是\r\n\r\njavax.naming.Context ctx = new javax.naming.InitialContext();\r\ncom.ibm.portal.um.PumaHome pumaHome = (PumaHome) ctx.lookup(PumaHome.JNDI_NAME);\r\n\r\nPumaProfile profile = pumaHome.getProfile();\r\n\r\nUser user = profile.getCurrentUser() ;\r\n\r\n通过puma你可以实现对用户以及用户组 以及属性的增删改查等所有功能下面的文档涵盖了所需的内容\r\n\r\nhttp://www.ibm.com/developerworks/websphere/zones/portal/proddoc/dw-w-pumascenarios/index.html\r\n\r\npuma还提供了rest的api供第三方应用\r\n\r\n<a href=\"http://localhost/wordpress/wp-content/uploads/2012/05/Puma-REST-Samples-V1.0.pdf\">Puma-REST-Samples-V1.0</a>\r\n\r\n&nbsp;','puma 介绍','','inherit','open','open','','112-revision-v1','','','2013-08-23 14:02:35','2013-08-23 06:02:35','',112,'http://localhost/wordpress-new/?p=113',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (114,1,'2013-08-23 14:03:20','2013-08-23 06:03:20','1.获取通过web上传文件的文件名\r\n<pre>function getUploadFileName(fileString)\r\n    {\r\n        var x=fileString.lastIndexOf(\"\\\\\") &gt; 0 ? fileString.lastIndexOf(\"\\\\\") : fileString.lastIndexOf(\"/\");\r\n        if(x+0&gt; 0){\r\n            x++;\r\n            Name=fileString.substr(x,fileString.length-1);\r\n            return Name;\r\n        }\r\n        return fileString;\r\n    }</pre>\r\n<pre>2.ibm portal 一个非常棒的收藏夹</pre>\r\n<pre><a href=\"http://localhost/wordpress/wp-content/uploads/2012/09/Web2BookmarksJSR168.zip\">Web2BookmarksJSR168</a></pre>\r\n<pre>3.正则表达式验证一个URL</pre>\r\n<pre>/^(((https?)):\\/\\/([\\-\\w]+\\.)+\\w{2,3}(\\/[%\\-\\w]+(\\.\\w{2,})?)*(([\\w\\-\\.\\?\\\\/+@&amp;#;`~=%!]*)(\\.\\w{2,})?)*\\/?)/i</pre>','有用的javascript脚本','','publish','open','open','','%e6%9c%89%e7%94%a8%e7%9a%84javascript%e8%84%9a%e6%9c%ac','','','2013-08-23 14:03:20','2013-08-23 06:03:20','',0,'http://localhost/wordpress-new/?p=114',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (115,1,'2013-08-23 14:03:20','2013-08-23 06:03:20','1.获取通过web上传文件的文件名\r\n<pre>function getUploadFileName(fileString)\r\n    {\r\n        var x=fileString.lastIndexOf(\"\\\\\") &gt; 0 ? fileString.lastIndexOf(\"\\\\\") : fileString.lastIndexOf(\"/\");\r\n        if(x+0&gt; 0){\r\n            x++;\r\n            Name=fileString.substr(x,fileString.length-1);\r\n            return Name;\r\n        }\r\n        return fileString;\r\n    }</pre>\r\n<pre>2.ibm portal 一个非常棒的收藏夹</pre>\r\n<pre><a href=\"http://localhost/wordpress/wp-content/uploads/2012/09/Web2BookmarksJSR168.zip\">Web2BookmarksJSR168</a></pre>\r\n<pre>3.正则表达式验证一个URL</pre>\r\n<pre>/^(((https?)):\\/\\/([\\-\\w]+\\.)+\\w{2,3}(\\/[%\\-\\w]+(\\.\\w{2,})?)*(([\\w\\-\\.\\?\\\\/+@&amp;#;`~=%!]*)(\\.\\w{2,})?)*\\/?)/i</pre>','有用的javascript脚本','','inherit','open','open','','114-revision-v1','','','2013-08-23 14:03:20','2013-08-23 06:03:20','',114,'http://localhost/wordpress-new/?p=115',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (116,1,'2013-08-23 14:03:51','2013-08-23 06:03:51','1. 总是利用URL重写API，以获得Portlet中的内容\r\nJava开发人员经常在如下所示JSP中编写图像的URL：\r\n\r\n&lt;img src=\"/&lt;%= request.getContextPath()%&gt;/images/logo.gif\"/&gt;\r\n这在JSR-168 portlet中是不正确的。正确的方法是：\r\n\r\n&lt;img src=\"&lt;%= renderResponse.encodeURL(renderRequest.getContextPath()+\r\n\"/images/logo.gif\") %&gt;\"/&gt;\r\n\r\nencodeURL()方法可以采用完全路径URI或者完全限定URL。完全路径URI是最常用的。在使用JSR-168 portlet将资源嵌入Web Application Archive (WAR)中时，可以使用此技术。在将图像放置到单独服务器上时，可以使用完全限定URL。专门为静态内容提供服务的缓存服务器就是一个示例，它卸掉来自门户服务器的通信量。尽管可以通过对完全限定URL使用encodeURL()来引用portlet以外的内容，但应该只在无法通过客户机访问资源时这样做。如果客户机可以直接浏览资源，则无需对URL使用encodeURL()。例如，如果有一台Web服务器，可用该服务器获得门户用户无法直接浏览的防火墙内的静态内容，则需要调用encodeURL()。如果这些内容在防火墙之外，并且门户用户可以直接浏览到Web服务器，则无需调用encodeURL()。\r\n\r\n2. 不要将路径附加到重写URL中\r\n传入RenderRequest的encodeUrl()方法中的URL在调用该方法之前必须是完整的。在调用该方法之后，无法添加URL的某些部分。例如，如果想从XSLT转换中生成一个URL转换，则不能将已编码的基本URL(http://foo.com/)作为参数传递，并将路径(pages/bar.jsp)附加到该转换中的已编码基本URL中。\r\n\r\n以下调用演示了将URL编码到图像中的正确方式：\r\n\r\n&lt;@= renderResponse.encodeURL(renderRequest.getContextPath()+\r\n\"/images/logo.gif\")@&gt;\r\n它使用一个.portal文件在BEA WebLogic Portal 9.2中生成以下HTML片段：\r\n\r\n&lt;img src=\"http://localhost:7001/PortalWebApp/images/logo.gif;\r\nPORTAL_TAU=W3f6FbmLLcgZq9Fpv1JHLs5rrJG8Lgj2nnDVJqdfShhRGFnsqCKZ!-545815275\"/&gt;\r\n\r\n以下调用是不正确的。URL并不指向想要的资源。\r\n\r\n&lt;@= renderResponse.encodeURL(renderRequest.getContextPath()+\r\n\"/images/\")+\"logo.gif\"@&gt;\r\n它使用.portal文件在WebLogic Portal 9.2中生成以下HTML文件：\r\n\r\n&lt;img src=\"http://localhost:7001/PortalWebApp/images/;PORTAL_TAU=W3f6FbmLLcgZq9Fpv1JHLs5rrJG8Lgj2nnDVJqdfShhRGFnsqCKZ!-545815275logo.gif\"/&gt;\r\n\r\n3. 使用名称空间限定客户端脚本变量和方法\r\n假设您想使用portlet中的JavaScript验证用户输入。以下JavaScript功能可能很有用：\r\n\r\n&lt;script&gt;\r\nfunction validate(foo) {\r\nif (foo.bar.value==\"\") {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\n&lt;/script&gt;\r\n同一页面中的其他portlet可能也有一个命名为validate()的具有不同逻辑的JavaScript方法。门户框架本身可能使用JavaScript方法。这个问题的解决方法是使用客户端脚本中的名称空间方法和顶层变量。&lt;portlet:namespace/&gt;标记将为每个portlet生成一个惟一标识符。第一步是通过taglib directive将标记库包含在JSP中。\r\n\r\n&lt;%@taglib uri=\"http://java.sun.com/portlet\" prefix=\"portlet\"%&gt;\r\n脚本中的validate()方法可以对标记加以区分。\r\n\r\n&lt;script&gt;\r\nfunction validate&lt;portlet:namespace/&gt;(foo) {\r\nif (foo.bar.value==\"\") {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\n&lt;/script&gt;\r\n以下是调用带名称空间的JavaScript方法的方式：\r\n\r\n&lt;form action=\"http://www.somesite.org/servlet\"\r\nmethod=\"GET\" onsubmit=\"return validate&lt;portlet:namespace/&gt;(this);\"&gt;\r\n&lt;label for=\"bar\"&gt;Text(required): &lt;/label&gt;\r\n&lt;input type=\"text\" name=\"bar\" id=\"bar\"&gt;\r\n&lt;/form&gt;\r\n\r\n4. 确保引用Portlet资源的内联客户端脚本符合规范\r\n客户端脚本常常引用外部资源（如图像、电影和外部页面）来增强用户界面。常见的示例是预先加载图像以使交换图像更有效的JavaScript。以下是一个示例：\r\n\r\n&lt;script&gt;\r\nfunction preloadImages(){\r\nvar menuImage =\r\nnew Image();\r\nmenuImage.src = \"images/icon.gif\";\r\nvar menuImageDark=new Image();\r\nmenuImageDark.src = \"images/icon.gif\";\r\n}\r\n&lt;/script&gt;\r\n客户端脚本中的URL必须根据JSR-168规范进行重写。这些脚本必须在JSP或JSP-168 portlet类中，以便调用重写API的URL。它们不能在单独的JavaScript (.js)文件中。以下是一个包含URL重写的适当名称空间脚本在JSR-168 portlet中看起来的样子：\r\n\r\n&lt;script&gt;\r\nfunction &lt;portlet:namespace/&gt;preloadImages(){\r\nvar menuImage = new Image();\r\nmenuImage.src = \"&lt;%=renderResponse.encodeURL(renderRequest.getContextPath()+ \"images/icon.gif\")%&gt;\";\r\nvar menuImageDark= new Image();\r\nmenuImageDark.src = \"&lt;%=renderResponse.encodeURL(renderRequest.getContextPath()+ \"images/icon_dark.gif\") %&gt;\";\r\n}\r\n&lt;/script&gt;\r\n5. 总是为portlet响应声明一个内容类型\r\n根据JSR-168规范，“portlet必须使用RenderResponse接口的setContentType方法设置响应的内容类型”。没有显式设置其内容类型的portlet仍然会成功获得编译。但WebLogic Portal不会执行没有设置其内容类型的portlet。确保您的portlet设置了其内容类型。\r\n\r\n以下示例演示了一个正确设置其内容类型的portlet：\r\n\r\npublic class MyPortlet extends GenericPortlet {\r\npublic void doView(RenderRequest request, RenderResponse response)\r\nthrows PortletException, IOException {\r\nresponse.setContentType(\"text/html\");\r\nPrintWriter writer = response.getWriter();\r\nwriter.println(\"I set my content type!\");\r\n}\r\n}\r\n此示例是不正确的，但仍将获得编译：\r\n\r\npublic class MyPortlet extends GenericPortlet {\r\npublic void doView(RenderRequest request, RenderResponse response)\r\nthrows PortletException, IOException {\r\n// no content type set!\r\nPrintWriter writer = response.getWriter();\r\nwriter.println(\"I did NOT set my content type!\");\r\n}\r\n}\r\n\r\n6. 不要从Portlet发送Cookie\r\n根据JSR-168 portlet规范，在HttpServletResponse上调用addCookie()实际上不会设置一个cookie。允许设置cookie的portlet容器被打破。不要调用此方法。\r\n\r\n如果您喜欢在用户使用门户的时候基于每位用户持久存储信息，那么可以将信息存储为portlet会话中的一个属性。如果您喜欢在用户退出后持久存储信息，那么可以将信息存储到数据存储库（文件系统、数据库、LDAP等）中。\r\n\r\n7. 将业务逻辑从表示中分离出来\r\n有经验的开发人员都知道模型查看器控制器框架类似于Struts或Beehive，可以使开发富Web应用程序变得更容易。这同样也适用于portlet。JSR-168并不是适用于平台独立portlet的惟一理想规范。WSRP portlet在实现标准的门户（包括非Java门户）之间移动很方便。WebLogic Portal 可以通过WSRP公开Beehive和Struts portlet。\r\n\r\n如果需要将portlet部署为JSR-168 WAR，您仍然有一些选择。将业务逻辑从JSR-168 portlet的表示逻辑中分离出来的最简单方法是指派一个JavaServer Page (JSP)。portlet处理呈现方法（比如render()和doView()）中的业务逻辑。portlet使用应用程序级作用域或portlet作用域将信息传递给JSP。下面的示例将一个portlet请求指派给JSP，并传递portlet作用域中的一个字符串：\r\n\r\npublic void doView(RenderRequest request, RenderResponse response) throws PortletException, IOException {\r\nresponse.setContentType(\"text/html\");\r\nrequest.setAttribute(\"foo\",\"bar\");\r\nString jsp = \"/pages/portal.jsp\";\r\nPortletContext ctx = getPortletContext();\r\nPortletRequestDispatcher dispatcher = ctx.getRequestDispatcher(jsp);\r\ndispatcher.include(request, response);\r\n}\r\n到达JSP（上述示例中的jsp）的路径值并不包括portlet的Web归档文件（WAR）的上下文路径。\r\n\r\nJSR-168的指派方法允许将业务逻辑与表示分离。不过，它们缺乏MVC框架的成熟度。\r\n\r\n适用于JSR-168开发的框架包括：\r\n\r\nSpring Portlet MVC\r\nWebWork\r\nStruts Action 2\r\nStruts Action 2是Struts和WebWork的组合，因此portlet代码库对现在而言几乎是一样的。这些框架简化了复杂portlet的开发和维护。','portlet 细节','','publish','open','open','','portlet-%e7%bb%86%e8%8a%82','','','2013-08-23 14:03:51','2013-08-23 06:03:51','',0,'http://localhost/wordpress-new/?p=116',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (117,1,'2013-08-23 14:03:51','2013-08-23 06:03:51','1. 总是利用URL重写API，以获得Portlet中的内容\r\nJava开发人员经常在如下所示JSP中编写图像的URL：\r\n\r\n&lt;img src=\"/&lt;%= request.getContextPath()%&gt;/images/logo.gif\"/&gt;\r\n这在JSR-168 portlet中是不正确的。正确的方法是：\r\n\r\n&lt;img src=\"&lt;%= renderResponse.encodeURL(renderRequest.getContextPath()+\r\n\"/images/logo.gif\") %&gt;\"/&gt;\r\n\r\nencodeURL()方法可以采用完全路径URI或者完全限定URL。完全路径URI是最常用的。在使用JSR-168 portlet将资源嵌入Web Application Archive (WAR)中时，可以使用此技术。在将图像放置到单独服务器上时，可以使用完全限定URL。专门为静态内容提供服务的缓存服务器就是一个示例，它卸掉来自门户服务器的通信量。尽管可以通过对完全限定URL使用encodeURL()来引用portlet以外的内容，但应该只在无法通过客户机访问资源时这样做。如果客户机可以直接浏览资源，则无需对URL使用encodeURL()。例如，如果有一台Web服务器，可用该服务器获得门户用户无法直接浏览的防火墙内的静态内容，则需要调用encodeURL()。如果这些内容在防火墙之外，并且门户用户可以直接浏览到Web服务器，则无需调用encodeURL()。\r\n\r\n2. 不要将路径附加到重写URL中\r\n传入RenderRequest的encodeUrl()方法中的URL在调用该方法之前必须是完整的。在调用该方法之后，无法添加URL的某些部分。例如，如果想从XSLT转换中生成一个URL转换，则不能将已编码的基本URL(http://foo.com/)作为参数传递，并将路径(pages/bar.jsp)附加到该转换中的已编码基本URL中。\r\n\r\n以下调用演示了将URL编码到图像中的正确方式：\r\n\r\n&lt;@= renderResponse.encodeURL(renderRequest.getContextPath()+\r\n\"/images/logo.gif\")@&gt;\r\n它使用一个.portal文件在BEA WebLogic Portal 9.2中生成以下HTML片段：\r\n\r\n&lt;img src=\"http://localhost:7001/PortalWebApp/images/logo.gif;\r\nPORTAL_TAU=W3f6FbmLLcgZq9Fpv1JHLs5rrJG8Lgj2nnDVJqdfShhRGFnsqCKZ!-545815275\"/&gt;\r\n\r\n以下调用是不正确的。URL并不指向想要的资源。\r\n\r\n&lt;@= renderResponse.encodeURL(renderRequest.getContextPath()+\r\n\"/images/\")+\"logo.gif\"@&gt;\r\n它使用.portal文件在WebLogic Portal 9.2中生成以下HTML文件：\r\n\r\n&lt;img src=\"http://localhost:7001/PortalWebApp/images/;PORTAL_TAU=W3f6FbmLLcgZq9Fpv1JHLs5rrJG8Lgj2nnDVJqdfShhRGFnsqCKZ!-545815275logo.gif\"/&gt;\r\n\r\n3. 使用名称空间限定客户端脚本变量和方法\r\n假设您想使用portlet中的JavaScript验证用户输入。以下JavaScript功能可能很有用：\r\n\r\n&lt;script&gt;\r\nfunction validate(foo) {\r\nif (foo.bar.value==\"\") {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\n&lt;/script&gt;\r\n同一页面中的其他portlet可能也有一个命名为validate()的具有不同逻辑的JavaScript方法。门户框架本身可能使用JavaScript方法。这个问题的解决方法是使用客户端脚本中的名称空间方法和顶层变量。&lt;portlet:namespace/&gt;标记将为每个portlet生成一个惟一标识符。第一步是通过taglib directive将标记库包含在JSP中。\r\n\r\n&lt;%@taglib uri=\"http://java.sun.com/portlet\" prefix=\"portlet\"%&gt;\r\n脚本中的validate()方法可以对标记加以区分。\r\n\r\n&lt;script&gt;\r\nfunction validate&lt;portlet:namespace/&gt;(foo) {\r\nif (foo.bar.value==\"\") {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\n&lt;/script&gt;\r\n以下是调用带名称空间的JavaScript方法的方式：\r\n\r\n&lt;form action=\"http://www.somesite.org/servlet\"\r\nmethod=\"GET\" onsubmit=\"return validate&lt;portlet:namespace/&gt;(this);\"&gt;\r\n&lt;label for=\"bar\"&gt;Text(required): &lt;/label&gt;\r\n&lt;input type=\"text\" name=\"bar\" id=\"bar\"&gt;\r\n&lt;/form&gt;\r\n\r\n4. 确保引用Portlet资源的内联客户端脚本符合规范\r\n客户端脚本常常引用外部资源（如图像、电影和外部页面）来增强用户界面。常见的示例是预先加载图像以使交换图像更有效的JavaScript。以下是一个示例：\r\n\r\n&lt;script&gt;\r\nfunction preloadImages(){\r\nvar menuImage =\r\nnew Image();\r\nmenuImage.src = \"images/icon.gif\";\r\nvar menuImageDark=new Image();\r\nmenuImageDark.src = \"images/icon.gif\";\r\n}\r\n&lt;/script&gt;\r\n客户端脚本中的URL必须根据JSR-168规范进行重写。这些脚本必须在JSP或JSP-168 portlet类中，以便调用重写API的URL。它们不能在单独的JavaScript (.js)文件中。以下是一个包含URL重写的适当名称空间脚本在JSR-168 portlet中看起来的样子：\r\n\r\n&lt;script&gt;\r\nfunction &lt;portlet:namespace/&gt;preloadImages(){\r\nvar menuImage = new Image();\r\nmenuImage.src = \"&lt;%=renderResponse.encodeURL(renderRequest.getContextPath()+ \"images/icon.gif\")%&gt;\";\r\nvar menuImageDark= new Image();\r\nmenuImageDark.src = \"&lt;%=renderResponse.encodeURL(renderRequest.getContextPath()+ \"images/icon_dark.gif\") %&gt;\";\r\n}\r\n&lt;/script&gt;\r\n5. 总是为portlet响应声明一个内容类型\r\n根据JSR-168规范，“portlet必须使用RenderResponse接口的setContentType方法设置响应的内容类型”。没有显式设置其内容类型的portlet仍然会成功获得编译。但WebLogic Portal不会执行没有设置其内容类型的portlet。确保您的portlet设置了其内容类型。\r\n\r\n以下示例演示了一个正确设置其内容类型的portlet：\r\n\r\npublic class MyPortlet extends GenericPortlet {\r\npublic void doView(RenderRequest request, RenderResponse response)\r\nthrows PortletException, IOException {\r\nresponse.setContentType(\"text/html\");\r\nPrintWriter writer = response.getWriter();\r\nwriter.println(\"I set my content type!\");\r\n}\r\n}\r\n此示例是不正确的，但仍将获得编译：\r\n\r\npublic class MyPortlet extends GenericPortlet {\r\npublic void doView(RenderRequest request, RenderResponse response)\r\nthrows PortletException, IOException {\r\n// no content type set!\r\nPrintWriter writer = response.getWriter();\r\nwriter.println(\"I did NOT set my content type!\");\r\n}\r\n}\r\n\r\n6. 不要从Portlet发送Cookie\r\n根据JSR-168 portlet规范，在HttpServletResponse上调用addCookie()实际上不会设置一个cookie。允许设置cookie的portlet容器被打破。不要调用此方法。\r\n\r\n如果您喜欢在用户使用门户的时候基于每位用户持久存储信息，那么可以将信息存储为portlet会话中的一个属性。如果您喜欢在用户退出后持久存储信息，那么可以将信息存储到数据存储库（文件系统、数据库、LDAP等）中。\r\n\r\n7. 将业务逻辑从表示中分离出来\r\n有经验的开发人员都知道模型查看器控制器框架类似于Struts或Beehive，可以使开发富Web应用程序变得更容易。这同样也适用于portlet。JSR-168并不是适用于平台独立portlet的惟一理想规范。WSRP portlet在实现标准的门户（包括非Java门户）之间移动很方便。WebLogic Portal 可以通过WSRP公开Beehive和Struts portlet。\r\n\r\n如果需要将portlet部署为JSR-168 WAR，您仍然有一些选择。将业务逻辑从JSR-168 portlet的表示逻辑中分离出来的最简单方法是指派一个JavaServer Page (JSP)。portlet处理呈现方法（比如render()和doView()）中的业务逻辑。portlet使用应用程序级作用域或portlet作用域将信息传递给JSP。下面的示例将一个portlet请求指派给JSP，并传递portlet作用域中的一个字符串：\r\n\r\npublic void doView(RenderRequest request, RenderResponse response) throws PortletException, IOException {\r\nresponse.setContentType(\"text/html\");\r\nrequest.setAttribute(\"foo\",\"bar\");\r\nString jsp = \"/pages/portal.jsp\";\r\nPortletContext ctx = getPortletContext();\r\nPortletRequestDispatcher dispatcher = ctx.getRequestDispatcher(jsp);\r\ndispatcher.include(request, response);\r\n}\r\n到达JSP（上述示例中的jsp）的路径值并不包括portlet的Web归档文件（WAR）的上下文路径。\r\n\r\nJSR-168的指派方法允许将业务逻辑与表示分离。不过，它们缺乏MVC框架的成熟度。\r\n\r\n适用于JSR-168开发的框架包括：\r\n\r\nSpring Portlet MVC\r\nWebWork\r\nStruts Action 2\r\nStruts Action 2是Struts和WebWork的组合，因此portlet代码库对现在而言几乎是一样的。这些框架简化了复杂portlet的开发和维护。','portlet 细节','','inherit','open','open','','116-revision-v1','','','2013-08-23 14:03:51','2013-08-23 06:03:51','',116,'http://localhost/wordpress-new/?p=117',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (118,1,'2013-08-23 14:04:28','2013-08-23 06:04:28','附件中包含了pdf 和源代码 详细的讲述了portlet是如何工作的 非常棒\r\n\r\n1.在portlet.xml中配置首选参数 如获取数据源 jndi的名字\r\n\r\n2.以实例讲述了 portlet的多种模式 doview, doedit,doconfig\r\n\r\n3.为portlet添加命名空间以防止 页面中多个portlet存在冲突的情况 如下定义一个form的名字\r\n\r\n&lt;form method=\"post\" name=\"&lt;portlet:namespace/&gt;editform\"&gt;\r\n\r\n4.讲述了 &lt;portlet:actionURL /&gt; &lt;portlet:renderURL /&gt;的区别 一个调用processAction方法 一个直接调用doXXX方法。\r\n\r\n小结：在实际运用中可能不需要这么多模式 可以直接通过  &lt;portlet:actionURL /&gt;和 &lt;portlet:renderURL /&gt; 来实现不同页面的跳转 值传递来处理业务。 因为有的时候 portlet的主题会导致编辑，以及配置等连接无法直接展现给用户，如portal8 需要在编辑模式下 才能展现，对用户来说不是很方便。\r\n\r\n&nbsp;\r\n\r\n<a href=\"http://localhost/wordpress/wp-content/uploads/2012/09/portletwb-samples.zip\">portletwb-samples</a>','一个基于联系人地址的 ibm portlet 实例','','publish','open','open','','%e4%b8%80%e4%b8%aa%e5%9f%ba%e4%ba%8e%e8%81%94%e7%b3%bb%e4%ba%ba%e5%9c%b0%e5%9d%80%e7%9a%84-ibm-portlet-%e5%ae%9e%e4%be%8b','','','2013-08-23 14:04:28','2013-08-23 06:04:28','',0,'http://localhost/wordpress-new/?p=118',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (119,1,'2013-08-23 14:04:28','2013-08-23 06:04:28','附件中包含了pdf 和源代码 详细的讲述了portlet是如何工作的 非常棒\r\n\r\n1.在portlet.xml中配置首选参数 如获取数据源 jndi的名字\r\n\r\n2.以实例讲述了 portlet的多种模式 doview, doedit,doconfig\r\n\r\n3.为portlet添加命名空间以防止 页面中多个portlet存在冲突的情况 如下定义一个form的名字\r\n\r\n&lt;form method=\"post\" name=\"&lt;portlet:namespace/&gt;editform\"&gt;\r\n\r\n4.讲述了 &lt;portlet:actionURL /&gt; &lt;portlet:renderURL /&gt;的区别 一个调用processAction方法 一个直接调用doXXX方法。\r\n\r\n小结：在实际运用中可能不需要这么多模式 可以直接通过  &lt;portlet:actionURL /&gt;和 &lt;portlet:renderURL /&gt; 来实现不同页面的跳转 值传递来处理业务。 因为有的时候 portlet的主题会导致编辑，以及配置等连接无法直接展现给用户，如portal8 需要在编辑模式下 才能展现，对用户来说不是很方便。\r\n\r\n&nbsp;\r\n\r\n<a href=\"http://localhost/wordpress/wp-content/uploads/2012/09/portletwb-samples.zip\">portletwb-samples</a>','一个基于联系人地址的 ibm portlet 实例','','inherit','open','open','','118-revision-v1','','','2013-08-23 14:04:28','2013-08-23 06:04:28','',118,'http://localhost/wordpress-new/?p=119',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (120,1,'2013-08-23 14:04:48','2013-08-23 06:04:48','LTPA(Lightweight Third Party Authentication)技术是IBM的标准。当某用户访问某WebSphere URL时,系统会提示他输入用户名和口令进行登录。这时用户可以输入他的惟一标识符,通过验证后,Web服务器将把该用户的Web 浏览器中显示的Web 站点内容发送回来。在场景后台,WebSphere入口网站服务器将会建立包含已鉴别使用者认证的单点登录Cookie(默认值是LTPA记号),并且会一直发送该cookie, 而浏览器通常的默认设置是允许接收cookie的,因此用户的浏览器将保存这个cookie。 LTPA cookie是临时的,只在浏览器内存中存留,用户如果关闭浏览器,cookie就会被永久删除。LTPA cookie的特点如下：\r\n(1)LTPA cookie是一种典型的浏览器cookie。LTPA cookie特有的名称是LtpaToken。当配置 SSO时,在配置实用工具中,LTPA cookie有一个被编码值,隐藏起cookie中包含的重要信息并且通过Internet传输。\r\n(2)LTPA cookie 不能跨域，通常SSO环境必须部署到单一DNS域中,即每台服务器都在同一DNS域中。\r\n(3)在用户已经登录并且该用户的浏览器接收到 LTPA cookie以后,在HTTP通信中不再需要进行特定的配置,浏览器运行的标准方法就是浏览器将自动发送该cookie。浏览器不断地向任何正确的DNS域中的URL目标发送HTTP请求，通过这种途径不断地向外发送LPTA cookie。当SSO服务接收到HTTP请求并且发现请求中包含了LTPA cookie时,服务器将验证cookie，随即可知道该cookie属于哪一位已经登录的用户，服务器就可以允许这个用户对这台服务器进行适当的访问。浏览器的任务就是确定在什么时候应该随同HTTP通信一起发出LTPA cookie。当用户浏览到一个不在同一DNS域中的URL时, 因为该cookie不适用于这个新的DNS域,浏览器则不会发送 LTPA cookie,新的DNS目标的接收服务器就不知道用户是谁,这时会提示用户输入他的用户名和口令。\r\n(4)LTPA cookie是安全的,因为服务器在创建它时，使用一组加密密钥进行了安全加密。加密密钥用于对cookie进行编码,编码后的cookie传送到用户浏览器,而浏览器只对有加密密钥的cookie进行解码和验证cookie的完整性,并随时检测cookie是否被篡改过。在SSO环境中的所有服务器必须共享同一个加密密钥。当SSO服务器接收到HTTP请求并发现其中包含LTPA cookie时,就使用它共享的加密密钥副本验证cookie,这时有效的cookie信息就使服务器能够识别出登录的用户。\r\nSSO服务器使用的安全加密确保了没有任何伪造cookie的机会。没有加密密钥,其他非法 的cookie不会通过验证,伪造的cookie将被忽略。因此，SSO服务器不会被入侵。\r\n在WebSphere Portal环境中,LTPA加密密钥通常在配置SSO时由WebSphere 创建。管理员可以将密钥导出到文件中,然后转移该文件到其他的SSO服务器（例如Domino）,在那里导入密钥。系统的管理维护人员应该非常小心地处理密钥文件,把所有的副本保护好。\r\n这样,LTPA技术就实现了WebSphere Portal门户网站的安全性','IBM portal LTPA','','publish','open','open','','ibm-portal-ltpa','','','2013-08-23 14:04:48','2013-08-23 06:04:48','',0,'http://localhost/wordpress-new/?p=120',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (121,1,'2013-08-23 14:04:48','2013-08-23 06:04:48','LTPA(Lightweight Third Party Authentication)技术是IBM的标准。当某用户访问某WebSphere URL时,系统会提示他输入用户名和口令进行登录。这时用户可以输入他的惟一标识符,通过验证后,Web服务器将把该用户的Web 浏览器中显示的Web 站点内容发送回来。在场景后台,WebSphere入口网站服务器将会建立包含已鉴别使用者认证的单点登录Cookie(默认值是LTPA记号),并且会一直发送该cookie, 而浏览器通常的默认设置是允许接收cookie的,因此用户的浏览器将保存这个cookie。 LTPA cookie是临时的,只在浏览器内存中存留,用户如果关闭浏览器,cookie就会被永久删除。LTPA cookie的特点如下：\r\n(1)LTPA cookie是一种典型的浏览器cookie。LTPA cookie特有的名称是LtpaToken。当配置 SSO时,在配置实用工具中,LTPA cookie有一个被编码值,隐藏起cookie中包含的重要信息并且通过Internet传输。\r\n(2)LTPA cookie 不能跨域，通常SSO环境必须部署到单一DNS域中,即每台服务器都在同一DNS域中。\r\n(3)在用户已经登录并且该用户的浏览器接收到 LTPA cookie以后,在HTTP通信中不再需要进行特定的配置,浏览器运行的标准方法就是浏览器将自动发送该cookie。浏览器不断地向任何正确的DNS域中的URL目标发送HTTP请求，通过这种途径不断地向外发送LPTA cookie。当SSO服务接收到HTTP请求并且发现请求中包含了LTPA cookie时,服务器将验证cookie，随即可知道该cookie属于哪一位已经登录的用户，服务器就可以允许这个用户对这台服务器进行适当的访问。浏览器的任务就是确定在什么时候应该随同HTTP通信一起发出LTPA cookie。当用户浏览到一个不在同一DNS域中的URL时, 因为该cookie不适用于这个新的DNS域,浏览器则不会发送 LTPA cookie,新的DNS目标的接收服务器就不知道用户是谁,这时会提示用户输入他的用户名和口令。\r\n(4)LTPA cookie是安全的,因为服务器在创建它时，使用一组加密密钥进行了安全加密。加密密钥用于对cookie进行编码,编码后的cookie传送到用户浏览器,而浏览器只对有加密密钥的cookie进行解码和验证cookie的完整性,并随时检测cookie是否被篡改过。在SSO环境中的所有服务器必须共享同一个加密密钥。当SSO服务器接收到HTTP请求并发现其中包含LTPA cookie时,就使用它共享的加密密钥副本验证cookie,这时有效的cookie信息就使服务器能够识别出登录的用户。\r\nSSO服务器使用的安全加密确保了没有任何伪造cookie的机会。没有加密密钥,其他非法 的cookie不会通过验证,伪造的cookie将被忽略。因此，SSO服务器不会被入侵。\r\n在WebSphere Portal环境中,LTPA加密密钥通常在配置SSO时由WebSphere 创建。管理员可以将密钥导出到文件中,然后转移该文件到其他的SSO服务器（例如Domino）,在那里导入密钥。系统的管理维护人员应该非常小心地处理密钥文件,把所有的副本保护好。\r\n这样,LTPA技术就实现了WebSphere Portal门户网站的安全性','IBM portal LTPA','','inherit','open','open','','120-revision-v1','','','2013-08-23 14:04:48','2013-08-23 06:04:48','',120,'http://localhost/wordpress-new/?p=121',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (122,1,'2013-08-23 14:05:16','2013-08-23 06:05:16','简介：\r\nLTPA 浏览器 cookie 是典型的浏览器 cookie。如果不了解浏览器 cookies，就请注意，cookie 是将信息保存在用户的计算机上，以备以后使用的一种标准方法。LTPA cookie 中保存的信息表示user已经进行了登录。所有的浏览器 cookies 都有一些标准属性，例如名称。LTPA cookie 特有的名称是 LtpaToken。（顺便说一下，当配置 SSO 时，在我们的配置实用工具中，通常将 LTPA cookie 称为 SSO LTPA“令牌”。这里谈到 SSO cookie，也等同于使用 SSO 令牌这一术语。）除 cookie 名称外，与所有的浏览器 cookie 一样，LTPA cookie 有一个值。在使用 LTPA cookie 的情况下，无法在第一眼看到 cookie 时理解这个值，因为这个值已经被编码。通过要求将 LTPA cookie 值编码，cookie 中包含的重要信息可以隐藏起来，通过 internet 传输。\r\n\r\n作为典型的浏览器 cookie，LTPA 浏览器 cookie 具有相关的域信息。当 user 在 portal 登录时， portal服务器创建了 LTPA cookie。 portal 服务器在 portal.com DNS 域中，因此 cookie 域信息被设置为 portal.com。域信息表示该 cookie 只能在 portal.com DNS 域中使用。由于 LTPA 的实现依赖于具有域信息的浏览器 cookies，通常这意味着 SSO 环境必须部署到单一 DNS 域中。在我们的部署例子中，服务器是 ibm.portal.com、demo.portal.com 和 oa.portal.com。每一台设备都在 portal.com DNS 域中。只能在单一 DNS 域中部署 SSO 这一限制，直接与 LTAP 实现的核心是带有域信息的浏览器 cookie 这一情况相关。如果确实需要突破必须将所有 SSO 机器放在同一个 DNS 域中的限制，那么可以通过部署名为 IBM Tivoli Access Manager 的附加基础设施来实现。Access Manager 包括提供访问 Web 内容的中心点的 WebSEAL 反向代理服务器。WebSEAL 将所有的 SSO 通信路由到位于各种各样 DNS 域中的后端服务器。那么可以实现跨域的SSO\r\n\r\nSSO 的根本出发点是为方便用户，但是如果它不安全，那么它的意义就不大了。。LTPA cookie 是安全的，因为在创建它时进行了安全加密。服务器在创建 LTPA cookie 时，使用一组加密密钥。加密密钥用于对 cookie 进行编码，编码后的 cookie 传送到用户浏览器，除非有加密密钥，否则无法对 cookie 进行解码。同时还使用加密密钥验证 cookie，例如可以验证 cookie 的完整性和随时检测 cookie 是否被篡改。SSO 环境中的所有服务器必须共享同一加密密钥。当 SSO 服务器接收到 HTTP 请求并发现其中包含 LTPA cookie 时，服务器使用它共享的加密密钥副本验证 cookie，有效 cookie 中的信息使服务器能够识别登录的用户。SSO 服务器使用的安全加密确保没有任何伪造 cookie 的机会。在 WebSphere Portal 环境中，LTPA 加密密钥通常在配置 SSO 时由 WebSphere 创建。管理员可以将密钥导出到文件中，然后转移该文件到其他的 SSO 服务器（例如，Domino），这样可以在那里导入密钥。显而易见，您应该非常小心地处理这个密钥文件，并将所有副本保护好。\r\n现在，让我回过头来探讨在编码的 cookie 内部有什么。首先用户提供了他的用户名 jb013 和他的口令。接着登录服务器在目录中查找用户 jb013。在目录中，设想查找到了带有惟一名称 uid=jb013,ou=secret,dc=spies,dc=com 的用户条目。验证该用户的口令后，现在服务器可以通过这个惟一名称识别这个用户。这个惟一名称被写入到生成的 LTPA cookie 中并发送到浏览器。浏览器随同 HTTP 通信一起发送该 cookie。接下来会发生什么呢？当浏览到 SSO 环境中的 URL 时，SSO 接收到该 cookie 并使用加密密钥解码和验证它。SSO 服务器将发现在 cookie 内有这个用户的名称 uid=jb013,ou=secret,dc=spies,dc=com。SSO 服务器基于 LTPA cookie 中提供的名称标识该用户。\r\n在所有 SSO 组件都使用一个目录的环境中，LTPA cookie 中的名称足以确切地标识用户。但是，在有多个目录的更复杂的环境中，如果为某个单一用户（例如 Bland）在这些目录中使用多个名称格式，就会引起问题。假设使用了两个目录：Microsoft 的 Active Directory 和 IBM Lotus Domino Directory。当 Bland 的 Active Directory 专有名称与他定义的 Domino 专有名称不同时就会发生问题。当用户具有一个以上的名称时，就会出现问题，因为 LTPA cookie 包含且仅包含一个名称以标识已登录的用户。LTPA cookie 中包括的用户名称可能是接收服务器对该用户所知道的惟一信息。如果接收服务器在识别 LTPA cookie 中的名称时遇到麻烦，将会导致 SSO 令人沮丧地失败。\r\nSSO cookie 的安全\r\nLTPA cookie 的安全性非常重要，当其穿越未受保护的网络时，LTPA cookie 易于被盗取，注意到这一点非常关键。即使 cookie 被编码而且不会立即显示出 cookie 所代表的登录用户，但是显然对于一些黑客，他会窃取所看到的每个通过 HTTP 通信传输的 cookie，并使用每一个 cookie 进行尝试。但是，使用这种卑劣的手段，要想一直获得成功，黑客 将需要监视网络并不断地窃取新 cookie。虽然钻石是永恒不变的，但所窃取的 cookie 却不会长期有效。可以将 LTPA cookie 设置为在配置一段时间后到期，并且到期后不再有效。尽管如此，当 cookie 在未受保护的网络上被暴露时，一个完全出于犯罪动机的人也不难反复窃取 cookie。\r\n\r\n幸运的是，如果在 SSO 服务器上部署了 SSL，那么那些坏人就无法盗取信息。应该使用 SSL（安全套接字层）对浏览器和服务器间的通信（通过 https 访问的 URL）进行加密。如果黑客正在探查线路，这些恶意攻击者将只能看到网络中被加密的信息，而且完全无法捕获 LTPA cookie。应该在 SSO 环境中的每台服务器上都部署 SSL。\r\n\r\n我们有时会受到资源短缺的限制。如果由于资源有限，完全的 SSL 部署和支持注定是不切实际的，那么可以考虑部署一个反向代理服务器，以充当访问 SSO 环境的网关和中心点。在反向代理服务器场景中，有一个“不受信任的网络”的概念，用户可能位于该网络中，并且所有 SSO 服务器都位于“受信任的”网络中。在反向代理服务器场景中，所有的 SSO 通信都通过反向代理服务器流出，因此必须在其上部署 SSL 的关键点是反向代理服务器自身，这可以保护与不受信任网络上的用户浏览器的通信。\r\n\r\n不幸的是，如果将 SSL 部署仅限于反向代理服务器，则在受信任网络中，当通过代理服务器将 LTPA cookie 传递给后端 SSO 服务器时，LTPA cookie 仍然易遭受攻击。很难确定受信任网络是否真的可靠。任何环境中都有可能存在不道德的内部人员，他们隐藏在内部并随时都可能攻击未受保护的 cookie。（“受信任”网络中有未受保护的 cookie 可用，不道德的内部人员有机会进行很多恶意活动。）\r\n\r\n.Summary: This white paper provides an in-depth explanation of how the single sign-on (SSO) feature works between IBM WebSphere Portal and IBM Lotus Domino. Learn the basics of how cookies are written to―and used in―Internet browsers, how the cookies are used to enable SSO, and exactly what is in the token and why it\'s needed for SSO between two servers. Included are specific details of where the WebSphere Portal and Lotus Domino servers configure each part of the cookie used for SSO, the LTPAToken. Editor\'s Note: This white paper is the first in a three-part series on SSO to be published over the next few months. See the second paper, \"Configuring single sign-on (SSO) between IBM WebSphere Portal and IBM Lotus Domino.\"\r\n\r\n1.\r\nUnderstanding single sign-on (SSO) between IBM WebSphere Portal and IBM Lotus Domino\r\nhttp://public.dhe.ibm.com/software/dw/websphere/SSOPortal-DominoFinal.pdf\r\n2.\r\nConfiguring single sign-on (SSO) between IBM WebSphere Portal and IBM Lotus Domino\r\nhttp://public.dhe.ibm.com/software/dw/websphere/ConfigSSOFinal.pdf\r\n3.\r\nTroubleshooting single sign-on (SSO) between IBM WebSphere Portal and IBM Lotus Domino\r\nhttp://public.dhe.ibm.com/software/dw/websphere/TroubleshootSSOFinal.pdf\r\n\r\n备注：对于多目录多身份环境中 如何让portal与domino或者 ibm的组件产品实现SSO可以参考下面的连接\r\nhttp://www.ibm.com/developerworks/cn/lotus/sso2/\r\n\r\n如何使用ibm 提供的ldap服务器以及如何创建组 以及用户\r\n\r\nhttp://www.ibm.com/developerworks/cn/websphere/library/techarticles/lizhi/0402_ldap4wpc/ldap4wpc_1.html\r\n\r\n对于IDS 6.0以上的版本 新推出了一种用户存储方式 联合存储库 详细信息 在以下链接\r\n\r\nhttp://www.ibm.com/developerworks/cn/websphere/library/techarticles/0804_cfliu/index.html\r\n\r\nIBM TDS 管理控制台的口令 superadmin/secret  (备注)','SSO between IBM WebSphere Portal and IBM Lotus Domino','','publish','open','open','','sso-between-ibm-websphere-portal-and-ibm-lotus-domino','','','2013-08-23 14:05:16','2013-08-23 06:05:16','',0,'http://localhost/wordpress-new/?p=122',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (123,1,'2013-08-23 14:05:16','2013-08-23 06:05:16','简介：\r\nLTPA 浏览器 cookie 是典型的浏览器 cookie。如果不了解浏览器 cookies，就请注意，cookie 是将信息保存在用户的计算机上，以备以后使用的一种标准方法。LTPA cookie 中保存的信息表示user已经进行了登录。所有的浏览器 cookies 都有一些标准属性，例如名称。LTPA cookie 特有的名称是 LtpaToken。（顺便说一下，当配置 SSO 时，在我们的配置实用工具中，通常将 LTPA cookie 称为 SSO LTPA“令牌”。这里谈到 SSO cookie，也等同于使用 SSO 令牌这一术语。）除 cookie 名称外，与所有的浏览器 cookie 一样，LTPA cookie 有一个值。在使用 LTPA cookie 的情况下，无法在第一眼看到 cookie 时理解这个值，因为这个值已经被编码。通过要求将 LTPA cookie 值编码，cookie 中包含的重要信息可以隐藏起来，通过 internet 传输。\r\n\r\n作为典型的浏览器 cookie，LTPA 浏览器 cookie 具有相关的域信息。当 user 在 portal 登录时， portal服务器创建了 LTPA cookie。 portal 服务器在 portal.com DNS 域中，因此 cookie 域信息被设置为 portal.com。域信息表示该 cookie 只能在 portal.com DNS 域中使用。由于 LTPA 的实现依赖于具有域信息的浏览器 cookies，通常这意味着 SSO 环境必须部署到单一 DNS 域中。在我们的部署例子中，服务器是 ibm.portal.com、demo.portal.com 和 oa.portal.com。每一台设备都在 portal.com DNS 域中。只能在单一 DNS 域中部署 SSO 这一限制，直接与 LTAP 实现的核心是带有域信息的浏览器 cookie 这一情况相关。如果确实需要突破必须将所有 SSO 机器放在同一个 DNS 域中的限制，那么可以通过部署名为 IBM Tivoli Access Manager 的附加基础设施来实现。Access Manager 包括提供访问 Web 内容的中心点的 WebSEAL 反向代理服务器。WebSEAL 将所有的 SSO 通信路由到位于各种各样 DNS 域中的后端服务器。那么可以实现跨域的SSO\r\n\r\nSSO 的根本出发点是为方便用户，但是如果它不安全，那么它的意义就不大了。。LTPA cookie 是安全的，因为在创建它时进行了安全加密。服务器在创建 LTPA cookie 时，使用一组加密密钥。加密密钥用于对 cookie 进行编码，编码后的 cookie 传送到用户浏览器，除非有加密密钥，否则无法对 cookie 进行解码。同时还使用加密密钥验证 cookie，例如可以验证 cookie 的完整性和随时检测 cookie 是否被篡改。SSO 环境中的所有服务器必须共享同一加密密钥。当 SSO 服务器接收到 HTTP 请求并发现其中包含 LTPA cookie 时，服务器使用它共享的加密密钥副本验证 cookie，有效 cookie 中的信息使服务器能够识别登录的用户。SSO 服务器使用的安全加密确保没有任何伪造 cookie 的机会。在 WebSphere Portal 环境中，LTPA 加密密钥通常在配置 SSO 时由 WebSphere 创建。管理员可以将密钥导出到文件中，然后转移该文件到其他的 SSO 服务器（例如，Domino），这样可以在那里导入密钥。显而易见，您应该非常小心地处理这个密钥文件，并将所有副本保护好。\r\n现在，让我回过头来探讨在编码的 cookie 内部有什么。首先用户提供了他的用户名 jb013 和他的口令。接着登录服务器在目录中查找用户 jb013。在目录中，设想查找到了带有惟一名称 uid=jb013,ou=secret,dc=spies,dc=com 的用户条目。验证该用户的口令后，现在服务器可以通过这个惟一名称识别这个用户。这个惟一名称被写入到生成的 LTPA cookie 中并发送到浏览器。浏览器随同 HTTP 通信一起发送该 cookie。接下来会发生什么呢？当浏览到 SSO 环境中的 URL 时，SSO 接收到该 cookie 并使用加密密钥解码和验证它。SSO 服务器将发现在 cookie 内有这个用户的名称 uid=jb013,ou=secret,dc=spies,dc=com。SSO 服务器基于 LTPA cookie 中提供的名称标识该用户。\r\n在所有 SSO 组件都使用一个目录的环境中，LTPA cookie 中的名称足以确切地标识用户。但是，在有多个目录的更复杂的环境中，如果为某个单一用户（例如 Bland）在这些目录中使用多个名称格式，就会引起问题。假设使用了两个目录：Microsoft 的 Active Directory 和 IBM Lotus Domino Directory。当 Bland 的 Active Directory 专有名称与他定义的 Domino 专有名称不同时就会发生问题。当用户具有一个以上的名称时，就会出现问题，因为 LTPA cookie 包含且仅包含一个名称以标识已登录的用户。LTPA cookie 中包括的用户名称可能是接收服务器对该用户所知道的惟一信息。如果接收服务器在识别 LTPA cookie 中的名称时遇到麻烦，将会导致 SSO 令人沮丧地失败。\r\nSSO cookie 的安全\r\nLTPA cookie 的安全性非常重要，当其穿越未受保护的网络时，LTPA cookie 易于被盗取，注意到这一点非常关键。即使 cookie 被编码而且不会立即显示出 cookie 所代表的登录用户，但是显然对于一些黑客，他会窃取所看到的每个通过 HTTP 通信传输的 cookie，并使用每一个 cookie 进行尝试。但是，使用这种卑劣的手段，要想一直获得成功，黑客 将需要监视网络并不断地窃取新 cookie。虽然钻石是永恒不变的，但所窃取的 cookie 却不会长期有效。可以将 LTPA cookie 设置为在配置一段时间后到期，并且到期后不再有效。尽管如此，当 cookie 在未受保护的网络上被暴露时，一个完全出于犯罪动机的人也不难反复窃取 cookie。\r\n\r\n幸运的是，如果在 SSO 服务器上部署了 SSL，那么那些坏人就无法盗取信息。应该使用 SSL（安全套接字层）对浏览器和服务器间的通信（通过 https 访问的 URL）进行加密。如果黑客正在探查线路，这些恶意攻击者将只能看到网络中被加密的信息，而且完全无法捕获 LTPA cookie。应该在 SSO 环境中的每台服务器上都部署 SSL。\r\n\r\n我们有时会受到资源短缺的限制。如果由于资源有限，完全的 SSL 部署和支持注定是不切实际的，那么可以考虑部署一个反向代理服务器，以充当访问 SSO 环境的网关和中心点。在反向代理服务器场景中，有一个“不受信任的网络”的概念，用户可能位于该网络中，并且所有 SSO 服务器都位于“受信任的”网络中。在反向代理服务器场景中，所有的 SSO 通信都通过反向代理服务器流出，因此必须在其上部署 SSL 的关键点是反向代理服务器自身，这可以保护与不受信任网络上的用户浏览器的通信。\r\n\r\n不幸的是，如果将 SSL 部署仅限于反向代理服务器，则在受信任网络中，当通过代理服务器将 LTPA cookie 传递给后端 SSO 服务器时，LTPA cookie 仍然易遭受攻击。很难确定受信任网络是否真的可靠。任何环境中都有可能存在不道德的内部人员，他们隐藏在内部并随时都可能攻击未受保护的 cookie。（“受信任”网络中有未受保护的 cookie 可用，不道德的内部人员有机会进行很多恶意活动。）\r\n\r\n.Summary: This white paper provides an in-depth explanation of how the single sign-on (SSO) feature works between IBM WebSphere Portal and IBM Lotus Domino. Learn the basics of how cookies are written to―and used in―Internet browsers, how the cookies are used to enable SSO, and exactly what is in the token and why it\'s needed for SSO between two servers. Included are specific details of where the WebSphere Portal and Lotus Domino servers configure each part of the cookie used for SSO, the LTPAToken. Editor\'s Note: This white paper is the first in a three-part series on SSO to be published over the next few months. See the second paper, \"Configuring single sign-on (SSO) between IBM WebSphere Portal and IBM Lotus Domino.\"\r\n\r\n1.\r\nUnderstanding single sign-on (SSO) between IBM WebSphere Portal and IBM Lotus Domino\r\nhttp://public.dhe.ibm.com/software/dw/websphere/SSOPortal-DominoFinal.pdf\r\n2.\r\nConfiguring single sign-on (SSO) between IBM WebSphere Portal and IBM Lotus Domino\r\nhttp://public.dhe.ibm.com/software/dw/websphere/ConfigSSOFinal.pdf\r\n3.\r\nTroubleshooting single sign-on (SSO) between IBM WebSphere Portal and IBM Lotus Domino\r\nhttp://public.dhe.ibm.com/software/dw/websphere/TroubleshootSSOFinal.pdf\r\n\r\n备注：对于多目录多身份环境中 如何让portal与domino或者 ibm的组件产品实现SSO可以参考下面的连接\r\nhttp://www.ibm.com/developerworks/cn/lotus/sso2/\r\n\r\n如何使用ibm 提供的ldap服务器以及如何创建组 以及用户\r\n\r\nhttp://www.ibm.com/developerworks/cn/websphere/library/techarticles/lizhi/0402_ldap4wpc/ldap4wpc_1.html\r\n\r\n对于IDS 6.0以上的版本 新推出了一种用户存储方式 联合存储库 详细信息 在以下链接\r\n\r\nhttp://www.ibm.com/developerworks/cn/websphere/library/techarticles/0804_cfliu/index.html\r\n\r\nIBM TDS 管理控制台的口令 superadmin/secret  (备注)','SSO between IBM WebSphere Portal and IBM Lotus Domino','','inherit','open','open','','122-revision-v1','','','2013-08-23 14:05:16','2013-08-23 06:05:16','',122,'http://localhost/wordpress-new/?p=123',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (124,1,'2013-08-23 14:05:42','2013-08-23 06:05:42','1:Lotus Quickr connectors (quickr的桌面产品 用于在桌面上上传文档到quickr)\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/quickr-connectors/index.html\r\n\r\n2:通过 WebSphere Portal 的 RCSS 搜索 Lotus Quickr 中的内容 这里讲述了\r\n\r\nportal 和quickr的sso ltpa ssl 以及内容搜索等一系列问题\r\n\r\n配置 WebSphere Portal 和 Lotus Quickr 之间的单点登录（SSO，Single Sign On）\r\n为 WebSphere Portal 和 Lotus Quickr 配置 SSL 安全连接（Secure Socket Layer，安全套接层连接）\r\n配置 WebSphere Portal 的远程内容服务器搜索\r\n配置面向 Lotus Quickr 的搜索范围（Search Scope）等配置方式\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/quickr-wpsrcss/\r\n\r\n3:IBM Lotus Quickr REST 服务简介 quickr 为开发人员提供的  API\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/quickr-rest/\r\n\r\n4: 在 IBM WebSphere Portal 中整合 IBM Lotus Quickr 协作功能 再实现了 第2个内容的内容后可以对其进行整合\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/portal-quickrdoc/\r\n\r\n5.quickr 中的通知功能 主要是采用邮件来实现通知的\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/ls-cn-quickr85p-notif/\r\n\r\n&nbsp;','Lotus Quickr 产品简介','','publish','open','open','','lotus-quickr-%e4%ba%a7%e5%93%81%e7%ae%80%e4%bb%8b','','','2013-08-23 14:05:42','2013-08-23 06:05:42','',0,'http://localhost/wordpress-new/?p=124',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (125,1,'2013-08-23 14:05:42','2013-08-23 06:05:42','1:Lotus Quickr connectors (quickr的桌面产品 用于在桌面上上传文档到quickr)\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/quickr-connectors/index.html\r\n\r\n2:通过 WebSphere Portal 的 RCSS 搜索 Lotus Quickr 中的内容 这里讲述了\r\n\r\nportal 和quickr的sso ltpa ssl 以及内容搜索等一系列问题\r\n\r\n配置 WebSphere Portal 和 Lotus Quickr 之间的单点登录（SSO，Single Sign On）\r\n为 WebSphere Portal 和 Lotus Quickr 配置 SSL 安全连接（Secure Socket Layer，安全套接层连接）\r\n配置 WebSphere Portal 的远程内容服务器搜索\r\n配置面向 Lotus Quickr 的搜索范围（Search Scope）等配置方式\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/quickr-wpsrcss/\r\n\r\n3:IBM Lotus Quickr REST 服务简介 quickr 为开发人员提供的  API\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/quickr-rest/\r\n\r\n4: 在 IBM WebSphere Portal 中整合 IBM Lotus Quickr 协作功能 再实现了 第2个内容的内容后可以对其进行整合\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/portal-quickrdoc/\r\n\r\n5.quickr 中的通知功能 主要是采用邮件来实现通知的\r\n\r\nhttp://www.ibm.com/developerworks/cn/lotus/ls-cn-quickr85p-notif/\r\n\r\n&nbsp;','Lotus Quickr 产品简介','','inherit','open','open','','124-revision-v1','','','2013-08-23 14:05:42','2013-08-23 06:05:42','',124,'http://localhost/wordpress-new/?p=125',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (126,1,'2013-08-23 14:06:09','2013-08-23 06:06:09','RSS 和 Atom 是相似的基于 XML 的文档格式，描述被称为摘要（feed）的相关信息列表。这些摘要由许多项组成，每项都带有一套可扩展的附加元数据；例如，每项都有一个标题。这些摘要的主要用途是用于 Web 内容联合，比如用于 Web 站点和直接用于用户代理的 Weblog 或者新闻标题。\r\n\r\n一般来说Atom是对RSS的一个扩展 Atom不仅仅是给普通用户使用 对于开发人员也非常强大。Atom 发布协议是一种基于 HTTP 的用于创建和编辑 Web 资源的方法。它基本上围绕着这样一种观念设计，即利用 HTTP 协议提供的基本操作（如 GET、PUT 和 DELETE）传输表示 blog 项、博客、wiki 页面、日程记录等内容的 Atom 1.0 Feed and Entry 文档实例。而RSS对于当前来说更多的是用于消息的发布。\r\n\r\n当前有很多第三方库用来简化rss和atom的发布和消费。\r\n\r\n如 Rome(rss,atom),Apache Abdera(atom)   等等\r\n\r\n下面是简单的调用方法用户消费feed  更详细的文档可以参考官方文档\r\n\r\nrome.jar---\r\n\r\nSyndFeedInput input = new SyndFeedInput();\r\nInputStream ind = new FileInputStream(\"c:\\\\xml.xml\");\r\nInputSource sr = new InputSource();\r\nsr.setByteStream(ind);\r\nSyndFeed feedd = input.build(sr);\r\nfor (int i=0;i&lt; feed.getEntries().size();i++){\r\nSyndEntry en =(SyndEntry)feedd.getEntries().get(i);\r\nSystem.out.print(en.getAuthor()+\": \");\r\nSystem.out.println(en.getDescription().getValue());\r\n}\r\n\r\nAbdera ------------注意 Abdera 只能处理atom格式的的至少当前是\r\n\r\nParser parser = Abdera.getNewParser();\r\nInputStream in = new FileInputStream(\"c:\\\\xml.xml\");\r\nDocument&lt;Feed&gt; doc = parser.parse(in);\r\nFeed feed = doc.getRoot();\r\nSystem.out.println(feed.getTitle());\r\nSystem.out.println(feed.getTitleType());\r\nSystem.out.println(feed.getAlternateLink().getResolvedHref());\r\nSystem.out.println(feed.getUpdated());\r\nSystem.out.println(feed.getId());\r\nEntry entry = feed.getEntries().get(0);\r\nSystem.out.println(entry.getAuthor().getName());\r\nSystem.out.println(entry.getTitle());\r\nSystem.out.println(entry.getTitleType());\r\nSystem.out.println(entry.getAlternateLink().getHref()); // relative URI\r\nSystem.out.println(entry.getAlternateLink().getResolvedHref()); // absolute URI resolved against Base URI\r\nSystem.out.println(entry.getId());\r\nSystem.out.println(entry.getUpdated());\r\nSystem.out.println(entry.getSummary());\r\nSystem.out.println(entry.getSummaryType());\r\n\r\n使用Abdera你可以发布自己的atom消息源 也可以为你的应用给第三方开放接口用于数据交换，因此atom协议比rss更强大\r\n\r\n下面是一篇介绍atom的ibm的文档很不错详细的讲述了atom协议的功能以及如何通过开源框架去发布和使用atom\r\n\r\nhttp://www.ibm.com/developerworks/cn/xml/x-atompp1/index.html\r\n\r\n&nbsp;\r\n\r\n&nbsp;','消息源聚合 简介RSS与Atom','','publish','open','open','','%e6%b6%88%e6%81%af%e6%ba%90%e8%81%9a%e5%90%88-%e7%ae%80%e4%bb%8brss%e4%b8%8eatom','','','2013-08-23 14:06:09','2013-08-23 06:06:09','',0,'http://localhost/wordpress-new/?p=126',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (127,1,'2013-08-23 14:06:09','2013-08-23 06:06:09','RSS 和 Atom 是相似的基于 XML 的文档格式，描述被称为摘要（feed）的相关信息列表。这些摘要由许多项组成，每项都带有一套可扩展的附加元数据；例如，每项都有一个标题。这些摘要的主要用途是用于 Web 内容联合，比如用于 Web 站点和直接用于用户代理的 Weblog 或者新闻标题。\r\n\r\n一般来说Atom是对RSS的一个扩展 Atom不仅仅是给普通用户使用 对于开发人员也非常强大。Atom 发布协议是一种基于 HTTP 的用于创建和编辑 Web 资源的方法。它基本上围绕着这样一种观念设计，即利用 HTTP 协议提供的基本操作（如 GET、PUT 和 DELETE）传输表示 blog 项、博客、wiki 页面、日程记录等内容的 Atom 1.0 Feed and Entry 文档实例。而RSS对于当前来说更多的是用于消息的发布。\r\n\r\n当前有很多第三方库用来简化rss和atom的发布和消费。\r\n\r\n如 Rome(rss,atom),Apache Abdera(atom)   等等\r\n\r\n下面是简单的调用方法用户消费feed  更详细的文档可以参考官方文档\r\n\r\nrome.jar---\r\n\r\nSyndFeedInput input = new SyndFeedInput();\r\nInputStream ind = new FileInputStream(\"c:\\\\xml.xml\");\r\nInputSource sr = new InputSource();\r\nsr.setByteStream(ind);\r\nSyndFeed feedd = input.build(sr);\r\nfor (int i=0;i&lt; feed.getEntries().size();i++){\r\nSyndEntry en =(SyndEntry)feedd.getEntries().get(i);\r\nSystem.out.print(en.getAuthor()+\": \");\r\nSystem.out.println(en.getDescription().getValue());\r\n}\r\n\r\nAbdera ------------注意 Abdera 只能处理atom格式的的至少当前是\r\n\r\nParser parser = Abdera.getNewParser();\r\nInputStream in = new FileInputStream(\"c:\\\\xml.xml\");\r\nDocument&lt;Feed&gt; doc = parser.parse(in);\r\nFeed feed = doc.getRoot();\r\nSystem.out.println(feed.getTitle());\r\nSystem.out.println(feed.getTitleType());\r\nSystem.out.println(feed.getAlternateLink().getResolvedHref());\r\nSystem.out.println(feed.getUpdated());\r\nSystem.out.println(feed.getId());\r\nEntry entry = feed.getEntries().get(0);\r\nSystem.out.println(entry.getAuthor().getName());\r\nSystem.out.println(entry.getTitle());\r\nSystem.out.println(entry.getTitleType());\r\nSystem.out.println(entry.getAlternateLink().getHref()); // relative URI\r\nSystem.out.println(entry.getAlternateLink().getResolvedHref()); // absolute URI resolved against Base URI\r\nSystem.out.println(entry.getId());\r\nSystem.out.println(entry.getUpdated());\r\nSystem.out.println(entry.getSummary());\r\nSystem.out.println(entry.getSummaryType());\r\n\r\n使用Abdera你可以发布自己的atom消息源 也可以为你的应用给第三方开放接口用于数据交换，因此atom协议比rss更强大\r\n\r\n下面是一篇介绍atom的ibm的文档很不错详细的讲述了atom协议的功能以及如何通过开源框架去发布和使用atom\r\n\r\nhttp://www.ibm.com/developerworks/cn/xml/x-atompp1/index.html\r\n\r\n&nbsp;\r\n\r\n&nbsp;','消息源聚合 简介RSS与Atom','','inherit','open','open','','126-revision-v1','','','2013-08-23 14:06:09','2013-08-23 06:06:09','',126,'http://localhost/wordpress-new/?p=127',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (128,1,'2013-08-23 14:06:28','2013-08-23 06:06:28','这里简单介绍一下dojo框架的一些基础知识。写这篇文章的时候该版本已推出到1.8 下面的是以1.6的版本为基础而讨论的 从1.7开始dojo采用了AMD（异步模块加载）的方式来实现dojo库的加载。因此为了考虑老版本的dojo采用1.6的版本来说明 dojo的基础用法。后续的版本由于采用amd模式因此在使用方法上跟以前的版本可能会不同 但是基本上保持不变。官方文档中提到对老版本的支持到2.0结束。下面是一些dojo的基础知识。\r\n\r\n1.dojoConfig 对象。\r\n\r\ndojoConfig对象用于配置当前 dojo库的行为。举例说明如下在html页面中添加下面的代码\r\n\r\n&lt;script&gt;\r\nvar dojoConfig = {\r\nisDebug: true,//设置当前dojo模式为调试模式 可以输出错误信息。\r\nparseOnLoad: false, //当页面加载完成前是否对文档进行解析。\r\n};\r\n&lt;/script&gt;\r\n\r\n注意该 对象必须写在 导入dojo库 之前 不然dojo库无法识别该对象 并且在2.0之前该对象有2种 djConfig 和 dojoConfig 2.0以后只支持dojoConfig 以及dojo.query()这种方式不再支持 将使用AMD模式 具体 使用方法参考官方文档http://dojotoolkit.org/documentation/\r\n\r\n2. 模块化\r\n\r\n一般来说一个独立的dojo js文件就是一个模块 模块里面可以是一个widget 也可以是一个类下面是一个列子。这是一个独立的文件app.js 位于 my/目录下  my/app.js\r\n\r\n对于dojo来说默认的整个架构的路径是 以dojo.js文件的上一级目录为根目录的 所有的外部js文件都以它为基准进行查找 如下。（下面的目录结构是代码列出的文件结构目录 后面不在列出）\r\n\r\nwebcontent/index.htm\r\nwebcontent/css\r\nwebcontent/js/dojo1.6/dojo/dojo.js\r\nwebcontent/js/dojo1.6/dojox\r\nwebcontent/js/dojo1.6/dijit\r\nwebcontent/js/dojo1.6/my/app.js\r\nwebcontent/js/dojo1.6/third/data.js\r\nwebcontent/js/dojo1.6/demo/templates/SomeWidget.html\r\n\r\ndojo.provide(\"my.App\");//一个简单的包含包前缀的类 my.App\r\nmy.App.name =\"my app name\";\r\nmy.App.hello = function (){//do some thing\r\n}\r\n\r\n在html里可以这样引用进来 注意my.App不需要执行new 初始化命令 dojo.provide(\"my.App\")就已经定义了该对象my.App因此可以直接使用\r\n&lt;script&gt;\r\ndojo.require(\"my.app\");//引入my/app.js\r\nmy.App.hello();\r\n&lt;/script&gt;\r\n\r\n--------分隔符 另外一种声明的方式来创建类\r\n\r\n-----data.js\r\ndojo.declare(\"third.Data\",null,{\r\nusername:\"jeff\",// declare 命令 (\"包含命名空间的类\",继承的类[dijit.form.button,dijit.form.text],{类属性以及方法})\r\npassword:\"gigi117\",\r\nhello:function(){\r\nalert(\"yes\");\r\n},\r\ngetD:function() {\r\nreturn this.password;}\r\n});\r\n\r\n----index.html\r\n&lt;script&gt;\r\ndojo.require(\"third.data\");\r\nvar td = new third.Data();//因为是声明方式所以需要初始化\r\ntd.getD();\r\n&lt;/script&gt;\r\n\r\n3.-----------自定义模块 自定义的widget\r\n\r\n由于这种结构很容易实现 自定义的widget 也就是采用declare的继承方式。\r\n\r\n定义模板\r\n\r\n---  SomeWidget.html\r\n\r\n&lt;div&gt;\r\n&lt;div data-dojo-attach-point=\"titleNode\" data-dojo-attach-event=\"ondijitclick:onClick\"&gt;&lt;/div&gt;\r\n&lt;div&gt;And our container:&lt;/div&gt;\r\n&lt;div data-dojo-attach-point=\"containerNode\"&gt;&lt;/div&gt;\r\n&lt;/div&gt;\r\n\r\n-----index.html 嵌入js\r\n\r\n&lt;script&gt;\r\ndojo.require(\"dijit._Widget\");//创建widget必须引入\r\ndojo.require(\"dijit._Templated\");//创建widget必须引入 ，因为需要继承\r\n\r\n// To keep the example simple, we\'re declaring our widget inline and then manually parsing.\r\n// Future tutorials will explain how to properly separate this out into its own file.\r\ndojo.ready(function(){\r\n// Declare our widget 继承 _Widget, _Templated\r\ndojo.declare(\"demo.SomeWidget\", [ dijit._Widget, dijit._Templated ], {\r\n// get our template\r\ntemplateString: dojo.cache(\"demo\", \"templates/SomeWidget.html\"),//注意这里的目录结构 在前面有说明\r\n\r\n// some properties\r\nbaseClass: \"someWidgetBase\",\r\ntitle: \"\", // we\'ll set this from the widget def\r\n\r\n// hidden counter\r\n_counter: 1,\r\n_firstClicked: false,\r\n\r\n// define an onClick handler\r\nonClick: function(){\r\nif(this._firstClicked){\r\nthis.titleNode.innerHTML =this.title + \" was clicked \" + (++this._counter) + \" times.\";\r\n} else {\r\nthis.titleNode.innerHTML = this.title + \" was clicked!\";\r\nthis._firstClicked = true;\r\n}\r\n},\r\n\r\npostCreate: function(){\r\nthis.titleNode.innerHTML = this.title;\r\n}\r\n});\r\n\r\n// Now we can parse\r\ndojo.parser.parse();\r\n}); // end dojo.ready\r\n&lt;/script&gt;\r\n\r\n&nbsp;\r\n\r\n-------在index.html里放入模板\r\n\r\n&lt;div data-dojo-type=\"demo.SomeWidget\" data-dojo-props=\"title:\'Our Some Widget\'\"&gt;//放置该widget\r\n&lt;div&gt;Don\'t forget to click on the title!&lt;/div&gt;\r\n&lt;p&gt;This is arbitrary content!&lt;/p&gt;\r\n&lt;button data-dojo-type=\"dijit.form.Button\"&gt;My Button&lt;/button&gt;\r\n&lt;p&gt;More arbitrary content!&lt;/p&gt;\r\n&lt;/div&gt;\r\n\r\n这里只是简要的说明了通过模块化以及decalre声明以及继承的方式创建 自定义的模块 更多细节需要参考官方文档','Dojo toolkit info','','publish','open','open','','dojo-toolkit-info','','','2013-08-23 14:06:28','2013-08-23 06:06:28','',0,'http://localhost/wordpress-new/?p=128',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (129,1,'2013-08-23 14:06:28','2013-08-23 06:06:28','这里简单介绍一下dojo框架的一些基础知识。写这篇文章的时候该版本已推出到1.8 下面的是以1.6的版本为基础而讨论的 从1.7开始dojo采用了AMD（异步模块加载）的方式来实现dojo库的加载。因此为了考虑老版本的dojo采用1.6的版本来说明 dojo的基础用法。后续的版本由于采用amd模式因此在使用方法上跟以前的版本可能会不同 但是基本上保持不变。官方文档中提到对老版本的支持到2.0结束。下面是一些dojo的基础知识。\r\n\r\n1.dojoConfig 对象。\r\n\r\ndojoConfig对象用于配置当前 dojo库的行为。举例说明如下在html页面中添加下面的代码\r\n\r\n&lt;script&gt;\r\nvar dojoConfig = {\r\nisDebug: true,//设置当前dojo模式为调试模式 可以输出错误信息。\r\nparseOnLoad: false, //当页面加载完成前是否对文档进行解析。\r\n};\r\n&lt;/script&gt;\r\n\r\n注意该 对象必须写在 导入dojo库 之前 不然dojo库无法识别该对象 并且在2.0之前该对象有2种 djConfig 和 dojoConfig 2.0以后只支持dojoConfig 以及dojo.query()这种方式不再支持 将使用AMD模式 具体 使用方法参考官方文档http://dojotoolkit.org/documentation/\r\n\r\n2. 模块化\r\n\r\n一般来说一个独立的dojo js文件就是一个模块 模块里面可以是一个widget 也可以是一个类下面是一个列子。这是一个独立的文件app.js 位于 my/目录下  my/app.js\r\n\r\n对于dojo来说默认的整个架构的路径是 以dojo.js文件的上一级目录为根目录的 所有的外部js文件都以它为基准进行查找 如下。（下面的目录结构是代码列出的文件结构目录 后面不在列出）\r\n\r\nwebcontent/index.htm\r\nwebcontent/css\r\nwebcontent/js/dojo1.6/dojo/dojo.js\r\nwebcontent/js/dojo1.6/dojox\r\nwebcontent/js/dojo1.6/dijit\r\nwebcontent/js/dojo1.6/my/app.js\r\nwebcontent/js/dojo1.6/third/data.js\r\nwebcontent/js/dojo1.6/demo/templates/SomeWidget.html\r\n\r\ndojo.provide(\"my.App\");//一个简单的包含包前缀的类 my.App\r\nmy.App.name =\"my app name\";\r\nmy.App.hello = function (){//do some thing\r\n}\r\n\r\n在html里可以这样引用进来 注意my.App不需要执行new 初始化命令 dojo.provide(\"my.App\")就已经定义了该对象my.App因此可以直接使用\r\n&lt;script&gt;\r\ndojo.require(\"my.app\");//引入my/app.js\r\nmy.App.hello();\r\n&lt;/script&gt;\r\n\r\n--------分隔符 另外一种声明的方式来创建类\r\n\r\n-----data.js\r\ndojo.declare(\"third.Data\",null,{\r\nusername:\"jeff\",// declare 命令 (\"包含命名空间的类\",继承的类[dijit.form.button,dijit.form.text],{类属性以及方法})\r\npassword:\"gigi117\",\r\nhello:function(){\r\nalert(\"yes\");\r\n},\r\ngetD:function() {\r\nreturn this.password;}\r\n});\r\n\r\n----index.html\r\n&lt;script&gt;\r\ndojo.require(\"third.data\");\r\nvar td = new third.Data();//因为是声明方式所以需要初始化\r\ntd.getD();\r\n&lt;/script&gt;\r\n\r\n3.-----------自定义模块 自定义的widget\r\n\r\n由于这种结构很容易实现 自定义的widget 也就是采用declare的继承方式。\r\n\r\n定义模板\r\n\r\n---  SomeWidget.html\r\n\r\n&lt;div&gt;\r\n&lt;div data-dojo-attach-point=\"titleNode\" data-dojo-attach-event=\"ondijitclick:onClick\"&gt;&lt;/div&gt;\r\n&lt;div&gt;And our container:&lt;/div&gt;\r\n&lt;div data-dojo-attach-point=\"containerNode\"&gt;&lt;/div&gt;\r\n&lt;/div&gt;\r\n\r\n-----index.html 嵌入js\r\n\r\n&lt;script&gt;\r\ndojo.require(\"dijit._Widget\");//创建widget必须引入\r\ndojo.require(\"dijit._Templated\");//创建widget必须引入 ，因为需要继承\r\n\r\n// To keep the example simple, we\'re declaring our widget inline and then manually parsing.\r\n// Future tutorials will explain how to properly separate this out into its own file.\r\ndojo.ready(function(){\r\n// Declare our widget 继承 _Widget, _Templated\r\ndojo.declare(\"demo.SomeWidget\", [ dijit._Widget, dijit._Templated ], {\r\n// get our template\r\ntemplateString: dojo.cache(\"demo\", \"templates/SomeWidget.html\"),//注意这里的目录结构 在前面有说明\r\n\r\n// some properties\r\nbaseClass: \"someWidgetBase\",\r\ntitle: \"\", // we\'ll set this from the widget def\r\n\r\n// hidden counter\r\n_counter: 1,\r\n_firstClicked: false,\r\n\r\n// define an onClick handler\r\nonClick: function(){\r\nif(this._firstClicked){\r\nthis.titleNode.innerHTML =this.title + \" was clicked \" + (++this._counter) + \" times.\";\r\n} else {\r\nthis.titleNode.innerHTML = this.title + \" was clicked!\";\r\nthis._firstClicked = true;\r\n}\r\n},\r\n\r\npostCreate: function(){\r\nthis.titleNode.innerHTML = this.title;\r\n}\r\n});\r\n\r\n// Now we can parse\r\ndojo.parser.parse();\r\n}); // end dojo.ready\r\n&lt;/script&gt;\r\n\r\n&nbsp;\r\n\r\n-------在index.html里放入模板\r\n\r\n&lt;div data-dojo-type=\"demo.SomeWidget\" data-dojo-props=\"title:\'Our Some Widget\'\"&gt;//放置该widget\r\n&lt;div&gt;Don\'t forget to click on the title!&lt;/div&gt;\r\n&lt;p&gt;This is arbitrary content!&lt;/p&gt;\r\n&lt;button data-dojo-type=\"dijit.form.Button\"&gt;My Button&lt;/button&gt;\r\n&lt;p&gt;More arbitrary content!&lt;/p&gt;\r\n&lt;/div&gt;\r\n\r\n这里只是简要的说明了通过模块化以及decalre声明以及继承的方式创建 自定义的模块 更多细节需要参考官方文档','Dojo toolkit info','','inherit','open','open','','128-revision-v1','','','2013-08-23 14:06:28','2013-08-23 06:06:28','',128,'http://localhost/wordpress-new/?p=129',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (131,1,'2013-08-23 14:25:04','2013-08-23 06:25:04','“drupal7 导入翻译出错 An AJAX HTTP error occurred\r\n\r\n解决方法\r\n\r\n打开\\sites\\default\\settings.php文件，在最后增加以下两行：\r\n\r\nini_set(\'memory_limit\', \'1280M\'); //加大php的内存 也可以在php.ini中设置\r\nini_set(\'max_execution_time\', 200); //加大页面执行时间 php.ini中的默认值是30 (秒)”\r\n\r\n也有的人说即使改成3600秒也还是出错，我也发现我怎么改这个值都不行。\r\n\r\n我本地安装的是xampp最新版，运行平台是win7 64和win2008 R2，曾经查询修改mysql进程时间设定有效过。\r\n\r\n现在发现问题根结所在（也可能是我个例，但如果你碰到了一样的问题，而你的数据库默认引擎也是innodb，那就很有可能是这个原因）。\r\n\r\n最新版的xampp安装好之后，mysql默认引擎为Innodb，而且Innodb设置参数的innodb_flush_log_at_trx_commit 值是1。这个值可以取0,1,2，1是最安全的，即使系统完全崩溃也能找回前一秒钟的数据，但也是性能最低的，每秒都要向硬盘写日志数据。设为2是比较适中的。有关Innodb引擎更多优化请查询百度。\r\n\r\n（mysql引擎设定可以在phpmyadmin的【引擎】链接或【更多】-【引擎】里查看，一般默认不是Myisam就是innoDB，点击这两个名字进去就可以查看具体参数设定及是否为默认引擎。如果你的引擎默认是InnoDB就很有优化的必要。设定参数在mysql\\bin\\my.ini 文件中）\r\n\r\n其实就是innodb_flush_log_at_trx_commit 设为1 的问题，只要mysql\\bin\\my.ini中的innodb_flush_log_at_trx_commit = 2 重启mysql进程就可以了。(只读不能改请先停止mysql，或另存-删除原文件-改名) 再安装时导入翻译时间就是几秒钟的速度~~！','drupal7安装时出错 导入翻译出错 的新原因及解决办法 An AJAX HTTP error occurred','','publish','open','open','','drupal7%e5%ae%89%e8%a3%85%e6%97%b6%e5%87%ba%e9%94%99-%e5%af%bc%e5%85%a5%e7%bf%bb%e8%af%91%e5%87%ba%e9%94%99-%e7%9a%84%e6%96%b0%e5%8e%9f%e5%9b%a0%e5%8f%8a%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95-an-ajax-ht','','','2013-08-23 14:25:04','2013-08-23 06:25:04','',0,'http://localhost/wordpress/?p=131',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (132,1,'2013-08-23 14:25:04','2013-08-23 06:25:04','“drupal7 导入翻译出错 An AJAX HTTP error occurred\r\n\r\n解决方法\r\n\r\n打开\\sites\\default\\settings.php文件，在最后增加以下两行：\r\n\r\nini_set(\'memory_limit\', \'1280M\'); //加大php的内存 也可以在php.ini中设置\r\nini_set(\'max_execution_time\', 200); //加大页面执行时间 php.ini中的默认值是30 (秒)”\r\n\r\n也有的人说即使改成3600秒也还是出错，我也发现我怎么改这个值都不行。\r\n\r\n我本地安装的是xampp最新版，运行平台是win7 64和win2008 R2，曾经查询修改mysql进程时间设定有效过。\r\n\r\n现在发现问题根结所在（也可能是我个例，但如果你碰到了一样的问题，而你的数据库默认引擎也是innodb，那就很有可能是这个原因）。\r\n\r\n最新版的xampp安装好之后，mysql默认引擎为Innodb，而且Innodb设置参数的innodb_flush_log_at_trx_commit 值是1。这个值可以取0,1,2，1是最安全的，即使系统完全崩溃也能找回前一秒钟的数据，但也是性能最低的，每秒都要向硬盘写日志数据。设为2是比较适中的。有关Innodb引擎更多优化请查询百度。\r\n\r\n（mysql引擎设定可以在phpmyadmin的【引擎】链接或【更多】-【引擎】里查看，一般默认不是Myisam就是innoDB，点击这两个名字进去就可以查看具体参数设定及是否为默认引擎。如果你的引擎默认是InnoDB就很有优化的必要。设定参数在mysql\\bin\\my.ini 文件中）\r\n\r\n其实就是innodb_flush_log_at_trx_commit 设为1 的问题，只要mysql\\bin\\my.ini中的innodb_flush_log_at_trx_commit = 2 重启mysql进程就可以了。(只读不能改请先停止mysql，或另存-删除原文件-改名) 再安装时导入翻译时间就是几秒钟的速度~~！','drupal7安装时出错 导入翻译出错 的新原因及解决办法 An AJAX HTTP error occurred','','inherit','open','open','','131-revision-v1','','','2013-08-23 14:25:04','2013-08-23 06:25:04','',131,'http://localhost/wordpress/?p=132',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (133,1,'2013-08-23 14:27:22','2013-08-23 06:27:22','在Javascript脚本里，一个cookie 实际就是一个字符串属性。当你读取cookie的值时，就得到一个字符串，里面当前WEB页使用的所有cookies的名称和值。每个cookie除了 name名称和value值这两个属性以外，还有四个属性。这些属性是： expires过期时间、 path路径、 domain域、以及 secure安全。\r\n\r\nExpires – 过期时间。指定cookie的生命期。具体是值是过期日期。如果想让cookie的存在期限超过当前浏览器会话时间，就必须使用这个属性。当过了到期日期时，浏览器就可以删除cookie文件，没有任何影响。\r\n\r\nPath – 路径。指定与cookie关联的WEB页。值可以是一个目录，或者是一个路径。如果http://www.zdnet.com/devhead /index.html 建立了一个cookie，那么在http://www.zdnet.com/devhead/目录里的所有页面，以及该目录下面任何子目录里的页面都可以 访问这个cookie。这就是说，在http://www.zdnet.com/devhead/stories/articles 里的任何页面都可以访问http://www.zdnet.com/devhead/index.html建立的cookie。但是，如果http: //www.zdnet.com/zdnn/ 需要访问http://www.zdnet.com/devhead/index.html设置的cookes，该怎么办？这时，我们要把cookies 的path属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享cookies。现在看另一个例子： 如果想让 http://www.zdnet.com/devhead/filters/ 和http://www.zdnet.com/devhead/stories/共享cookies，就要把path设成“/devhead”。\r\n\r\nDomain – 域。指定关联的WEB服务器或域。值是域名，比如zdnet.com。这是对path路径属性的一个延伸。如果我们想让 catalog.mycompany.com 能够访问shoppingcart.mycompany.com设置的cookies，该怎么办? 我们可以把domain属性设置成“mycompany.com”，并把path属性设置成“/”。不能把cookies域属性设置成与设置它的服务器的 所在域不同的值。\r\n\r\nSecure – 安全。指定cookie的值通过网络如何在用户和WEB服务器之间传递。这个属性的值或者是“secure”，或者为空。缺省情况下，该属性为空，也就是 使用不安全的HTTP连接传递数据。如果一个 cookie 标记为secure，那么，它与WEB服务器之间就通过HTTPS或者其它安全协议传递数据。不过，设置了secure属性不代表其他人不能看到你机器本 地保存的cookie。换句话说，把cookie设置为secure，只保证cookie与WEB服务器之间的数据传输过程加密，而保存在本地的 cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。\r\n\r\nJS设置Cookie的方法\r\n\r\nfunction setCookie(c_name,value,expiredays) {\r\nvar exdate=new Date();\r\nexdate.setDate(exdate.getDate()+expiredays);\r\ndocument.cookie=c_name+ \"=\" +escape(value)+\r\n((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString())+\";path=/\";\r\n}\r\nfunction getCookie(c_name) {\r\nif (document.cookie.length&gt;0)\r\n{\r\nc_start=document.cookie.indexOf(c_name + \"=\");\r\nif (c_start!=-1)\r\n{\r\nc_start=c_start + c_name.length+1 ;\r\nc_end=document.cookie.indexOf(\";\",c_start);\r\nif (c_end==-1) c_end=document.cookie.length;\r\nreturn unescape(document.cookie.substring(c_start,c_end));\r\n}\r\n}\r\nreturn \"\";\r\n}\r\n\r\n\r\n\r\n\r\n\r\n一、浏览器允许每个域名所包含的 cookie 数：Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie（ color=\"#006da3\"&gt;《Update to Internet Explorer&amp;rsquo;s Cookie Jar》）。Firefox 每个域名 cookie 限制为 50 个。Opera 每个域名 cookie 限制为 30 个。Safari/WebKit 貌似没有 cookie 限制。但是如果 cookie 很多，则会使 header 大小超过服务器的处理的限制，会导致错误发生。注：每个域名 cookie 限制为 20 个将不再正确！二、当很多的 cookie 被设置，浏览器如何去响应。除 （可以设置全部cookie，不管数量多少），有两个方法：最少最近使用（least recently used (LRU)）的方法：当 Cookie 已达到限额，自动踢除最老的 Cookie ，以使给最新的 Cookie 一些空间。 Internet Explorer 和 Opera 使用此方法。Firefox 很独特：虽然最后的设置的 Cookie 始终保留，但似乎随机决定哪些 cookie 被保留。似乎没有任何计划（建议：在 Firefox 中不要超过 Cookie 限制）。三、不同浏览器间 cookie 总大小也不同：Firefox 和 Safari 允许 cookie 多达 4097 个字节, 包括名（name）、值（value）和等号。Opera 允许 cookie 多达 4096 个字节, 包括：名（name）、值（value）和等号。Internet Explorer 允许 cookie 多达 4095 个字节, 包括：名（name）、值（value）和等号。注：多字节字符计算为两个字节。在所有浏览器中，任何 cookie 大小超过限制都被忽略，且永远不会被设置。','  JS设置Cookie,及COOKIE的限制','','publish','open','open','','js%e8%ae%be%e7%bd%aecookie%e5%8f%8acookie%e7%9a%84%e9%99%90%e5%88%b6','','','2013-08-23 14:27:22','2013-08-23 06:27:22','',0,'http://localhost/wordpress/?p=133',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (134,1,'2013-08-23 14:27:22','2013-08-23 06:27:22','在Javascript脚本里，一个cookie 实际就是一个字符串属性。当你读取cookie的值时，就得到一个字符串，里面当前WEB页使用的所有cookies的名称和值。每个cookie除了 name名称和value值这两个属性以外，还有四个属性。这些属性是： expires过期时间、 path路径、 domain域、以及 secure安全。\r\n\r\nExpires – 过期时间。指定cookie的生命期。具体是值是过期日期。如果想让cookie的存在期限超过当前浏览器会话时间，就必须使用这个属性。当过了到期日期时，浏览器就可以删除cookie文件，没有任何影响。\r\n\r\nPath – 路径。指定与cookie关联的WEB页。值可以是一个目录，或者是一个路径。如果http://www.zdnet.com/devhead /index.html 建立了一个cookie，那么在http://www.zdnet.com/devhead/目录里的所有页面，以及该目录下面任何子目录里的页面都可以 访问这个cookie。这就是说，在http://www.zdnet.com/devhead/stories/articles 里的任何页面都可以访问http://www.zdnet.com/devhead/index.html建立的cookie。但是，如果http: //www.zdnet.com/zdnn/ 需要访问http://www.zdnet.com/devhead/index.html设置的cookes，该怎么办？这时，我们要把cookies 的path属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享cookies。现在看另一个例子： 如果想让 http://www.zdnet.com/devhead/filters/ 和http://www.zdnet.com/devhead/stories/共享cookies，就要把path设成“/devhead”。\r\n\r\nDomain – 域。指定关联的WEB服务器或域。值是域名，比如zdnet.com。这是对path路径属性的一个延伸。如果我们想让 catalog.mycompany.com 能够访问shoppingcart.mycompany.com设置的cookies，该怎么办? 我们可以把domain属性设置成“mycompany.com”，并把path属性设置成“/”。不能把cookies域属性设置成与设置它的服务器的 所在域不同的值。\r\n\r\nSecure – 安全。指定cookie的值通过网络如何在用户和WEB服务器之间传递。这个属性的值或者是“secure”，或者为空。缺省情况下，该属性为空，也就是 使用不安全的HTTP连接传递数据。如果一个 cookie 标记为secure，那么，它与WEB服务器之间就通过HTTPS或者其它安全协议传递数据。不过，设置了secure属性不代表其他人不能看到你机器本 地保存的cookie。换句话说，把cookie设置为secure，只保证cookie与WEB服务器之间的数据传输过程加密，而保存在本地的 cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。\r\n\r\nJS设置Cookie的方法\r\n\r\nfunction setCookie(c_name,value,expiredays) {\r\nvar exdate=new Date();\r\nexdate.setDate(exdate.getDate()+expiredays);\r\ndocument.cookie=c_name+ \"=\" +escape(value)+\r\n((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString())+\";path=/\";\r\n}\r\nfunction getCookie(c_name) {\r\nif (document.cookie.length&gt;0)\r\n{\r\nc_start=document.cookie.indexOf(c_name + \"=\");\r\nif (c_start!=-1)\r\n{\r\nc_start=c_start + c_name.length+1 ;\r\nc_end=document.cookie.indexOf(\";\",c_start);\r\nif (c_end==-1) c_end=document.cookie.length;\r\nreturn unescape(document.cookie.substring(c_start,c_end));\r\n}\r\n}\r\nreturn \"\";\r\n}\r\n\r\n\r\n\r\n\r\n\r\n一、浏览器允许每个域名所包含的 cookie 数：Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie（ color=\"#006da3\"&gt;《Update to Internet Explorer&amp;rsquo;s Cookie Jar》）。Firefox 每个域名 cookie 限制为 50 个。Opera 每个域名 cookie 限制为 30 个。Safari/WebKit 貌似没有 cookie 限制。但是如果 cookie 很多，则会使 header 大小超过服务器的处理的限制，会导致错误发生。注：每个域名 cookie 限制为 20 个将不再正确！二、当很多的 cookie 被设置，浏览器如何去响应。除 （可以设置全部cookie，不管数量多少），有两个方法：最少最近使用（least recently used (LRU)）的方法：当 Cookie 已达到限额，自动踢除最老的 Cookie ，以使给最新的 Cookie 一些空间。 Internet Explorer 和 Opera 使用此方法。Firefox 很独特：虽然最后的设置的 Cookie 始终保留，但似乎随机决定哪些 cookie 被保留。似乎没有任何计划（建议：在 Firefox 中不要超过 Cookie 限制）。三、不同浏览器间 cookie 总大小也不同：Firefox 和 Safari 允许 cookie 多达 4097 个字节, 包括名（name）、值（value）和等号。Opera 允许 cookie 多达 4096 个字节, 包括：名（name）、值（value）和等号。Internet Explorer 允许 cookie 多达 4095 个字节, 包括：名（name）、值（value）和等号。注：多字节字符计算为两个字节。在所有浏览器中，任何 cookie 大小超过限制都被忽略，且永远不会被设置。','  JS设置Cookie,及COOKIE的限制','','inherit','open','open','','133-revision-v1','','','2013-08-23 14:27:22','2013-08-23 06:27:22','',133,'http://localhost/wordpress/?p=134',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (135,1,'2013-08-23 14:27:38','2013-08-23 06:27:38','前戏是我的最爱，无论是耳边的呼吸戏语、两腿间的唇舌吸香、还是乳房到脖子间的柔情爱抚……没前戏的性爱多乏味啊。当然，欲火焚身一触即发除外，讲前戏，慢慢来……\r\n\r\n前戏当然强调对身体的技术，但若你希望彼此在性爱中获得最大的满足，对异性情欲激发的挑逗就尤为重要了。通过身体的挑逗激起心理强烈情欲，再通过对情欲的控制使生理的欲望更大化，在身心交替、爱抚调情之后达到大爱。\r\n\r\n我是男性，所以我更多从男性的角度讲自己的感受和经验，但是在运用上男女都差不多，自己体会发挥吧。\r\n\r\n首先投入是首位，假high可耻。，“投入”即全身心的享受性爱，配合对方以及引导对方配合以求交合默契，耐心、有效地交流及引导能使双方放下心理负担全身心投入到如梦幻般忘我即刻当下的欢乐中。\r\n\r\n其次是技术方面的控制能力。“控制”包括温柔的耐心、对敏感部位及周围若近若离的游控、对触技（身、气）的控制、真情表露你的赞美以激发对方的情欲等等。最好在做爱之前洗个澡，用带温和香味的沐浴品，如果是沐浴用品本身的清香最好，也可以适当用些香水，但不宜太浓，清香适宜。女性最好将阴部清洗干净，让阴部有点清香，以便男士更好的为你们舔阴。\r\n\r\n女性的身体反应是比较缓慢的，所以男性要给她一段时间的适应，女性敏感的部位各有不同，也比较多，最好开始的时候搂着她说说情话，例如你真的很性感、让我很有欲望，你很美啊，你某某地方很漂亮之类的，要有眼神交流哦，在谈论过程中尽量引导对方告诉你他（她）的敏感部位，在谈论敏感部位的时候可以用语言引导对方幻想，例如说到脖子或者耳朵的时，问问是耳珠敏感还是耳背敏感，甚或在耳朵周围轻轻亲吻带着呼吸更敏感之类，然后在对方身上尝试刚才说过的话。走题了，我觉得大概的顺序如下面介绍，但是个人以及环境的差异需要您发挥自己的观察力和想象力了。你可以先搂着她，尽可能的贴近身体能通过柔软的肌肤感受到彼此的温度，看着她的眼睛感觉看到内心去，说几句赞美的情话，她身体或部位很诱人，碰到对方身体时的感受，让她心理放松并感觉舒服，然后亲吻她的嘴唇，先是用唇轻轻的触碰对方嘴唇，然后抬头眼神交流，深情对望，她会开始迷离，接着亲吻，要循序渐进，用你的舌头跟对方交流，让双方的舌面接触，适机从嘴部移向颈部，接触颈部的第一下要适度张嘴，像品尝夏天快融化的雪糕顶部，两唇微张舌头触碰肌肤，让自己也感受她颈部的细腻，让她感受到你嘴和舌的温度，这个过程不要只用舌头和嘴，还可以让鼻尖和呼吸也用上，有时候是四点加呼吸轻微移动，上下嘴唇、舌头、鼻尖加轻微呼出的气息。颈部之后移向耳珠、耳背、耳面、耳边，轻轻的用牙和舌头刺激耳朵，然后再往颈部、乳房，乳房停留的时间可以稍微长点，乳房、乳头和胸背间都是敏感区域，亲吻乳房可以从锁骨开始，不要一下就到乳头，用上舌头在乳房和胸背间游控，接近乳头，然后轻轻的突然的由上至下的刷一下乳头，一口含住吸住同时用舌头搅动，适当的控制力度，要温柔对待这个敏感的地方，然后是小腹和腰部，方法大致相同，这个时候对方已经要注意的是，在小腹部分不要着急往下，有些女性比较害羞，不习惯阴部展露在男士面前，所以，在亲女性阴部的时候要尽量耐心，言语上要多加鼓励，排除她的顾及，动作要轻要温柔。将脸轻轻的凑到大腿正面靠近膝盖的位置，从这里开始向大腿内侧轻扫，到大腿根部，停留在阴部周围凹陷部位，再到小腹，再重复几次，然后回到阴部周围，当你觉得对方有点麻麻的控制不住了，可以小心用鼻子或者热乎乎的气息试探她的阴部了，当你觉得她已经很投入并且身体开始控制不住，呼吸急促甚至呻吟，敏感的女性阴道附近应该已经湿润了。\r\n\r\n为女性舔阴（异性口交）是前戏里的重头戏，口活好或者遇到敏感的女性也许就已经帮助她达到高潮了。通过前面的动作，已经让女性克服了害羞的心理，现在她正处于蠢蠢欲动欲拒还迎的状态，这时舔阴就能事半功倍了。\r\n\r\n以下文字我截取几年前一篇《关于女性》文章中的一部分内容给大家，描写的非常详细：\r\n“这时候女性应该主动些，把腿分开成八字形，最好是腿往后仰，把整个阴部展露在男性面前，这点没有什么害羞的，要知道在这种时候你稍为的主动能 为男性提供更大的动力和投入。\r\n\r\n当女性抬高张开腿后，男性要先攻克几个主攻方向的重要据点，这就是女性的会阴、阴唇、阴道口。会阴是在女性阴道与肛门的连接部位，这个部位的皮肤虽然很紧绷，但是极为敏感，要用湿润的舌头轻舔这个部位，亲女性大腿根部时女性会觉得由上自下阴道口部分酸麻，亲会阴位置时女性就会有种由下自上的舒坦的扩张感了。亲女性会阴时，如果你可以克服更大的心理障碍，你可以用突然袭击的方式用舌头贴到女性肛门上舔、触，保证这时候的女性会大呼小叫兴奋无比。如果你有心理障碍，那就由会阴向上一路舔到女性阴唇处。\r\n\r\n这时候的女性相信大多是水如泉涌了，这时候女人的阴水大多是透明，比较稀，如果你喜欢的话，可以把它喝了（不是开玩笑了），女性体内刚分泌出来的，不会脏的了。应该怎么样亲阴唇呢？这时候先不要动手，要用舌头把女性的大阴唇分别向二边撬开（有些女性的大阴唇较小，或较兴奋时，阴唇可能已经自行分开）；含住女性的一片阴唇，用舌头扫动已经含在嘴里的它，阴唇的里外二面都要顾及，然后换一片阴唇，动作依然。最后身体稍侧，自已的嘴唇与女性的阴唇呈平行状态，轻轻地把女性的二片阴唇同时含进嘴里，一起吸住，用舌头从二片阴唇中间做插入抽出横扫动作，那女性会舒服死的。\r\n\r\n上文说到如何亲女性的阴唇，记住了，亲阴唇时要把女性的阴唇尽量吸吮到嘴里，用舌头轻扫轻舔，女性会觉得阴唇部位特别有点痒，她很想你亲得更多位置，亲得更广些，别理她们，你亲你的就行了，因为没有几个女性会说：\"亲爱的，亲我哪里哪里，再亲哪里哪里……\"的。你可以趁着她们正享受着的时候，轻轻的咬一下她的阴唇，肉在你嘴里，咬不咬怎么咬还不是你说了算？但是不要咬太大力了，要恰到好处，可以让她突然间大叫一下，把她刚才积累的感觉基本上破坏掉就行了。\r\n\r\n好端端的为什么要破坏女性的感觉？男性的性兴奋是通过眼睛和性器官的摩擦来达到的，这种直接的刺激可以让男性很快到达高潮，用图表的形式表现出就就是一个珠穆朗玛峰，直上直下。而女性的性兴奋是通过耳朵（听你的甜言蜜语）和脑子（想象和感受）来积累的，性高潮的到达需要多次的刺激和积累而来的。用图表来表示就是云贵高原，一个梯形。\r\n\r\n经过刚才一轮的亲吻，女性已经达到一定的兴奋点，人有点迷糊。太迷糊了不好，因为女人一迷糊她就不知道谁在亲她了，哈哈，开玩笑的了。轻咬她一下，可以把她从迷糊状态中唤醒，在半醉半醒中再接受你继续的刺激会让她下一次的性兴奋来得更快和积累得更多。这一点在为女性舔阴的时候一定要重复使用，但也不要太频繁了，小心给人踢下床，嘿。咬的时候一定要小心，阴唇很嫩的了。\r\n\r\n你一轻咬女性的阴唇，她肯定会\"啊\"的一下惊叫，身子抽动一下，在她还没来得及说话时，你快速把嘴唇整个贴在她的阴道口，这种做法可以让女性一下子感觉到整个阴部很温暖很舒服，刚才的那声\"啊\"还没叫完就变成\"噢\"的一轻呼了。这样可以让女性有种想骂骂不出，想叫又不敢叫的感觉，\r\n好好玩的，呵。\r\n\r\n当你\"攻下\"女性的\"外围据点\"（会阴、阴唇、肛门等）后，可以开始进入\"徐蚌会战\"了，在房中术语中，有将女性的阴道称之为\"蚌（阴唇）\"的，挺形象的，而且，\"蚌\"内的确有\"珍珠（阴蒂）\"了。\r\n上文说到轻咬女性阴唇后快速用嘴唇堵住女性的阴道口，这可以让女性感觉到一阵温暖和舒坦。这时开始应该动手了，你应该用大拇指轻轻的将她的阴唇向二边分开，露出女性的阴道口，用舌头在阴道口周围打转绕圈，时轻时重，时而整个嘴唇贴上，记住别往女性阴道内吹气，这不好玩，而且容易出\r\n事。这时候的女性注意力全部集中在阴道部位，而且阴蒂开始胀大外露（有些女性阴蒂很小不容易外露，遇到这种女性就别瞎找了），如果你还没有亲吻到她的阴蒂的话，她只是觉得胀而已，应该不会有太大的感觉。这时候你可以稍为停下不亲阴道口，而是用湿润的舌尖轻轻撩几下她的阴蒂，把她的 感觉从阴蒂里撩拨起来，女性会轻叫几下，然后你再回去亲她的阴道口和阴唇，这时的女生的阴蒂刚受过刺激，会处于很渴望你再亲她阴蒂的状态，记住了，无论如何，也不要在这时候再亲她的阴蒂，要让女性半吊在那种感觉里，而且男性要开始从女性的会阴处向阴蒂方向往上轻舔，慢点，舌头到达\r\n阴道口时左右拨动，把阴唇一边拨开一边向上继续舔，一点点向阴蒂部位接近。这时女性心里应该在告诉自已\"到了，快亲到了，快点，快点含住它\"，别管女性怎么叫怎么拉你，就是偏不要亲到阴蒂那，差不多到的时候你用舌尖轻轻的，越轻越好，只是在她的阴蒂上轻扫轻点一下（舌头要含点口水），随即反方向按上述亲法朝阴道口部位舔去。这样会把女性给急死的，她一急，自然就兴奋了。\r\n\r\n亲阴道口时，舌头长的男性可以尝试把舌头插入女性的阴道内搅动，随便你怎么搅动，只要你搅得动就行。女性很受用这招的，只是男性要小心自己的舌根，伸得太长可是会弄伤的了。舌头宽厚的男性（象我这样了，好可怜）虽然只能插进一小段，不过可以把舌头卷起来插入，虽然插入得不多，但可 以让女性觉得很胀。而且宽厚的舌头由阴道口自下往上扫动的感觉可是舌头细长的男性无法给于女性的感觉了，舌头细长的男性可以用舌尖轻挑女性的阴唇中缝，也很舒服的，各有千秋。\r\n\r\n现在开始可以集中精力夺取\"珍珠\"了，请把舌头上移至女性的阴蒂处，集中精力。很多男性可能以为只需要用舌头拼命舔女性的阴蒂就可以让女性到高潮，这有点错误，女性的阴蒂是非常敏感的，如果你太大力舔动，她的痛感多过快感，就没意思了。亲吻阴蒂要注意几点，舌头一定要湿、轻、尖， 一定要保持舌头湿润（在第一章中准备的水现在用得上了），亲舔阴蒂时一定要轻，要用舌尖来舔。\r\n\r\n进攻阴蒂要用\"点、挑、拨、压、搅\"五字诀，点是指用舌尖轻点轻触女性的阴蒂顶端，挑是指舌头从阴蒂下面向上挑动；拨是用舌头左右拨动女性的阴蒂；压是时不时用舌头压女性的阴蒂，把它稍为压下即可；搅是当你含住女性的阴蒂时用舌头在阴蒂四周搅动。\r\n\r\n这时候开始你要掌握好女性的反应，因为这时的女性已经十分投入和兴奋了，你可以感觉到她们的阴蒂下似乎有点筋会在跳动，这在你含着女性的阴蒂时感觉非常明显。不要随便中断女性的感觉，动作要平均，因为你突然而快节奏的动作很容易让女性到达高潮。男性在做爱时，总是希望久一些，晚点射精，这样可以更舒服些。这时的女性和男性一样，都是希望这种异常舒服的感觉持久些，所以一定要体谅女性的这种感觉，除非对方强烈要求你\"给\"她，或者亲吻时间过长你的舌头发麻了，才采用快节奏使对方达到高潮。\r\n\r\n有一个很管用的技巧，不要学成人片中男主角那种乱舔乱舔的舔阴方式，也不要老是按上述的方法亲吻女性的阴蒂，这些动作做得差不多，觉得可以给对方高潮时，应该用整个嘴唇含住女性的阴蒂部位，上嘴唇压在阴蒂上方的阴毛根部，下嘴唇左右分开女生的阴唇，尽量贴近阴道口（看你的嘴唇大不大罗，嘻嘻），用口含住女性的阴蒂（留点空间），让女性觉得她的阴蒂是飘浮在你的嘴里的；用五字诀发动进攻。男性为女性舔阴最有意义的时刻就是这了。因为你可以通过你的口唇舌控制对方的兴奋程度和控制对方高潮，通常我都是舔上一轮，让对方猛的一阵抽搐，看着她快到时，轻轻一放，离开她的阴蒂，把她气得大喊大叫，或者一离开，看着她要叫喊的时候，马上含上去，她一舒服又喊不出了，当你看到自己可以控制女性的情绪时是多么自豪啊，不过千万别玩太过份喔，会让对方踢下床的。\r\n\r\n含着女性的阴蒂舔动时，可以一边舔一边用手挠她的阴毛，很舒服的了；也可以用手指轻撩她的肛门；或用手指轻轻插入她的阴道内搅动；也可以用双手伸上去抓她的双乳，这些都是可以让女性加倍舒服的动作了，军事上叫\"围点打援\"。\r\n\r\n这个时候你向女性提什么要求，她都会答应的了，如果她不答应，你就停止这些动作，她一急，肯定答应，当然要看你的要求过不过份了。我通常都会要求她给我\"走后门\"，没一次会答应的:((你可以让她求你给她高潮，嘻嘻，看着她娇声娇气求你快点给她，你会觉得你好有征服感的了。然后你就一边晃光晃脑一边用舌头飞快舔动，女性的大腿会越夹越紧（女性们注意了，如果你的男友第二天告诉你脖子疼，就是你夹的了，哼），然后一个强烈抽搐动作，然后身子就放松下来了。如果你有心呢，你就含住她的阴蒂别动，只是含着，吸着她的阴蒂，但是不要用舌头做任何动作，也不要碰到阴蒂，因为这时候女性的阴蒂充血肿涨得很，高潮的时候异常敏感，这时你要碰到它，女性就会\"舒服\"得很\"痛苦\"了。除非你想狠狠的\"修理\"一下她，那你就继续舔下去，看她左躲右避的开心一阵吧。\r\n\r\n女性高潮可以持续很久的，十几秒到几十秒吧，她们会躺在床上一动不动甚至全身抽搐。这时候你该干嘛就干嘛去吧，比如擦汗喝水之类的，因为这时候的女性已经是高潮白痴了，脑子里除了极端兴奋的感觉外，不会有你存在的空间了。等你\"走\"一圈回来，她也就刚缓过劲而已。女性舔阴高潮过后，非常渴望有类似茄子的物体即时插入她的阴道的，这就不用教了吧？要知道这年头茄子是靠不住的了，还得靠你自己。如果你是因为过于集中精力为女方舔阴而\"软\"了，可以请女性即时为你口交一会，待\"重振雄风\"后，随即转入另一阵地作战了。\r\n\r\n并不是每一个女孩都适合舔阴的，因为有些女孩可能因为内分泌分调的原因，分泌物较多，体味较重，就算是清洗干净，但阴部还是会很大味道的，这就很难让男性接受了，换上我我也不愿意的了，有这个特征的女性就要多多谅解了。\r\n\r\n另外在女性来例假的前几天也不要舔阴了，因为女性来例假时，通常白带都会增多，这时候为女性舔阴的话，阴水中掺有白带，不太卫生了。\r\n\r\n舔阴时可以放点音乐，跟着音乐的节奏亲吻女性，而且要暗示她你为她舔阴的节奏是来自音乐，让她一边听音乐一边感受你的亲吻，会让她感觉到很浪漫和舒服的。选一些节奏感明显的音乐试试，看看哪首比较合适你亲吻的频率。我个人推荐就是古筝\"平沙落雁\"、琵琶\"十面埋伏\"、吉它\"加洲旅馆\"，千万别放\"二泉印月\"，那么凄凉的音乐，什么气氛都给破坏了。\r\n\r\n无论男女，舔阴都需要练习的，一次生二次熟三次就……没词了。需要的只是你感情的投入，不要以为舔阴会没面子了，应该知道舔阴也可以得到很大的征服感了。\r\n\r\n另一方面讲，男性需要征服感，女性也需要征服感呀，这样她们才能更投入更主动更配合去和你做爱的。男人的征服感还怕不够吗？帮女性舔阴，既可以显示男人的风度，又可以给于女生满足感和征服感，何苦而不为呢？\r\n\r\n如果你想向你的女友表现更多的爱心，给于更多的尊重和平等，而且你又能过得了大男人主义的关口的话，可以变换一下体位，也就是这里所说的\"加强版\"了。\r\n\r\n开始时让女性躺在床上，按基本版进行舔阴，大概各部位刺激过后，男性躺在床上，用枕头垫高自己的头部，让女性\"骑\"在你的头上（嘻嘻，这可是真正的骑在男性的头上作威作福了），男性脸朝上为女性舔阴，这种方式女性可以比较主动调整受刺激部位，男性比较累了，轻常要抬头追吻，脖子会很酸的。\r\n\r\n但这种舔阴方式对于女性的刺激和满足感来说，绝对比躺在床上要强几倍。请站在女性的角度想想，自己的胯下竟然躺着一个自己喜爱的男人，广义来说就是一个男人被自己骑在胯下，在为自己舔阴，那是一种多么刺激多么满足多么有征服感的事啊。\r\n\r\n男性会觉得兴奋中的女性的阴水流满你的下巴，甚至整个脖子有嘴角。舔阴中你可以尝试用鼻尖或胡子轻轻摩擦女性，会有另类的刺激的。 ”\r\n\r\n上面的技巧说的已经够详细了，大家在尝试的同时尽可能仔细观察异性的表现，以便做些适合彼此的调整，发挥个人的想象力，切记要投入，要尊重体贴对方。\r\n\r\n祝愿意提高性爱质量的你成功，玩的开心。','怎么做好前戏？','','publish','open','open','','%e6%80%8e%e4%b9%88%e5%81%9a%e5%a5%bd%e5%89%8d%e6%88%8f%ef%bc%9f','','','2013-08-23 14:27:38','2013-08-23 06:27:38','',0,'http://localhost/wordpress/?p=135',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (136,1,'2013-08-23 14:27:38','2013-08-23 06:27:38','前戏是我的最爱，无论是耳边的呼吸戏语、两腿间的唇舌吸香、还是乳房到脖子间的柔情爱抚……没前戏的性爱多乏味啊。当然，欲火焚身一触即发除外，讲前戏，慢慢来……\r\n\r\n前戏当然强调对身体的技术，但若你希望彼此在性爱中获得最大的满足，对异性情欲激发的挑逗就尤为重要了。通过身体的挑逗激起心理强烈情欲，再通过对情欲的控制使生理的欲望更大化，在身心交替、爱抚调情之后达到大爱。\r\n\r\n我是男性，所以我更多从男性的角度讲自己的感受和经验，但是在运用上男女都差不多，自己体会发挥吧。\r\n\r\n首先投入是首位，假high可耻。，“投入”即全身心的享受性爱，配合对方以及引导对方配合以求交合默契，耐心、有效地交流及引导能使双方放下心理负担全身心投入到如梦幻般忘我即刻当下的欢乐中。\r\n\r\n其次是技术方面的控制能力。“控制”包括温柔的耐心、对敏感部位及周围若近若离的游控、对触技（身、气）的控制、真情表露你的赞美以激发对方的情欲等等。最好在做爱之前洗个澡，用带温和香味的沐浴品，如果是沐浴用品本身的清香最好，也可以适当用些香水，但不宜太浓，清香适宜。女性最好将阴部清洗干净，让阴部有点清香，以便男士更好的为你们舔阴。\r\n\r\n女性的身体反应是比较缓慢的，所以男性要给她一段时间的适应，女性敏感的部位各有不同，也比较多，最好开始的时候搂着她说说情话，例如你真的很性感、让我很有欲望，你很美啊，你某某地方很漂亮之类的，要有眼神交流哦，在谈论过程中尽量引导对方告诉你他（她）的敏感部位，在谈论敏感部位的时候可以用语言引导对方幻想，例如说到脖子或者耳朵的时，问问是耳珠敏感还是耳背敏感，甚或在耳朵周围轻轻亲吻带着呼吸更敏感之类，然后在对方身上尝试刚才说过的话。走题了，我觉得大概的顺序如下面介绍，但是个人以及环境的差异需要您发挥自己的观察力和想象力了。你可以先搂着她，尽可能的贴近身体能通过柔软的肌肤感受到彼此的温度，看着她的眼睛感觉看到内心去，说几句赞美的情话，她身体或部位很诱人，碰到对方身体时的感受，让她心理放松并感觉舒服，然后亲吻她的嘴唇，先是用唇轻轻的触碰对方嘴唇，然后抬头眼神交流，深情对望，她会开始迷离，接着亲吻，要循序渐进，用你的舌头跟对方交流，让双方的舌面接触，适机从嘴部移向颈部，接触颈部的第一下要适度张嘴，像品尝夏天快融化的雪糕顶部，两唇微张舌头触碰肌肤，让自己也感受她颈部的细腻，让她感受到你嘴和舌的温度，这个过程不要只用舌头和嘴，还可以让鼻尖和呼吸也用上，有时候是四点加呼吸轻微移动，上下嘴唇、舌头、鼻尖加轻微呼出的气息。颈部之后移向耳珠、耳背、耳面、耳边，轻轻的用牙和舌头刺激耳朵，然后再往颈部、乳房，乳房停留的时间可以稍微长点，乳房、乳头和胸背间都是敏感区域，亲吻乳房可以从锁骨开始，不要一下就到乳头，用上舌头在乳房和胸背间游控，接近乳头，然后轻轻的突然的由上至下的刷一下乳头，一口含住吸住同时用舌头搅动，适当的控制力度，要温柔对待这个敏感的地方，然后是小腹和腰部，方法大致相同，这个时候对方已经要注意的是，在小腹部分不要着急往下，有些女性比较害羞，不习惯阴部展露在男士面前，所以，在亲女性阴部的时候要尽量耐心，言语上要多加鼓励，排除她的顾及，动作要轻要温柔。将脸轻轻的凑到大腿正面靠近膝盖的位置，从这里开始向大腿内侧轻扫，到大腿根部，停留在阴部周围凹陷部位，再到小腹，再重复几次，然后回到阴部周围，当你觉得对方有点麻麻的控制不住了，可以小心用鼻子或者热乎乎的气息试探她的阴部了，当你觉得她已经很投入并且身体开始控制不住，呼吸急促甚至呻吟，敏感的女性阴道附近应该已经湿润了。\r\n\r\n为女性舔阴（异性口交）是前戏里的重头戏，口活好或者遇到敏感的女性也许就已经帮助她达到高潮了。通过前面的动作，已经让女性克服了害羞的心理，现在她正处于蠢蠢欲动欲拒还迎的状态，这时舔阴就能事半功倍了。\r\n\r\n以下文字我截取几年前一篇《关于女性》文章中的一部分内容给大家，描写的非常详细：\r\n“这时候女性应该主动些，把腿分开成八字形，最好是腿往后仰，把整个阴部展露在男性面前，这点没有什么害羞的，要知道在这种时候你稍为的主动能 为男性提供更大的动力和投入。\r\n\r\n当女性抬高张开腿后，男性要先攻克几个主攻方向的重要据点，这就是女性的会阴、阴唇、阴道口。会阴是在女性阴道与肛门的连接部位，这个部位的皮肤虽然很紧绷，但是极为敏感，要用湿润的舌头轻舔这个部位，亲女性大腿根部时女性会觉得由上自下阴道口部分酸麻，亲会阴位置时女性就会有种由下自上的舒坦的扩张感了。亲女性会阴时，如果你可以克服更大的心理障碍，你可以用突然袭击的方式用舌头贴到女性肛门上舔、触，保证这时候的女性会大呼小叫兴奋无比。如果你有心理障碍，那就由会阴向上一路舔到女性阴唇处。\r\n\r\n这时候的女性相信大多是水如泉涌了，这时候女人的阴水大多是透明，比较稀，如果你喜欢的话，可以把它喝了（不是开玩笑了），女性体内刚分泌出来的，不会脏的了。应该怎么样亲阴唇呢？这时候先不要动手，要用舌头把女性的大阴唇分别向二边撬开（有些女性的大阴唇较小，或较兴奋时，阴唇可能已经自行分开）；含住女性的一片阴唇，用舌头扫动已经含在嘴里的它，阴唇的里外二面都要顾及，然后换一片阴唇，动作依然。最后身体稍侧，自已的嘴唇与女性的阴唇呈平行状态，轻轻地把女性的二片阴唇同时含进嘴里，一起吸住，用舌头从二片阴唇中间做插入抽出横扫动作，那女性会舒服死的。\r\n\r\n上文说到如何亲女性的阴唇，记住了，亲阴唇时要把女性的阴唇尽量吸吮到嘴里，用舌头轻扫轻舔，女性会觉得阴唇部位特别有点痒，她很想你亲得更多位置，亲得更广些，别理她们，你亲你的就行了，因为没有几个女性会说：\"亲爱的，亲我哪里哪里，再亲哪里哪里……\"的。你可以趁着她们正享受着的时候，轻轻的咬一下她的阴唇，肉在你嘴里，咬不咬怎么咬还不是你说了算？但是不要咬太大力了，要恰到好处，可以让她突然间大叫一下，把她刚才积累的感觉基本上破坏掉就行了。\r\n\r\n好端端的为什么要破坏女性的感觉？男性的性兴奋是通过眼睛和性器官的摩擦来达到的，这种直接的刺激可以让男性很快到达高潮，用图表的形式表现出就就是一个珠穆朗玛峰，直上直下。而女性的性兴奋是通过耳朵（听你的甜言蜜语）和脑子（想象和感受）来积累的，性高潮的到达需要多次的刺激和积累而来的。用图表来表示就是云贵高原，一个梯形。\r\n\r\n经过刚才一轮的亲吻，女性已经达到一定的兴奋点，人有点迷糊。太迷糊了不好，因为女人一迷糊她就不知道谁在亲她了，哈哈，开玩笑的了。轻咬她一下，可以把她从迷糊状态中唤醒，在半醉半醒中再接受你继续的刺激会让她下一次的性兴奋来得更快和积累得更多。这一点在为女性舔阴的时候一定要重复使用，但也不要太频繁了，小心给人踢下床，嘿。咬的时候一定要小心，阴唇很嫩的了。\r\n\r\n你一轻咬女性的阴唇，她肯定会\"啊\"的一下惊叫，身子抽动一下，在她还没来得及说话时，你快速把嘴唇整个贴在她的阴道口，这种做法可以让女性一下子感觉到整个阴部很温暖很舒服，刚才的那声\"啊\"还没叫完就变成\"噢\"的一轻呼了。这样可以让女性有种想骂骂不出，想叫又不敢叫的感觉，\r\n好好玩的，呵。\r\n\r\n当你\"攻下\"女性的\"外围据点\"（会阴、阴唇、肛门等）后，可以开始进入\"徐蚌会战\"了，在房中术语中，有将女性的阴道称之为\"蚌（阴唇）\"的，挺形象的，而且，\"蚌\"内的确有\"珍珠（阴蒂）\"了。\r\n上文说到轻咬女性阴唇后快速用嘴唇堵住女性的阴道口，这可以让女性感觉到一阵温暖和舒坦。这时开始应该动手了，你应该用大拇指轻轻的将她的阴唇向二边分开，露出女性的阴道口，用舌头在阴道口周围打转绕圈，时轻时重，时而整个嘴唇贴上，记住别往女性阴道内吹气，这不好玩，而且容易出\r\n事。这时候的女性注意力全部集中在阴道部位，而且阴蒂开始胀大外露（有些女性阴蒂很小不容易外露，遇到这种女性就别瞎找了），如果你还没有亲吻到她的阴蒂的话，她只是觉得胀而已，应该不会有太大的感觉。这时候你可以稍为停下不亲阴道口，而是用湿润的舌尖轻轻撩几下她的阴蒂，把她的 感觉从阴蒂里撩拨起来，女性会轻叫几下，然后你再回去亲她的阴道口和阴唇，这时的女生的阴蒂刚受过刺激，会处于很渴望你再亲她阴蒂的状态，记住了，无论如何，也不要在这时候再亲她的阴蒂，要让女性半吊在那种感觉里，而且男性要开始从女性的会阴处向阴蒂方向往上轻舔，慢点，舌头到达\r\n阴道口时左右拨动，把阴唇一边拨开一边向上继续舔，一点点向阴蒂部位接近。这时女性心里应该在告诉自已\"到了，快亲到了，快点，快点含住它\"，别管女性怎么叫怎么拉你，就是偏不要亲到阴蒂那，差不多到的时候你用舌尖轻轻的，越轻越好，只是在她的阴蒂上轻扫轻点一下（舌头要含点口水），随即反方向按上述亲法朝阴道口部位舔去。这样会把女性给急死的，她一急，自然就兴奋了。\r\n\r\n亲阴道口时，舌头长的男性可以尝试把舌头插入女性的阴道内搅动，随便你怎么搅动，只要你搅得动就行。女性很受用这招的，只是男性要小心自己的舌根，伸得太长可是会弄伤的了。舌头宽厚的男性（象我这样了，好可怜）虽然只能插进一小段，不过可以把舌头卷起来插入，虽然插入得不多，但可 以让女性觉得很胀。而且宽厚的舌头由阴道口自下往上扫动的感觉可是舌头细长的男性无法给于女性的感觉了，舌头细长的男性可以用舌尖轻挑女性的阴唇中缝，也很舒服的，各有千秋。\r\n\r\n现在开始可以集中精力夺取\"珍珠\"了，请把舌头上移至女性的阴蒂处，集中精力。很多男性可能以为只需要用舌头拼命舔女性的阴蒂就可以让女性到高潮，这有点错误，女性的阴蒂是非常敏感的，如果你太大力舔动，她的痛感多过快感，就没意思了。亲吻阴蒂要注意几点，舌头一定要湿、轻、尖， 一定要保持舌头湿润（在第一章中准备的水现在用得上了），亲舔阴蒂时一定要轻，要用舌尖来舔。\r\n\r\n进攻阴蒂要用\"点、挑、拨、压、搅\"五字诀，点是指用舌尖轻点轻触女性的阴蒂顶端，挑是指舌头从阴蒂下面向上挑动；拨是用舌头左右拨动女性的阴蒂；压是时不时用舌头压女性的阴蒂，把它稍为压下即可；搅是当你含住女性的阴蒂时用舌头在阴蒂四周搅动。\r\n\r\n这时候开始你要掌握好女性的反应，因为这时的女性已经十分投入和兴奋了，你可以感觉到她们的阴蒂下似乎有点筋会在跳动，这在你含着女性的阴蒂时感觉非常明显。不要随便中断女性的感觉，动作要平均，因为你突然而快节奏的动作很容易让女性到达高潮。男性在做爱时，总是希望久一些，晚点射精，这样可以更舒服些。这时的女性和男性一样，都是希望这种异常舒服的感觉持久些，所以一定要体谅女性的这种感觉，除非对方强烈要求你\"给\"她，或者亲吻时间过长你的舌头发麻了，才采用快节奏使对方达到高潮。\r\n\r\n有一个很管用的技巧，不要学成人片中男主角那种乱舔乱舔的舔阴方式，也不要老是按上述的方法亲吻女性的阴蒂，这些动作做得差不多，觉得可以给对方高潮时，应该用整个嘴唇含住女性的阴蒂部位，上嘴唇压在阴蒂上方的阴毛根部，下嘴唇左右分开女生的阴唇，尽量贴近阴道口（看你的嘴唇大不大罗，嘻嘻），用口含住女性的阴蒂（留点空间），让女性觉得她的阴蒂是飘浮在你的嘴里的；用五字诀发动进攻。男性为女性舔阴最有意义的时刻就是这了。因为你可以通过你的口唇舌控制对方的兴奋程度和控制对方高潮，通常我都是舔上一轮，让对方猛的一阵抽搐，看着她快到时，轻轻一放，离开她的阴蒂，把她气得大喊大叫，或者一离开，看着她要叫喊的时候，马上含上去，她一舒服又喊不出了，当你看到自己可以控制女性的情绪时是多么自豪啊，不过千万别玩太过份喔，会让对方踢下床的。\r\n\r\n含着女性的阴蒂舔动时，可以一边舔一边用手挠她的阴毛，很舒服的了；也可以用手指轻撩她的肛门；或用手指轻轻插入她的阴道内搅动；也可以用双手伸上去抓她的双乳，这些都是可以让女性加倍舒服的动作了，军事上叫\"围点打援\"。\r\n\r\n这个时候你向女性提什么要求，她都会答应的了，如果她不答应，你就停止这些动作，她一急，肯定答应，当然要看你的要求过不过份了。我通常都会要求她给我\"走后门\"，没一次会答应的:((你可以让她求你给她高潮，嘻嘻，看着她娇声娇气求你快点给她，你会觉得你好有征服感的了。然后你就一边晃光晃脑一边用舌头飞快舔动，女性的大腿会越夹越紧（女性们注意了，如果你的男友第二天告诉你脖子疼，就是你夹的了，哼），然后一个强烈抽搐动作，然后身子就放松下来了。如果你有心呢，你就含住她的阴蒂别动，只是含着，吸着她的阴蒂，但是不要用舌头做任何动作，也不要碰到阴蒂，因为这时候女性的阴蒂充血肿涨得很，高潮的时候异常敏感，这时你要碰到它，女性就会\"舒服\"得很\"痛苦\"了。除非你想狠狠的\"修理\"一下她，那你就继续舔下去，看她左躲右避的开心一阵吧。\r\n\r\n女性高潮可以持续很久的，十几秒到几十秒吧，她们会躺在床上一动不动甚至全身抽搐。这时候你该干嘛就干嘛去吧，比如擦汗喝水之类的，因为这时候的女性已经是高潮白痴了，脑子里除了极端兴奋的感觉外，不会有你存在的空间了。等你\"走\"一圈回来，她也就刚缓过劲而已。女性舔阴高潮过后，非常渴望有类似茄子的物体即时插入她的阴道的，这就不用教了吧？要知道这年头茄子是靠不住的了，还得靠你自己。如果你是因为过于集中精力为女方舔阴而\"软\"了，可以请女性即时为你口交一会，待\"重振雄风\"后，随即转入另一阵地作战了。\r\n\r\n并不是每一个女孩都适合舔阴的，因为有些女孩可能因为内分泌分调的原因，分泌物较多，体味较重，就算是清洗干净，但阴部还是会很大味道的，这就很难让男性接受了，换上我我也不愿意的了，有这个特征的女性就要多多谅解了。\r\n\r\n另外在女性来例假的前几天也不要舔阴了，因为女性来例假时，通常白带都会增多，这时候为女性舔阴的话，阴水中掺有白带，不太卫生了。\r\n\r\n舔阴时可以放点音乐，跟着音乐的节奏亲吻女性，而且要暗示她你为她舔阴的节奏是来自音乐，让她一边听音乐一边感受你的亲吻，会让她感觉到很浪漫和舒服的。选一些节奏感明显的音乐试试，看看哪首比较合适你亲吻的频率。我个人推荐就是古筝\"平沙落雁\"、琵琶\"十面埋伏\"、吉它\"加洲旅馆\"，千万别放\"二泉印月\"，那么凄凉的音乐，什么气氛都给破坏了。\r\n\r\n无论男女，舔阴都需要练习的，一次生二次熟三次就……没词了。需要的只是你感情的投入，不要以为舔阴会没面子了，应该知道舔阴也可以得到很大的征服感了。\r\n\r\n另一方面讲，男性需要征服感，女性也需要征服感呀，这样她们才能更投入更主动更配合去和你做爱的。男人的征服感还怕不够吗？帮女性舔阴，既可以显示男人的风度，又可以给于女生满足感和征服感，何苦而不为呢？\r\n\r\n如果你想向你的女友表现更多的爱心，给于更多的尊重和平等，而且你又能过得了大男人主义的关口的话，可以变换一下体位，也就是这里所说的\"加强版\"了。\r\n\r\n开始时让女性躺在床上，按基本版进行舔阴，大概各部位刺激过后，男性躺在床上，用枕头垫高自己的头部，让女性\"骑\"在你的头上（嘻嘻，这可是真正的骑在男性的头上作威作福了），男性脸朝上为女性舔阴，这种方式女性可以比较主动调整受刺激部位，男性比较累了，轻常要抬头追吻，脖子会很酸的。\r\n\r\n但这种舔阴方式对于女性的刺激和满足感来说，绝对比躺在床上要强几倍。请站在女性的角度想想，自己的胯下竟然躺着一个自己喜爱的男人，广义来说就是一个男人被自己骑在胯下，在为自己舔阴，那是一种多么刺激多么满足多么有征服感的事啊。\r\n\r\n男性会觉得兴奋中的女性的阴水流满你的下巴，甚至整个脖子有嘴角。舔阴中你可以尝试用鼻尖或胡子轻轻摩擦女性，会有另类的刺激的。 ”\r\n\r\n上面的技巧说的已经够详细了，大家在尝试的同时尽可能仔细观察异性的表现，以便做些适合彼此的调整，发挥个人的想象力，切记要投入，要尊重体贴对方。\r\n\r\n祝愿意提高性爱质量的你成功，玩的开心。','怎么做好前戏？','','inherit','open','open','','135-revision-v1','','','2013-08-23 14:27:38','2013-08-23 06:27:38','',135,'http://localhost/wordpress/?p=136',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (137,1,'2013-08-23 14:29:06','2013-08-23 06:29:06','在使用源代码安装的时候请确保 安装了c c++编译器 例如 gcc gcc-c++\r\n\r\n1. 编译安装Apache2.4\r\n注意2.4的版本安装方式与2.2不同\r\nRequirements ：APR and APR-Util Perl-Compatible Regular Expressions Library (PCRE) 参考Apache官方文档\r\n安装完 APR APR-Util PCRE 确认删除安装操作系统时自带的apache 俺顺序执行\r\n\r\n安装 apr | apr-Util | pcre\r\n# ./configure --prefix=/usr/local/apr\r\n# make\r\n# make install\r\n\r\n# ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr\r\n# make\r\n# make install\r\n\r\n# ./configure --prefix=/usr/local/pcre\r\n# make\r\n# make install\r\n安装 Apache2.4\r\n# ./configure --prefix=/usr/local/apache2 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-pcre=/usr/local/pcre --enable-so --enable-rewrite\r\n# make\r\n# make install\r\n\r\n./configure -help 可以查看可以扩展的参数等等\r\n\r\n配置开机启动加入配置文件实现自启动\r\n\r\n[root@localhost ~]# cp /usr/local/apache/bin/apachectl /etc/init.d/httpd\r\n\r\n[root@localhost ~]# vim /etc/init.d/httpd\r\n\r\n在#!/bin/sh 下面加上这两行，wq保存退出\r\n\r\n# chkconfig: 345 61 61\r\n# description: Apache\r\n\r\n[root@localhost ~]# chkconfig --add httpd\r\n\r\n[root@localhost ~]# service httpd start\r\n\r\n在编译安装apache后如果还需要安装其他模块则使用apxs工具\r\n进入安装后的apache/bin目录 找到apxs 工具 通过apxs来加载其他的模块 例如加载mod_rewrite模块\r\n进入apache安装目录 例如\r\n/usr/local/apache2/bin ./apxs -i -a -c /httpd-2.4.4/modules/mappers/mod_rewrite.c\r\n该命令可以同时编译和安装mod_rewrite.c模块\r\n并能激活http.conf中的 LoadModule rewrite_module modules/mod_rewrite.so 它会自动取消该模块前的注释#号\r\n之后apache使用rewrite模块只需要\r\n在需要.htaccess的目录中配置.htaccess文件了，如需要用rewrite模块，加入如下：\r\n\r\nRewriteEngine On\r\n对于如何使用apxs工具可以查看 http://httpd.apache.org/docs/2.4/programs/apxs.html 该文档\r\n\r\n2.安装php5.4.17\r\n在编译的配置php阶段 会检查libxml2 以及libxml2-devel 如果已经安装了那么就没有问题如果在configure 阶段检查 发现没有libxml2和libxml2-devel会出错 可以通过yum install libxml2 ,libxml2-devel来安装 gd库的时候注意 libpng libpng-devel gd gd-devel freetype等依赖库\r\n\r\n然后执行命令\r\n./configure --prefix=/opt/php/ --with-apxs2=/opt/apache2/bin/apxs --with-mysql=mysqlnd --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd --enable-soap --enable-mbstring --enable-sockets --with-zlib --with-mcrypt=/usr/local/libmcrypt --with-pear=/opt/php/lib/php --enable-mysqlnd --with-gd\r\n备注: 使用mysqlnd是在oracle收购mysql之后由于libmysql版权问题 php官方开发了自己的原生mysql驱动直接支持mysql只是在底层进行了改变 而不会影响API 接口因此使用上没有影响 性能比传统的libmysql.dll提高了许多.\r\n然后 make &amp; make install\r\n\r\n备注：这里在安装的时候可能会需要提供zlib,libmcrypt等库的支持\r\n例如在加载扩展 --with-mcrypt 的时候需要 libmcrypt的支持 需要下载libmcrypt-2.5.7.tar.gz\r\nftp://mcrypt.hellug.gr/pub/crypto/mcrypt/libmcrypt/libmcrypt-2.5.7.tar.gz\r\n然后安装libmcrypt 到 /usr/local/mcrypt\r\n在配置php时指定目录例如 --with-mcrypt=/usr/local/mcrypt\r\n\r\n安装完后配置apache的http.conf文件以支持php\r\n找到/usr/local/apache2/conf/http.conf\r\n添加如下信息\r\n1.LoadModule php5_module modules/libphp5.so //在安装php配置.configure 时 添加参数 --with-apxs2=/usr/local/apache2/bin/apxs 可以自动装载写入php5模块到 apache2的httpd.conf下\r\n2. &lt;IfModule dir_module&gt; //这里只需要添加 index.php\r\nDirectoryIndex index.html index.php\r\n&lt;/IfModule&gt;\r\n3. AddHandler application/x-httpd-php .php\r\n4.拷贝php源文件中的php-ini.production 到/usr/local/php/lib 下 php-ini 然后根据需要指定 扩展以及其他参数\r\n\r\n添加到PATH目录\r\n修改/etc/profile文件使其永久性生效，并对所有系统用户生效，在文件末尾加上如下两行代码\r\nPATH=$PATH:/opt/apache2/bin:/opt/php/bin\r\nexport PATH\r\n最后：执行 命令source /etc/profile或 执行点命令 ./profile使其修改生效\r\n\r\n3.安装mysql 建议采用RPM来安装 www.mysql.com\r\n下载 MySQL-client-5.6.12-2.linux MySQL-server-5.6.12-2.linux 的RPM版本\r\n并根据需要安装依赖库 RPM安装会自动创建组用户生成随机密码 以及配置到服务器启动\r\n因此可以直接使用 service mysql start 来启动 mysql\r\n然后使用客户端\r\nshell&gt;mysql -u root -p\r\n输入随机密码 /root/.mysql_secret中的随机密码\r\nmysql&gt;set passwrod=password(\'xxxx\');\r\n然后就可以使用了\r\nmysql&gt;show databases\r\n\r\n对于RPM没有自动生成/etc/my.cnf文件 可以在/usr/share/mysql下找到一个 my-xxxx.cnf的配置文件 在mysql-server-5.6.12里是\r\nmy-default.cnf\r\n拷贝到/etc/my.cnf 就可以修改其配置参数例如 aliyun服务器内存不足的问题 等等\r\n对于启动时的日志信息可以在 /var/lib/mysql/xxxxx.err里查看\r\n\r\n[mysqld]\r\ninnodb_buffer_pool_size = 8M\r\ncharacter-set-server=utf8\r\n[client]\r\ndefault-character-set=utf8\r\n\r\n5.可选 安装phpMyAdmin 下载 phpMyAdmin-4.0.4.1-all-languages\r\n修改目录下的config.sample.inc.php为config.inc.php\r\n填充 当认证方式为http cookie时 填充 blowfish_secret\r\n$cfg[\'Servers\'][$i][\'auth_type\'] = \'cookie\';\r\n$cfg[\'blowfish_secret\'] = \'gigi117zyd\';\r\n$cfg[\'Servers\'][$i][\'host\'] = \'localhost\'; | ip address\r\n$cfg[\'Servers\'][$i][\'extension\'] = \'mysql\'; mysql | mysqli\r\n\r\n备注：\r\nmysql配置非自动提交\r\nhttp://blog.sina.com.cn/s/blog_4f925fc30102elde.html\r\n\r\nmysql配置日志信息\r\nhttp://www.58blo.com/?p=652\r\n\r\nmysqlbinlog bug\r\nhttp://shanchao7932297.blog.163.com/blog/static/136362420112229736293/','centos5 编译并安装Apache,php,mysql','','publish','open','open','','centos5-%e7%bc%96%e8%af%91%e5%b9%b6%e5%ae%89%e8%a3%85apachephpmysql','','','2013-08-23 14:29:06','2013-08-23 06:29:06','',0,'http://localhost/wordpress/?p=137',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (138,1,'2013-08-23 14:29:06','2013-08-23 06:29:06','在使用源代码安装的时候请确保 安装了c c++编译器 例如 gcc gcc-c++\r\n\r\n1. 编译安装Apache2.4\r\n注意2.4的版本安装方式与2.2不同\r\nRequirements ：APR and APR-Util Perl-Compatible Regular Expressions Library (PCRE) 参考Apache官方文档\r\n安装完 APR APR-Util PCRE 确认删除安装操作系统时自带的apache 俺顺序执行\r\n\r\n安装 apr | apr-Util | pcre\r\n# ./configure --prefix=/usr/local/apr\r\n# make\r\n# make install\r\n\r\n# ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr\r\n# make\r\n# make install\r\n\r\n# ./configure --prefix=/usr/local/pcre\r\n# make\r\n# make install\r\n安装 Apache2.4\r\n# ./configure --prefix=/usr/local/apache2 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-pcre=/usr/local/pcre --enable-so --enable-rewrite\r\n# make\r\n# make install\r\n\r\n./configure -help 可以查看可以扩展的参数等等\r\n\r\n配置开机启动加入配置文件实现自启动\r\n\r\n[root@localhost ~]# cp /usr/local/apache/bin/apachectl /etc/init.d/httpd\r\n\r\n[root@localhost ~]# vim /etc/init.d/httpd\r\n\r\n在#!/bin/sh 下面加上这两行，wq保存退出\r\n\r\n# chkconfig: 345 61 61\r\n# description: Apache\r\n\r\n[root@localhost ~]# chkconfig --add httpd\r\n\r\n[root@localhost ~]# service httpd start\r\n\r\n在编译安装apache后如果还需要安装其他模块则使用apxs工具\r\n进入安装后的apache/bin目录 找到apxs 工具 通过apxs来加载其他的模块 例如加载mod_rewrite模块\r\n进入apache安装目录 例如\r\n/usr/local/apache2/bin ./apxs -i -a -c /httpd-2.4.4/modules/mappers/mod_rewrite.c\r\n该命令可以同时编译和安装mod_rewrite.c模块\r\n并能激活http.conf中的 LoadModule rewrite_module modules/mod_rewrite.so 它会自动取消该模块前的注释#号\r\n之后apache使用rewrite模块只需要\r\n在需要.htaccess的目录中配置.htaccess文件了，如需要用rewrite模块，加入如下：\r\n\r\nRewriteEngine On\r\n对于如何使用apxs工具可以查看 http://httpd.apache.org/docs/2.4/programs/apxs.html 该文档\r\n\r\n2.安装php5.4.17\r\n在编译的配置php阶段 会检查libxml2 以及libxml2-devel 如果已经安装了那么就没有问题如果在configure 阶段检查 发现没有libxml2和libxml2-devel会出错 可以通过yum install libxml2 ,libxml2-devel来安装 gd库的时候注意 libpng libpng-devel gd gd-devel freetype等依赖库\r\n\r\n然后执行命令\r\n./configure --prefix=/opt/php/ --with-apxs2=/opt/apache2/bin/apxs --with-mysql=mysqlnd --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd --enable-soap --enable-mbstring --enable-sockets --with-zlib --with-mcrypt=/usr/local/libmcrypt --with-pear=/opt/php/lib/php --enable-mysqlnd --with-gd\r\n备注: 使用mysqlnd是在oracle收购mysql之后由于libmysql版权问题 php官方开发了自己的原生mysql驱动直接支持mysql只是在底层进行了改变 而不会影响API 接口因此使用上没有影响 性能比传统的libmysql.dll提高了许多.\r\n然后 make &amp; make install\r\n\r\n备注：这里在安装的时候可能会需要提供zlib,libmcrypt等库的支持\r\n例如在加载扩展 --with-mcrypt 的时候需要 libmcrypt的支持 需要下载libmcrypt-2.5.7.tar.gz\r\nftp://mcrypt.hellug.gr/pub/crypto/mcrypt/libmcrypt/libmcrypt-2.5.7.tar.gz\r\n然后安装libmcrypt 到 /usr/local/mcrypt\r\n在配置php时指定目录例如 --with-mcrypt=/usr/local/mcrypt\r\n\r\n安装完后配置apache的http.conf文件以支持php\r\n找到/usr/local/apache2/conf/http.conf\r\n添加如下信息\r\n1.LoadModule php5_module modules/libphp5.so //在安装php配置.configure 时 添加参数 --with-apxs2=/usr/local/apache2/bin/apxs 可以自动装载写入php5模块到 apache2的httpd.conf下\r\n2. &lt;IfModule dir_module&gt; //这里只需要添加 index.php\r\nDirectoryIndex index.html index.php\r\n&lt;/IfModule&gt;\r\n3. AddHandler application/x-httpd-php .php\r\n4.拷贝php源文件中的php-ini.production 到/usr/local/php/lib 下 php-ini 然后根据需要指定 扩展以及其他参数\r\n\r\n添加到PATH目录\r\n修改/etc/profile文件使其永久性生效，并对所有系统用户生效，在文件末尾加上如下两行代码\r\nPATH=$PATH:/opt/apache2/bin:/opt/php/bin\r\nexport PATH\r\n最后：执行 命令source /etc/profile或 执行点命令 ./profile使其修改生效\r\n\r\n3.安装mysql 建议采用RPM来安装 www.mysql.com\r\n下载 MySQL-client-5.6.12-2.linux MySQL-server-5.6.12-2.linux 的RPM版本\r\n并根据需要安装依赖库 RPM安装会自动创建组用户生成随机密码 以及配置到服务器启动\r\n因此可以直接使用 service mysql start 来启动 mysql\r\n然后使用客户端\r\nshell&gt;mysql -u root -p\r\n输入随机密码 /root/.mysql_secret中的随机密码\r\nmysql&gt;set passwrod=password(\'xxxx\');\r\n然后就可以使用了\r\nmysql&gt;show databases\r\n\r\n对于RPM没有自动生成/etc/my.cnf文件 可以在/usr/share/mysql下找到一个 my-xxxx.cnf的配置文件 在mysql-server-5.6.12里是\r\nmy-default.cnf\r\n拷贝到/etc/my.cnf 就可以修改其配置参数例如 aliyun服务器内存不足的问题 等等\r\n对于启动时的日志信息可以在 /var/lib/mysql/xxxxx.err里查看\r\n\r\n[mysqld]\r\ninnodb_buffer_pool_size = 8M\r\ncharacter-set-server=utf8\r\n[client]\r\ndefault-character-set=utf8\r\n\r\n5.可选 安装phpMyAdmin 下载 phpMyAdmin-4.0.4.1-all-languages\r\n修改目录下的config.sample.inc.php为config.inc.php\r\n填充 当认证方式为http cookie时 填充 blowfish_secret\r\n$cfg[\'Servers\'][$i][\'auth_type\'] = \'cookie\';\r\n$cfg[\'blowfish_secret\'] = \'gigi117zyd\';\r\n$cfg[\'Servers\'][$i][\'host\'] = \'localhost\'; | ip address\r\n$cfg[\'Servers\'][$i][\'extension\'] = \'mysql\'; mysql | mysqli\r\n\r\n备注：\r\nmysql配置非自动提交\r\nhttp://blog.sina.com.cn/s/blog_4f925fc30102elde.html\r\n\r\nmysql配置日志信息\r\nhttp://www.58blo.com/?p=652\r\n\r\nmysqlbinlog bug\r\nhttp://shanchao7932297.blog.163.com/blog/static/136362420112229736293/','centos5 编译并安装Apache,php,mysql','','inherit','open','open','','137-revision-v1','','','2013-08-23 14:29:06','2013-08-23 06:29:06','',137,'http://localhost/wordpress/?p=138',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (139,1,'2013-08-23 14:29:33','2013-08-23 06:29:33','金三门户\r\nhttp://162.20.20.20/ ;\r\n------------\r\nitsm\r\nhttp://162.20.20.20/ssoServer/login?service=http%3A%2F%2F162.20.20.206%2Fitsm%2Flogin%2Flogin.jsp ;\r\naccount 25000009967 | 123\r\n-----------------\r\n金三集成管控数据修改\r\nhttp://218.247.237.95/system/login.aspx ;\r\naccoount 姓名全拼 密码空\r\n备注添加 xgr_dm = \'25000000000\', xgrq = sysdate\r\n--------------------\r\n中软vpn\r\nhttps://218.247.237.54 ; zhouyudong 123456\r\n-----------------\r\n中软qc\r\n\r\nhttp://10.23.4.100:7001/20qcbin/start_a.htm 老 需要连接vpn zhouyudong css\r\n\r\nhttp://100.12.242.110:7001/20qcbin ;新\r\nzhouyudong 密码为空  地税内网可以访问\r\n\r\n预生产 Abcd1234\r\n生产 Jssq1234\r\n\r\n项目管理平台 工时\r\n\r\nhttp://10.23.4.178/devsuite/\r\n\r\nzhouyd/gl123\r\n\r\n&nbsp;\r\n\r\n工作流任务  查询\r\n\r\nselect * from HX_GZLYQ.wr_mhworkitem t where rwzt like \'%510227195305243958%\'\r\n<div>select * from HX_GZLYQ.wr_mhworkitem t where rwzt like \'%发票库房退库入库查验%\' and XNDBRDM=\'25001140118\';</div>\r\n<div>1、首先定位到某条代办任务，打开代办任务页面，然后右击属性，获取此条代办任务的 工作项信息。类似如下：\r\nhttp://ltcs.hxzg.gt3.com:8116/sword?tid=dealTask&amp;workItemId=ff48c1ddc31143aa83118420436d6482&amp;taskType=2\r\n其中有个 字段 workItemId=ff48c1ddc31143aa83118420436d6482\r\n\r\n其中workIemId 是业务主键 执行以下语句。\r\n\r\n2、---如果workItemId 是非数字的32为字符串，此类任务为非流程类的任务。那么执行以下语句。\r\ndelete from hx_gzl.gzl_yx_flcrwzb zb\r\nwhere zb.flcrwuuid = (select flcrwuuid\r\nfrom hx_gzl.gzl_yx_flcrwmx mx\r\nwhere mx.flcrwmxuuid =【第一部中的ID】)\r\n\r\ndelete from hx_gzl.gzl_yx_flcrwmx mx\r\nwhere mx.flcrwmxuuid =【第一部中的ID】;\r\n\r\n3、切换门户数据库。以生产库为例 门户所在的库名为:ZJSC_HXJCPT\r\n执行以下语句：\r\n\r\ndelete zj_mh.mh_gzlrwxx rw where rw.gzxid=【第一部中的ID】;\r\n\r\n后台清理任务，只是用于近期引用代码异常中断过程中，造成的垃圾代办任务。后台清理数据比较繁琐，执行时按顺序执行即可。</div>','金三运维平台','','publish','open','open','','%e9%87%91%e4%b8%89%e8%bf%90%e7%bb%b4%e5%b9%b3%e5%8f%b0','','','2013-11-15 10:45:21','2013-11-15 02:45:21','',0,'http://localhost/wordpress/?p=139',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (140,1,'2013-08-23 14:29:33','2013-08-23 06:29:33','金三门户\r\nhttp://162.20.20.20/ ;\r\n------------\r\nitsm\r\nhttp://162.20.20.20/ssoServer/login?service=http%3A%2F%2F162.20.20.206%2Fitsm%2Flogin%2Flogin.jsp ;\r\naccount 25000009967 | 123\r\n-----------------\r\n金三集成管控数据修改\r\nhttp://218.247.237.95/system/login.aspx ;\r\naccoount 姓名全拼 密码空\r\n备注添加 xgr_dm = \'25000000000\', xgrq = sysdate\r\n--------------------\r\n中软vpn\r\nhttps://218.247.237.54 ; zhouyudong 123456\r\n-----------------\r\n中软qc\r\n\r\nhttp://10.23.4.100:7001/20qcbin/start_a.htm ;需要连接vpn\r\nzhouyudong css\r\n\r\n预生产 Abcd1234\r\n生产 Jssq1234','金三运维平台','','inherit','open','open','','139-revision-v1','','','2013-08-23 14:29:33','2013-08-23 06:29:33','',139,'http://localhost/wordpress/?p=140',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (141,1,'2013-08-30 12:58:23','2013-08-30 04:58:23','金三门户\r\nhttp://162.20.20.20/ ;\r\n------------\r\nitsm\r\nhttp://162.20.20.20/ssoServer/login?service=http%3A%2F%2F162.20.20.206%2Fitsm%2Flogin%2Flogin.jsp ;\r\naccount 25000009967 | 123\r\n-----------------\r\n金三集成管控数据修改\r\nhttp://218.247.237.95/system/login.aspx ;\r\naccoount 姓名全拼 密码空\r\n备注添加 xgr_dm = \'25000000000\', xgrq = sysdate\r\n--------------------\r\n中软vpn\r\nhttps://218.247.237.54 ; zhouyudong 123456\r\n-----------------\r\n中软qc\r\n\r\nhttp://10.23.4.100:7001/20qcbin/start_a.htm ;需要连接vpn\r\nzhouyudong css\r\n\r\n预生产 Abcd1234\r\n生产 Jssq1234\r\n\r\n项目管理平台 工时\r\n\r\nhttp://10.23.4.178/devsuite/','金三运维平台','','inherit','open','open','','139-revision-v1','','','2013-08-30 12:58:23','2013-08-30 04:58:23','',139,'http://localhost/wordpress/?p=141',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (142,1,'2013-08-30 14:06:11','2013-08-30 06:06:11','金三门户\r\nhttp://162.20.20.20/ ;\r\n------------\r\nitsm\r\nhttp://162.20.20.20/ssoServer/login?service=http%3A%2F%2F162.20.20.206%2Fitsm%2Flogin%2Flogin.jsp ;\r\naccount 25000009967 | 123\r\n-----------------\r\n金三集成管控数据修改\r\nhttp://218.247.237.95/system/login.aspx ;\r\naccoount 姓名全拼 密码空\r\n备注添加 xgr_dm = \'25000000000\', xgrq = sysdate\r\n--------------------\r\n中软vpn\r\nhttps://218.247.237.54 ; zhouyudong 123456\r\n-----------------\r\n中软qc\r\n\r\nhttp://10.23.4.100:7001/20qcbin/start_a.htm ;需要连接vpn\r\nzhouyudong css\r\n\r\n预生产 Abcd1234\r\n生产 Jssq1234\r\n\r\n项目管理平台 工时\r\n\r\nhttp://10.23.4.178/devsuite/\r\n\r\nzhouyd/gl123','金三运维平台','','inherit','open','open','','139-revision-v1','','','2013-08-30 14:06:11','2013-08-30 06:06:11','',139,'http://localhost/wordpress/?p=142',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (143,1,'2013-09-10 11:47:46','2013-09-10 03:47:46','金三门户\r\nhttp://162.20.20.20/ ;\r\n------------\r\nitsm\r\nhttp://162.20.20.20/ssoServer/login?service=http%3A%2F%2F162.20.20.206%2Fitsm%2Flogin%2Flogin.jsp ;\r\naccount 25000009967 | 123\r\n-----------------\r\n金三集成管控数据修改\r\nhttp://218.247.237.95/system/login.aspx ;\r\naccoount 姓名全拼 密码空\r\n备注添加 xgr_dm = \'25000000000\', xgrq = sysdate\r\n--------------------\r\n中软vpn\r\nhttps://218.247.237.54 ; zhouyudong 123456\r\n-----------------\r\n中软qc\r\n\r\nhttp://100.12.242.110:7001/20qcbin ;需要连接vpn\r\nzhouyudong 密码为空  地税内网可以访问\r\n\r\n预生产 Abcd1234\r\n生产 Jssq1234\r\n\r\n项目管理平台 工时\r\n\r\nhttp://10.23.4.178/devsuite/\r\n\r\nzhouyd/gl123','金三运维平台','','inherit','open','open','','139-revision-v1','','','2013-09-10 11:47:46','2013-09-10 03:47:46','',139,'http://localhost/wordpress/?p=143',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (144,1,'2013-09-12 11:51:33','2013-09-12 03:51:33','金三门户\r\nhttp://162.20.20.20/ ;\r\n------------\r\nitsm\r\nhttp://162.20.20.20/ssoServer/login?service=http%3A%2F%2F162.20.20.206%2Fitsm%2Flogin%2Flogin.jsp ;\r\naccount 25000009967 | 123\r\n-----------------\r\n金三集成管控数据修改\r\nhttp://218.247.237.95/system/login.aspx ;\r\naccoount 姓名全拼 密码空\r\n备注添加 xgr_dm = \'25000000000\', xgrq = sysdate\r\n--------------------\r\n中软vpn\r\nhttps://218.247.237.54 ; zhouyudong 123456\r\n-----------------\r\n中软qc\r\n\r\nhttp://10.23.4.100:7001/20qcbin/start_a.htm 老 需要连接vpn zhouyudong css\r\n\r\nhttp://100.12.242.110:7001/20qcbin ;新\r\nzhouyudong 密码为空  地税内网可以访问\r\n\r\n预生产 Abcd1234\r\n生产 Jssq1234\r\n\r\n项目管理平台 工时\r\n\r\nhttp://10.23.4.178/devsuite/\r\n\r\nzhouyd/gl123','金三运维平台','','inherit','open','open','','139-revision-v1','','','2013-09-12 11:51:33','2013-09-12 03:51:33','',139,'http://localhost/wordpress/?p=144',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (145,1,'2013-09-14 18:02:27','2013-09-14 10:02:27','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\n创建用户，输入命令：\r\n\r\ngroupadd oinstall\r\ngroupadd dba\r\n\r\n创建Oracle用户和密码,输入命令：\r\n\r\nuseradd -g oinstall -g dba -m oracle\r\n\r\npasswd oracle\r\n\r\nchown -R oracle:oinstall /opt/app/oracle\r\n\r\nchmod –R 775 /opt/app/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\ncentos5 安装11g时 注意修改内核参数 安装的时候oracle会提供修改内核的参数\r\n\r\nSetting Kernel Parameters...\r\nkernel.sem = 250 32000 100 128\r\n\r\n安装完 oracle11g 软件后 就可以运行 dbca netca 进行数据库的创建和维护以及网络的配置等\r\n\r\n在linux下 如果安装完后 运行dbca 以及 netca提示找不到命令的时候 就是你的PATH路径配置有问题没有配置到 oracle的bin\r\n\r\n修改包括:\r\n\r\n1.在~/.bash_profile中增加以下内容\r\n\r\nexport ORACLE_BASE=/opt/app/oracle\r\nexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1\r\nexport ORACLE_SID=orcl\r\nexport LD_LIBRARY_PATH=$ORACLE_HOME/lib\r\nPATH=$PATH:$HOME/bin:$ORACLE_HOME/bin\r\n\r\nexport PATH\r\n\r\n配置path路径 可以直接使用 dbca  netca netmgr 等命令\r\n\r\n保存后输入命令 source ~/.bash_profile 让设置生效\r\n\r\n那么就可以直接在命令行下 输入dbca netca等命令','linux install oracle 11g','','publish','open','open','','linux-install-oracle-11g','','','2013-10-19 10:16:24','2013-10-19 02:16:24','',0,'http://localhost/wordpress/?p=145',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (146,1,'2013-09-14 18:02:27','2013-09-14 10:02:27','111','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-14 18:02:27','2013-09-14 10:02:27','',145,'http://localhost/wordpress/?p=146',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (147,1,'2013-09-14 18:02:31','2013-09-14 10:02:31','','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-14 18:02:31','2013-09-14 10:02:31','',145,'http://localhost/wordpress/?p=147',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (148,1,'2013-09-14 18:13:12','2013-09-14 10:13:12','这篇文档主要按最小化配置来说明 安装11g需要的配置信息','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-14 18:13:12','2013-09-14 10:13:12','',145,'http://localhost/wordpress/?p=148',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (149,1,'2013-09-14 18:13:55','2013-09-14 10:13:55','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-14 18:13:55','2013-09-14 10:13:55','',145,'http://localhost/wordpress/?p=149',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (150,1,'2013-09-14 18:14:05','2013-09-14 10:14:05','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-14 18:14:05','2013-09-14 10:14:05','',145,'http://localhost/wordpress/?p=150',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (151,1,'2013-10-19 09:59:10','2013-10-19 01:59:10','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\n\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\n\n2.系统配置 添加组 用户\n\n创建用户，输入命令：\n\ngroupadd oinstall\ngroupadd dba\n\n创建Oracle用户和密码,输入命令：\n\nuseradd -g oinstall -g dba -m oracle\n\npasswd oracle\n\nchown -R oracle:oinstall /opt/app/oracle\n\nchmod –R 775 /opt/app/oracle\n\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\n\n3.环境变量\n\n以oracle用户身份登录,修改当前用户下的.bash_profile\n\nexport ORACLE_BASE=/opt/oracle\nexport ORACLE_SID=orcl\n\n4.以远程终端安装需要配置export DISPLAY=ip:0\n\n5.oracle安装配置程序\n\nLisner配置：Netca\n\nDatabase配置：dbca\n\nTns 配置：netmgr\n\n6.运行\n\n./runInstaller\n\ncentos5 安装11g时 注意修改内核参数 安装的时候oracle会提供修改内核的参数\n\nSetting Kernel Parameters...\nkernel.sem = 250 32000 100 128\n\n安装完 oracle11g 软件后 就可以运行 dbca netca 进行数据库的创建和维护以及网络的配置等\n\n在linux下 如果安装完后 运行dbca 以及 netca提示找不到命令的时候 就是你的PATH路径配置有问题没有配置到 oracle的bin\n\n修改包括:\n\n1.在~/.bash_profile中增加以下内容\n\nexport ORACLE_BASE=/opt/app/oracle\nexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1\nexport ORACLE_SID=orcl\nexport LD_LIBRARY_PATH=$ORACLE_HOME/lib\nPATH=$PATH:$HOME/bin:$ORACLE_HOME/bin\n\nexport PATH\n\n配置\n\n保存后输入命令 source ~/.bash_profile 让设置生效\n\n那么就可以直接在命令行下 输入dbca netca等命令','linux install oracle 11g','','inherit','open','open','','145-autosave-v1','','','2013-10-19 09:59:10','2013-10-19 01:59:10','',145,'http://localhost/wordpress/?p=151',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (152,1,'2013-09-17 14:44:12','2013-09-17 06:44:12','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-17 14:44:12','2013-09-17 06:44:12','',145,'http://localhost/wordpress/?p=152',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (153,1,'2013-09-17 14:53:44','2013-09-17 06:53:44','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n&nbsp;','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-17 14:53:44','2013-09-17 06:53:44','',145,'http://localhost/wordpress/?p=153',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (154,1,'2013-09-17 14:55:25','2013-09-17 06:55:25','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n&nbsp;','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-17 14:55:25','2013-09-17 06:55:25','',145,'http://localhost/wordpress/?p=154',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (155,1,'2013-09-17 14:56:27','2013-09-17 06:56:27','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n&nbsp;\r\n\r\n&nbsp;','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-17 14:56:27','2013-09-17 06:56:27','',145,'http://localhost/wordpress/?p=155',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (156,1,'2013-09-17 15:10:42','2013-09-17 07:10:42','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\n&nbsp;\r\n\r\n&nbsp;','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-09-17 15:10:42','2013-09-17 07:10:42','',145,'http://localhost/wordpress/?p=156',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (158,1,'2013-10-14 16:31:23','2013-10-14 08:31:23','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\n&nbsp;\r\n\r\n&nbsp;','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-10-14 16:31:23','2013-10-14 08:31:23','',145,'http://localhost/wordpress/?p=158',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (159,1,'2013-10-14 23:57:13','2013-10-14 15:57:13','http://pan.baidu.com/s/1kkj1Y     mvf4','oracle 安装文件地址','','publish','open','open','','oracle-install','','','2013-10-15 09:40:59','2013-10-15 01:40:59','',0,'http://localhost/wordpress/?p=159',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (160,1,'2013-10-14 23:57:13','2013-10-14 15:57:13','http://pan.baidu.com/s/1kkj1Y     mvf4','oracle install ','','inherit','open','open','','159-revision-v1','','','2013-10-14 23:57:13','2013-10-14 15:57:13','',159,'http://localhost/wordpress/?p=160',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (161,1,'2013-10-15 09:40:52','2013-10-15 01:40:52','http://pan.baidu.com/s/1kkj1Y     mvf4','oracle 安装文件地址','','inherit','open','open','','159-revision-v1','','','2013-10-15 09:40:52','2013-10-15 01:40:52','',159,'http://localhost/wordpress/?p=161',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (162,1,'2013-10-15 09:41:45','2013-10-15 01:41:45','CentOS5.5建立本地源\r\n\r\n实验环境：虚拟机＋CentOS5.2\r\n\r\n所需软件：CentOS-5.2-i386-bin-DVD.iso\r\n\r\n实验目的：搭建本地源，实现软件的快速安装\r\n\r\n教程适用：局域网；网速慢的用户；不想从网络安装软件包的用户\r\n\r\n一、首先准备好你要用的软件CentOS-5.2-i386-bin-DVD.iso\r\n\r\n可从自由软件库下载http://download.chinaunix.net至于虚拟机软件这里不做介绍，自己网上下载即可，推荐到中国虚拟机绿化小组下载。\r\n\r\n二、在虚拟机上安装好CentOS5.2，这里我也不多做介绍了，请自己查找相关资料。\r\n\r\n三、在CentOS5.2上面做以下操作：\r\n\r\n1、挂载CentOS-5.2-i386-bin-DVD.iso或者是挂载你的CentOS5.2光盘（刻录）\r\n\r\n挂载方法：(事先在/mnt下载建立iso文件夹)\r\n\r\nISO镜像mount –o loop /home/danny/CentOS-5.5-i386-bin-DVD.iso /mnt/iso\r\n\r\n光盘挂载mount /dev/cdrom /media\r\n\r\n这里要特别注意：在虚拟机上使用ISO镜像安装好CentOS5.5以后,系统会自动挂载你的CentOS5.2镜像到/media/CentOS_5.5_Final目录下面(在虚拟机的setting里设置CDROM)，这里我就利用他的自动挂载功能来做这个教程，不用手动来挂载，如果手动挂载的话你的目录可能和本教程里面的不太一样，请自己做相应的修改。\r\n\r\n2、修改/etc/yum.repos.d/CentOS-Base.repo\r\n\r\n修改之前备份此目录下面的两个文件CentOS-Base.repo CentOS-Media.repo，直接\r\n\r\ncp CentOS-Base.repo CentOS-Base.repo.bak\r\n\r\ncp CentOS-Media.repo CentOS-Media.repo.bak\r\n\r\n然后修改CentOS-Base.repo为如下内容：\r\n\r\n[ISO]\r\n\r\nname=iso\r\n\r\nbaseurl=file:///media/CentOS_5.5_Final/\r\n\r\ngpgcheck=1\r\n\r\nenable=1 --- 这里要启用\r\n\r\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5\r\n\r\n这里要注意，如果你是手动挂载光盘或者是镜像的话，请自行修改bashurl后面的文件路径。\r\n\r\n然后执行yum clean all\r\n\r\n3、安装你所需的软件\r\n\r\n直接执行yum install packagename\r\n\r\n例如：yum install samba','CentOS5.5建立本地源','','publish','open','open','','centos5-5%e5%bb%ba%e7%ab%8b%e6%9c%ac%e5%9c%b0%e6%ba%90','','','2013-10-17 12:15:05','2013-10-17 04:15:05','',0,'http://localhost/wordpress/?p=162',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (163,1,'2013-10-15 09:41:45','2013-10-15 01:41:45','CentOS5.5建立本地源\r\n\r\n实验环境：虚拟机＋CentOS5.2\r\n\r\n所需软件：CentOS-5.2-i386-bin-DVD.iso\r\n\r\n实验目的：搭建本地源，实现软件的快速安装\r\n\r\n教程适用：局域网；网速慢的用户；不想从网络安装软件包的用户\r\n\r\n\r\n\r\n\r\n\r\n一、首先准备好你要用的软件CentOS-5.2-i386-bin-DVD.iso\r\n\r\n可从自由软件库下载http://download.chinaunix.net至于虚拟机软件这里不做介绍，自己网上下载即可，推荐到中国虚拟机绿化小组下载。\r\n\r\n\r\n\r\n二、在虚拟机上安装好CentOS5.2，这里我也不多做介绍了，请自己查找相关资料。\r\n\r\n\r\n\r\n三、在CentOS5.2上面做以下操作：\r\n\r\n1、挂载CentOS-5.2-i386-bin-DVD.iso或者是挂载你的CentOS5.2光盘（刻录）\r\n\r\n挂载方法：(事先在/mnt下载建立iso文件夹)\r\n\r\nISO镜像mount –o loop /home/danny/CentOS-5.5-i386-bin-DVD.iso /mnt/iso\r\n\r\n光盘挂载mount /dev/cdrom /media\r\n\r\n这里要特别注意：在虚拟机上使用ISO镜像安装好CentOS5.5以后,系统会自动挂载你的CentOS5.2镜像到/media/CentOS_5.5_Final目录下面(在虚拟机的setting里设置CDROM)，这里我就利用他的自动挂载功能来做这个教程，不用手动来挂载，如果手动挂载的话你的目录可能和本教程里面的不太一样，请自己做相应的修改。\r\n\r\n2、修改/etc/yum.repos.d/CentOS-Base.repo\r\n\r\n修改之前备份此目录下面的两个文件CentOS-Base.repo CentOS-Media.repo，直接\r\n\r\ncp CentOS-Base.repo CentOS-Base.repo.bak\r\n\r\ncp CentOS-Media.repo CentOS-Media.repo.bak\r\n\r\n\r\n\r\n然后修改CentOS-Base.repo为如下内容：\r\n\r\n[ISO]\r\n\r\nname=iso\r\n\r\nbaseurl=file:///media/CentOS_5.5_Final/\r\n\r\ngpgcheck=1\r\n\r\nenable=0\r\n\r\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5\r\n\r\n这里要注意，如果你是手动挂载光盘或者是镜像的话，请自行修改bashurl后面的文件路径。\r\n\r\n然后执行yum clean all\r\n\r\n3、安装你所需的软件\r\n\r\n直接执行yum install packagename\r\n\r\n例如：yum install samba','CentOS5.5建立本地源','','inherit','open','open','','162-revision-v1','','','2013-10-15 09:41:45','2013-10-15 01:41:45','',162,'http://localhost/wordpress/?p=163',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (164,1,'2013-10-15 11:06:57','2013-10-15 03:06:57','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\ncentos5 安装11g时 注意修改内核参数\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semmns\" is properly set. (more details)\r\nExpected Value\r\n: 32000\r\nActual Value\r\n: 100\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semopm\" is properly set. (more details)\r\nExpected Value\r\n: 100\r\nActual Value\r\n: 32\r\n\r\nSetting Kernel Parameters...\r\nkernel.sem = 250 32000 100 128\r\n\r\n&nbsp;','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-10-15 11:06:57','2013-10-15 03:06:57','',145,'http://localhost/wordpress/?p=164',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (165,1,'2013-10-16 12:00:01','2013-10-16 04:00:01','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\ncentos5 安装11g时 注意修改内核参数 安装的时候oracle会提供修改内核的参数脚本\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semmns\" is properly set. (more details)\r\nExpected Value\r\n: 32000\r\nActual Value\r\n: 100\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semopm\" is properly set. (more details)\r\nExpected Value\r\n: 100\r\nActual Value\r\n: 32\r\n\r\nSetting Kernel Parameters...\r\nkernel.sem = 250 32000 100 128\r\n\r\n安装完 oracle11g 软件后 就可以运行 dbca netca 进行数据库的创建和维护以及网络的配置等','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-10-16 12:00:01','2013-10-16 04:00:01','',145,'http://localhost/wordpress/?p=165',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (166,1,'2013-10-16 12:01:48','2013-10-16 04:01:48','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\ncentos5 安装11g时 注意修改内核参数 安装的时候oracle会提供修改内核的参数脚本\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semmns\" is properly set. (more details)\r\nExpected Value\r\n: 32000\r\nActual Value\r\n: 100\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semopm\" is properly set. (more details)\r\nExpected Value\r\n: 100\r\nActual Value\r\n: 32\r\n\r\nSetting Kernel Parameters...\r\nkernel.sem = 250 32000 100 128\r\n\r\n安装完 oracle11g 软件后 就可以运行 dbca netca 进行数据库的创建和维护以及网络的配置等\r\n\r\n在linux下 如果安装完后 运行dbca 以及 netca提示找不到命令的时候 就是你的PATH路径配置有问题没有配置到 oracle的bin\r\n\r\n修改包括:\r\n\r\n1.在~/.bash_profile中增加以下内容\r\n\r\nexport ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_1\r\nexport LD_LIBRARY_PATH=/home/oracle/app/oracle/product/11.2.0/dbhome_1/lib\r\nexport PATH=$PATH:$ORACLE_HOME/bin\r\n\r\n\r\n\r\n保存后输入命令 source ~/.bash_profile 让设置生效\r\n\r\n那么就可以直接在命令行下 输入dbca netca等命令','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-10-16 12:01:48','2013-10-16 04:01:48','',145,'http://localhost/wordpress/?p=166',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (167,1,'2013-10-16 18:02:59','2013-10-16 10:02:59','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\ncentos5 安装11g时 注意修改内核参数 安装的时候oracle会提供修改内核的参数脚本\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semmns\" is properly set. (more details)\r\nExpected Value\r\n: 32000\r\nActual Value\r\n: 100\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semopm\" is properly set. (more details)\r\nExpected Value\r\n: 100\r\nActual Value\r\n: 32\r\n\r\nSetting Kernel Parameters...\r\nkernel.sem = 250 32000 100 128\r\n\r\n安装完 oracle11g 软件后 就可以运行 dbca netca 进行数据库的创建和维护以及网络的配置等\r\n\r\n在linux下 如果安装完后 运行dbca 以及 netca提示找不到命令的时候 就是你的PATH路径配置有问题没有配置到 oracle的bin\r\n\r\n修改包括:\r\n\r\n1.在~/.bash_profile中增加以下内容\r\n\r\nexport ORACLE_BASE=/home/oracle/app\r\n\r\nexport ORACLE_HOME=$ORACLE_BASE/oracle/product/11.2.0/dbhome_1\r\n\r\nexport ORACLE_SID=orcl\r\n\r\nexport PATH=$PATH:$HOME/bin:$ORACLE_HOME/bin\r\n\r\nexport LD_LIBRARY_PATH=$ORACLE_HOME/lib:/usr/lib export PATH=$PATH:$ORACLE_HOME/bin\r\n\r\n保存后输入命令 source ~/.bash_profile 让设置生效\r\n\r\n那么就可以直接在命令行下 输入dbca netca等命令','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-10-16 18:02:59','2013-10-16 10:02:59','',145,'http://localhost/wordpress/?p=167',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (168,1,'2013-10-16 18:09:41','2013-10-16 10:09:41','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\ngroupadd oinstall\r\n\r\ngroupadd dba\r\n\r\nuseradd oracle\r\n\r\nuseradd –g oinstall –G dba oracle\r\n\r\nchown -R oracle:oinstall /opt/oracle\r\n\r\nchmod –R 775 /opt/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\ncentos5 安装11g时 注意修改内核参数 安装的时候oracle会提供修改内核的参数脚本\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semmns\" is properly set. (more details)\r\nExpected Value\r\n: 32000\r\nActual Value\r\n: 100\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semopm\" is properly set. (more details)\r\nExpected Value\r\n: 100\r\nActual Value\r\n: 32\r\n\r\nSetting Kernel Parameters...\r\nkernel.sem = 250 32000 100 128\r\n\r\n安装完 oracle11g 软件后 就可以运行 dbca netca 进行数据库的创建和维护以及网络的配置等\r\n\r\n在linux下 如果安装完后 运行dbca 以及 netca提示找不到命令的时候 就是你的PATH路径配置有问题没有配置到 oracle的bin\r\n\r\n修改包括:\r\n\r\n1.在~/.bash_profile中增加以下内容export ORACLE_BASE=/opt/app/oracle\r\nexport ORACLE_HOME=$ORACLE_BASE/oracle/product/11.2.0/dbhome_1\r\nexport ORACLE_SID=orcl\r\nexport LD_LIBRARY_PATH=$ORACLE_HOME/lib\r\nPATH=$PATH:$HOME/bin:$ORACLE_HOME/bin\r\n\r\nexport PATH\r\n\r\n保存后输入命令 source ~/.bash_profile 让设置生效\r\n\r\n那么就可以直接在命令行下 输入dbca netca等命令','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-10-16 18:09:41','2013-10-16 10:09:41','',145,'http://localhost/wordpress/?p=168',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (169,1,'2013-10-16 19:07:51','2013-10-16 11:07:51','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\n创建用户，输入命令：\r\n\r\ngroupadd oinstall\r\ngroupadd dba\r\n\r\n创建Oracle用户和密码,输入命令：\r\n\r\nuseradd -g oinstall -g dba -m oracle\r\n\r\npasswd oracle\r\n\r\nchown -R oracle:oinstall /opt/app/oracle\r\n\r\nchmod –R 775 /opt/app/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\ncentos5 安装11g时 注意修改内核参数 安装的时候oracle会提供修改内核的参数脚本\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semmns\" is properly set. (more details)\r\nExpected Value\r\n: 32000\r\nActual Value\r\n: 100\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semopm\" is properly set. (more details)\r\nExpected Value\r\n: 100\r\nActual Value\r\n: 32\r\n\r\nSetting Kernel Parameters...\r\nkernel.sem = 250 32000 100 128\r\n\r\n安装完 oracle11g 软件后 就可以运行 dbca netca 进行数据库的创建和维护以及网络的配置等\r\n\r\n在linux下 如果安装完后 运行dbca 以及 netca提示找不到命令的时候 就是你的PATH路径配置有问题没有配置到 oracle的bin\r\n\r\n修改包括:\r\n\r\n1.在~/.bash_profile中增加以下内容export ORACLE_BASE=/opt/app/oracle\r\nexport ORACLE_HOME=$ORACLE_BASE/oracle/product/11.2.0/dbhome_1\r\nexport ORACLE_SID=orcl\r\nexport LD_LIBRARY_PATH=$ORACLE_HOME/lib\r\nPATH=$PATH:$HOME/bin:$ORACLE_HOME/bin\r\n\r\nexport PATH\r\n\r\n保存后输入命令 source ~/.bash_profile 让设置生效\r\n\r\n那么就可以直接在命令行下 输入dbca netca等命令','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-10-16 19:07:51','2013-10-16 11:07:51','',145,'http://localhost/wordpress/?p=169',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (170,1,'2013-10-16 23:15:52','2013-10-16 15:15:52','rhel5 /centos以上 请确认是否安装图形界面 xwindow gnome gdm\r\n1.修改/usr/share/gdm/defaults.conf文件\r\n[xdmcp]\r\nEnable=true\r\nDisplaysPerHost=10\r\nPort=177\r\n[security]\r\nAllowRoot=true\r\nAllowRemoteRoot=true\r\n2.再修改/etc/inittab文件 加入以下行：\r\nx:5:respawn:/usr/sbin/gdm\r\n3.在/etc/sysconfig/iptables文件中加入：\r\n-A RH-Firewall-1-INPUT -m state --state NEW -m udp -p udp --dport 177 -j ACCEPT\r\n-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 6000:6010 -j ACCEPT\r\nrhel6/centos\r\ngdm conf 在\r\n/etc/gdm/custom.conf\r\nreboot','xmanager 图形界面链接centos5','','publish','open','open','','xmanager-%e5%9b%be%e5%bd%a2%e7%95%8c%e9%9d%a2%e9%93%be%e6%8e%a5centos5','','','2013-10-16 23:21:02','2013-10-16 15:21:02','',0,'http://localhost/wordpress/?p=170',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (171,1,'2013-10-16 23:15:52','2013-10-16 15:15:52','rhel5 /centos以上 请确认是否安装图形界面 xwindow gnome gdm\r\n1.修改/usr/share/gdm/defaults.conf文件\r\n[xdmcp]\r\nEnable=true\r\nDisplaysPerHost=10\r\nPort=177\r\n[security]\r\nAllowRoot=true\r\nAllowRemoteRoot=true\r\n2.再修改/etc/inittab文件 加入以下行：\r\nx:5:respawn:/usr/sbin/gdm\r\n3.在/etc/sysconfig/iptables文件中加入：\r\n-A RH-Firewall-1-INPUT -m state --state NEW -m udp -p udp --dport 177 -j ACCEPT\r\n-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 6000:6010 -j ACCEPT\r\nrhel6/centos\r\ngdm conf 在\r\n/etc/gdm/custom.conf\r\nreboot','xmanager 图形界面链接centos5','','inherit','open','open','','170-revision-v1','','','2013-10-16 23:15:52','2013-10-16 15:15:52','',170,'http://localhost/wordpress/?p=171',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (172,1,'2013-10-16 23:38:00','2013-10-16 15:38:00','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\n创建用户，输入命令：\r\n\r\ngroupadd oinstall\r\ngroupadd dba\r\n\r\n创建Oracle用户和密码,输入命令：\r\n\r\nuseradd -g oinstall -g dba -m oracle\r\n\r\npasswd oracle\r\n\r\nchown -R oracle:oinstall /opt/app/oracle\r\n\r\nchmod –R 775 /opt/app/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\ncentos5 安装11g时 注意修改内核参数 安装的时候oracle会提供修改内核的参数脚本\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semmns\" is properly set. (more details)\r\nExpected Value\r\n: 32000\r\nActual Value\r\n: 100\r\n\r\nThis is a prerequisite condition to test whether the OS kernel parameter \"semopm\" is properly set. (more details)\r\nExpected Value\r\n: 100\r\nActual Value\r\n: 32\r\n\r\nSetting Kernel Parameters...\r\nkernel.sem = 250 32000 100 128\r\n\r\n安装完 oracle11g 软件后 就可以运行 dbca netca 进行数据库的创建和维护以及网络的配置等\r\n\r\n在linux下 如果安装完后 运行dbca 以及 netca提示找不到命令的时候 就是你的PATH路径配置有问题没有配置到 oracle的bin\r\n\r\n修改包括:\r\n\r\n1.在~/.bash_profile中增加以下内容\r\n\r\nexport ORACLE_BASE=/opt/app/oracle\r\nexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1\r\nexport ORACLE_SID=orcl\r\nexport LD_LIBRARY_PATH=$ORACLE_HOME/lib\r\nPATH=$PATH:$HOME/bin:$ORACLE_HOME/bin\r\n\r\nexport PATH\r\n\r\n保存后输入命令 source ~/.bash_profile 让设置生效\r\n\r\n那么就可以直接在命令行下 输入dbca netca等命令','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-10-16 23:38:00','2013-10-16 15:38:00','',145,'http://localhost/wordpress/?p=172',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (173,1,'2013-10-17 11:23:30','2013-10-17 03:23:30','CentOS5.5建立本地源\r\n\r\n实验环境：虚拟机＋CentOS5.2\r\n\r\n所需软件：CentOS-5.2-i386-bin-DVD.iso\r\n\r\n实验目的：搭建本地源，实现软件的快速安装\r\n\r\n教程适用：局域网；网速慢的用户；不想从网络安装软件包的用户\r\n\r\n一、首先准备好你要用的软件CentOS-5.2-i386-bin-DVD.iso\r\n\r\n可从自由软件库下载http://download.chinaunix.net至于虚拟机软件这里不做介绍，自己网上下载即可，推荐到中国虚拟机绿化小组下载。\r\n\r\n二、在虚拟机上安装好CentOS5.2，这里我也不多做介绍了，请自己查找相关资料。\r\n\r\n三、在CentOS5.2上面做以下操作：\r\n\r\n1、挂载CentOS-5.2-i386-bin-DVD.iso或者是挂载你的CentOS5.2光盘（刻录）\r\n\r\n挂载方法：(事先在/mnt下载建立iso文件夹)\r\n\r\nISO镜像mount –o loop /home/danny/CentOS-5.5-i386-bin-DVD.iso /mnt/iso\r\n\r\n光盘挂载mount /dev/cdrom /media\r\n\r\n这里要特别注意：在虚拟机上使用ISO镜像安装好CentOS5.5以后,系统会自动挂载你的CentOS5.2镜像到/media/CentOS_5.5_Final目录下面(在虚拟机的setting里设置CDROM)，这里我就利用他的自动挂载功能来做这个教程，不用手动来挂载，如果手动挂载的话你的目录可能和本教程里面的不太一样，请自己做相应的修改。\r\n\r\n2、修改/etc/yum.repos.d/CentOS-Base.repo\r\n\r\n修改之前备份此目录下面的两个文件CentOS-Base.repo CentOS-Media.repo，直接\r\n\r\ncp CentOS-Base.repo CentOS-Base.repo.bak\r\n\r\ncp CentOS-Media.repo CentOS-Media.repo.bak\r\n\r\n然后修改CentOS-Base.repo为如下内容：\r\n\r\n[ISO]\r\n\r\nname=iso\r\n\r\nbaseurl=file:///media/CentOS_5.5_Final/\r\n\r\ngpgcheck=1\r\n\r\nenable=1 --- 这里要启用\r\n\r\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5\r\n\r\n这里要注意，如果你是手动挂载光盘或者是镜像的话，请自行修改bashurl后面的文件路径。\r\n\r\n然后执行yum clean all\r\n\r\n3、安装你所需的软件\r\n\r\n直接执行yum install packagename\r\n\r\n例如：yum install samba','CentOS5.5建立本地源','','inherit','open','open','','162-revision-v1','','','2013-10-17 11:23:30','2013-10-17 03:23:30','',162,'http://localhost/wordpress/?p=173',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (174,1,'2013-10-19 09:59:32','2013-10-19 01:59:32','这篇文档主要按最小化配置来说明 安装11g需要的配置信息\r\n\r\n1.系统环境 centos5.5 32bit  2G RAM  swap 3G\r\n\r\n2.系统配置 添加组 用户\r\n\r\n创建用户，输入命令：\r\n\r\ngroupadd oinstall\r\ngroupadd dba\r\n\r\n创建Oracle用户和密码,输入命令：\r\n\r\nuseradd -g oinstall -g dba -m oracle\r\n\r\npasswd oracle\r\n\r\nchown -R oracle:oinstall /opt/app/oracle\r\n\r\nchmod –R 775 /opt/app/oracle\r\n\r\n如果用oracle用户进行安装的时候 提示某路径不可写 出了要chmod 775 还要修改chown 给予对应的组\r\n\r\n3.环境变量\r\n\r\n以oracle用户身份登录,修改当前用户下的.bash_profile\r\n\r\nexport ORACLE_BASE=/opt/oracle\r\nexport ORACLE_SID=orcl\r\n\r\n4.以远程终端安装需要配置export DISPLAY=ip:0\r\n\r\n5.oracle安装配置程序\r\n\r\nLisner配置：Netca\r\n\r\nDatabase配置：dbca\r\n\r\nTns 配置：netmgr\r\n\r\n6.运行\r\n\r\n./runInstaller\r\n\r\ncentos5 安装11g时 注意修改内核参数 安装的时候oracle会提供修改内核的参数\r\n\r\nSetting Kernel Parameters...\r\nkernel.sem = 250 32000 100 128\r\n\r\n安装完 oracle11g 软件后 就可以运行 dbca netca 进行数据库的创建和维护以及网络的配置等\r\n\r\n在linux下 如果安装完后 运行dbca 以及 netca提示找不到命令的时候 就是你的PATH路径配置有问题没有配置到 oracle的bin\r\n\r\n修改包括:\r\n\r\n1.在~/.bash_profile中增加以下内容\r\n\r\nexport ORACLE_BASE=/opt/app/oracle\r\nexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1\r\nexport ORACLE_SID=orcl\r\nexport LD_LIBRARY_PATH=$ORACLE_HOME/lib\r\nPATH=$PATH:$HOME/bin:$ORACLE_HOME/bin\r\n\r\nexport PATH\r\n\r\n配置path路径 可以直接使用 dbca  netca netmgr 等命令\r\n\r\n保存后输入命令 source ~/.bash_profile 让设置生效\r\n\r\n那么就可以直接在命令行下 输入dbca netca等命令','linux install oracle 11g','','inherit','open','open','','145-revision-v1','','','2013-10-19 09:59:32','2013-10-19 01:59:32','',145,'http://localhost/wordpress/?p=174',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (178,1,'2013-11-12 13:51:49','2013-11-12 05:51:49','----服务器端监听设置\r\n\r\nSID_LIST_LISTENER =\r\n(SID_LIST =\r\n(SID_DESC =\r\n(SID_NAME = PLSExtProc)\r\n(ORACLE_HOME = /opt/app/oracle/product/11.2.0/dbhome_1)\r\n(PROGRAM = extproc)\r\n)\r\n\r\n(SID_DESC =\r\n(SID_NAME = orcl)\r\n(ORACLE_HOME = /opt/app/oracle/product/11.2.0/dbhome_1)\r\n(GLOBAL_DBNAME= ORCL.ORACLE.COM)\r\n)\r\n)\r\n\r\nLISTENER =\r\n(DESCRIPTION_LIST =\r\n(DESCRIPTION =\r\n(ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))\r\n(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.93.3)(PORT = 1521))\r\n)\r\n)\r\n\r\n---------------客户端设置连接描述符\r\n\r\nCSDB =\r\n(DESCRIPTION =\r\n(ADDRESS_LIST =\r\n(ADDRESS = (PROTOCOL = TCP)(HOST = 162.16.220.81)(PORT = 1521))\r\n)\r\n(CONNECT_DATA =\r\n(SERVICE_NAME = csdb)\r\n)\r\n)\r\n\r\nORCL =\r\n(DESCRIPTION =\r\n(ADDRESS_LIST =\r\n(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.93.3)(PORT = 1521))\r\n)\r\n(CONNECT_DATA =\r\n(SERVICE_NAME = orcl.oracle.com)\r\n)\r\n)','oracle listener net config','','publish','open','open','','oracle-listener-net-config','','','2013-11-12 13:52:40','2013-11-12 05:52:40','',0,'http://localhost/wordpress/?p=178',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (179,1,'2013-11-12 13:51:49','2013-11-12 05:51:49','----服务器端监听设置\r\n\r\nSID_LIST_LISTENER =\r\n(SID_LIST =\r\n(SID_DESC =\r\n(SID_NAME = PLSExtProc)\r\n(ORACLE_HOME = /opt/app/oracle/product/11.2.0/dbhome_1)\r\n(PROGRAM = extproc)\r\n)\r\n\r\n(SID_DESC =\r\n(SID_NAME = orcl)\r\n(ORACLE_HOME = /opt/app/oracle/product/11.2.0/dbhome_1)\r\n(GLOBAL_DBNAME= ORCL.ORACLE.COM)\r\n)\r\n)\r\n\r\nLISTENER =\r\n(DESCRIPTION_LIST =\r\n(DESCRIPTION =\r\n(ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))\r\n(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.93.3)(PORT = 1521))\r\n)\r\n)','oracle listener net config','','inherit','open','open','','178-revision-v1','','','2013-11-12 13:51:49','2013-11-12 05:51:49','',178,'http://localhost/wordpress/?p=179',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (180,1,'2013-11-12 13:52:40','2013-11-12 05:52:40','----服务器端监听设置\r\n\r\nSID_LIST_LISTENER =\r\n(SID_LIST =\r\n(SID_DESC =\r\n(SID_NAME = PLSExtProc)\r\n(ORACLE_HOME = /opt/app/oracle/product/11.2.0/dbhome_1)\r\n(PROGRAM = extproc)\r\n)\r\n\r\n(SID_DESC =\r\n(SID_NAME = orcl)\r\n(ORACLE_HOME = /opt/app/oracle/product/11.2.0/dbhome_1)\r\n(GLOBAL_DBNAME= ORCL.ORACLE.COM)\r\n)\r\n)\r\n\r\nLISTENER =\r\n(DESCRIPTION_LIST =\r\n(DESCRIPTION =\r\n(ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))\r\n(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.93.3)(PORT = 1521))\r\n)\r\n)\r\n\r\n---------------客户端设置连接描述符\r\n\r\nCSDB =\r\n(DESCRIPTION =\r\n(ADDRESS_LIST =\r\n(ADDRESS = (PROTOCOL = TCP)(HOST = 162.16.220.81)(PORT = 1521))\r\n)\r\n(CONNECT_DATA =\r\n(SERVICE_NAME = csdb)\r\n)\r\n)\r\n\r\nORCL =\r\n(DESCRIPTION =\r\n(ADDRESS_LIST =\r\n(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.93.3)(PORT = 1521))\r\n)\r\n(CONNECT_DATA =\r\n(SERVICE_NAME = orcl.oracle.com)\r\n)\r\n)','oracle listener net config','','inherit','open','open','','178-revision-v1','','','2013-11-12 13:52:40','2013-11-12 05:52:40','',178,'http://localhost/wordpress/?p=180',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (181,1,'2013-11-15 10:33:04','2013-11-15 02:33:04','金三门户\r\nhttp://162.20.20.20/ ;\r\n------------\r\nitsm\r\nhttp://162.20.20.20/ssoServer/login?service=http%3A%2F%2F162.20.20.206%2Fitsm%2Flogin%2Flogin.jsp ;\r\naccount 25000009967 | 123\r\n-----------------\r\n金三集成管控数据修改\r\nhttp://218.247.237.95/system/login.aspx ;\r\naccoount 姓名全拼 密码空\r\n备注添加 xgr_dm = \'25000000000\', xgrq = sysdate\r\n--------------------\r\n中软vpn\r\nhttps://218.247.237.54 ; zhouyudong 123456\r\n-----------------\r\n中软qc\r\n\r\nhttp://10.23.4.100:7001/20qcbin/start_a.htm 老 需要连接vpn zhouyudong css\r\n\r\nhttp://100.12.242.110:7001/20qcbin ;新\r\nzhouyudong 密码为空  地税内网可以访问\r\n\r\n预生产 Abcd1234\r\n生产 Jssq1234\r\n\r\n项目管理平台 工时\r\n\r\nhttp://10.23.4.178/devsuite/\r\n\r\nzhouyd/gl123\r\n\r\n&nbsp;\r\n\r\n工作流任务  查询\r\n\r\nselect * from HX_GZLYQ.wr_mhworkitem t where rwzt like \'%510227195305243958%\'\r\n<div>select * from HX_GZLYQ.wr_mhworkitem t where rwzt like \'%发票库房退库入库查验%\' and XNDBRDM=\'25001140118\';</div>','金三运维平台','','inherit','open','open','','139-revision-v1','','','2013-11-15 10:33:04','2013-11-15 02:33:04','',139,'http://localhost/wordpress/?p=181',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (182,1,'2013-11-15 10:45:21','2013-11-15 02:45:21','金三门户\r\nhttp://162.20.20.20/ ;\r\n------------\r\nitsm\r\nhttp://162.20.20.20/ssoServer/login?service=http%3A%2F%2F162.20.20.206%2Fitsm%2Flogin%2Flogin.jsp ;\r\naccount 25000009967 | 123\r\n-----------------\r\n金三集成管控数据修改\r\nhttp://218.247.237.95/system/login.aspx ;\r\naccoount 姓名全拼 密码空\r\n备注添加 xgr_dm = \'25000000000\', xgrq = sysdate\r\n--------------------\r\n中软vpn\r\nhttps://218.247.237.54 ; zhouyudong 123456\r\n-----------------\r\n中软qc\r\n\r\nhttp://10.23.4.100:7001/20qcbin/start_a.htm 老 需要连接vpn zhouyudong css\r\n\r\nhttp://100.12.242.110:7001/20qcbin ;新\r\nzhouyudong 密码为空  地税内网可以访问\r\n\r\n预生产 Abcd1234\r\n生产 Jssq1234\r\n\r\n项目管理平台 工时\r\n\r\nhttp://10.23.4.178/devsuite/\r\n\r\nzhouyd/gl123\r\n\r\n&nbsp;\r\n\r\n工作流任务  查询\r\n\r\nselect * from HX_GZLYQ.wr_mhworkitem t where rwzt like \'%510227195305243958%\'\r\n<div>select * from HX_GZLYQ.wr_mhworkitem t where rwzt like \'%发票库房退库入库查验%\' and XNDBRDM=\'25001140118\';</div>\r\n<div>1、首先定位到某条代办任务，打开代办任务页面，然后右击属性，获取此条代办任务的 工作项信息。类似如下：\r\nhttp://ltcs.hxzg.gt3.com:8116/sword?tid=dealTask&amp;workItemId=ff48c1ddc31143aa83118420436d6482&amp;taskType=2\r\n其中有个 字段 workItemId=ff48c1ddc31143aa83118420436d6482\r\n\r\n其中workIemId 是业务主键 执行以下语句。\r\n\r\n2、---如果workItemId 是非数字的32为字符串，此类任务为非流程类的任务。那么执行以下语句。\r\ndelete from hx_gzl.gzl_yx_flcrwzb zb\r\nwhere zb.flcrwuuid = (select flcrwuuid\r\nfrom hx_gzl.gzl_yx_flcrwmx mx\r\nwhere mx.flcrwmxuuid =【第一部中的ID】)\r\n\r\ndelete from hx_gzl.gzl_yx_flcrwmx mx\r\nwhere mx.flcrwmxuuid =【第一部中的ID】;\r\n\r\n3、切换门户数据库。以生产库为例 门户所在的库名为:ZJSC_HXJCPT\r\n执行以下语句：\r\n\r\ndelete zj_mh.mh_gzlrwxx rw where rw.gzxid=【第一部中的ID】;\r\n\r\n后台清理任务，只是用于近期引用代码异常中断过程中，造成的垃圾代办任务。后台清理数据比较繁琐，执行时按顺序执行即可。</div>','金三运维平台','','inherit','open','open','','139-revision-v1','','','2013-11-15 10:45:21','2013-11-15 02:45:21','',139,'http://localhost/wordpress/?p=182',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (183,1,'2013-11-15 10:46:24','2013-11-15 02:46:24','金三门户\nhttp://162.20.20.20/ ;\n------------\nitsm\nhttp://162.20.20.20/ssoServer/login?service=http%3A%2F%2F162.20.20.206%2Fitsm%2Flogin%2Flogin.jsp ;\naccount 25000009967 | 123\n-----------------\n金三集成管控数据修改\nhttp://218.247.237.95/system/login.aspx ;\naccoount 姓名全拼 密码空\n备注添加 xgr_dm = \'25000000000\', xgrq = sysdate\n--------------------\n中软vpn\nhttps://218.247.237.54 ; zhouyudong 123456\n-----------------\n中软qc\n\nhttp://10.23.4.100:7001/20qcbin/start_a.htm 老 需要连接vpn zhouyudong css\n\nhttp://100.12.242.110:7001/20qcbin ;新\nzhouyudong 密码为空  地税内网可以访问\n\n预生产 Abcd1234\n生产 Jssq1234\n\n项目管理平台 工时\n\nhttp://10.23.4.178/devsuite/\n\nzhouyd/gl123\n\n&nbsp;\n\n工作流任务  查询\n\nselect * from HX_GZLYQ.wr_mhworkitem t where rwzt like \'%510227195305243958%\'\n<div>select * from HX_GZLYQ.wr_mhworkitem t where rwzt like \'%发票库房退库入库查验%\' and XNDBRDM=\'25001140118\';</div>\n<div>1、首先定位到某条代办任务，打开代办任务页面，然后右击属性，获取此条代办任务的 工作项信息。类似如下：\nhttp://ltcs.hxzg.gt3.com:8116/sword?tid=dealTask&amp;workItemId=ff48c1ddc31143aa83118420436d6482&amp;taskType=2\n其中有个 字段 workItemId=ff48c1ddc31143aa83118420436d6482其中workIemId 是业务主键 执行以下语句。\n\n2、---如果workItemId 是非数字的32为字符串，此类任务为非流程类的任务。那么执行以下语句。\ndelete from hx_gzl.gzl_yx_flcrwzb zb\nwhere zb.flcrwuuid = (select flcrwuuid\nfrom hx_gzl.gzl_yx_flcrwmx mx\nwhere mx.flcrwmxuuid =【第一部中的ID】)\n\ndelete from hx_gzl.gzl_yx_flcrwmx mx\nwhere mx.flcrwmxuuid =【第一部中的ID】;\n\n3、切换门户数据库。以生产库为例 门户所在的库名为:ZJSC_HXJCPT\n执行以下语句：\n\ndelete zj_mh.mh_gzlrwxx rw where rw.gzxid=【第一部中的ID】;\n\n后台清理任务，只是用于近期引用代码异常中断过程中，造成的垃圾代办任务。后台清理数据比较繁琐，执行时按顺序执行即可。\n\n</div>','金三运维平台','','inherit','open','open','','139-autosave-v1','','','2013-11-15 10:46:24','2013-11-15 02:46:24','',139,'http://localhost/wordpress/?p=183',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (185,1,'2013-12-31 10:38:09','2013-12-31 02:38:09','delete from (\r\nselect row_number(partition by a2 order by rowid desc nulls last ) rn from a2;\r\n) x\r\nwhere x.rn&gt;1','oracle delete rows','','publish','open','open','','oracle-delete-rows','','','2013-12-31 10:38:09','2013-12-31 02:38:09','',0,'http://localhost/wordpress/?p=185',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (186,1,'2013-12-31 10:38:09','2013-12-31 02:38:09','delete from (\r\nselect row_number(partition by a2 order by rowid desc nulls last ) rn from a2;\r\n) x\r\nwhere x.rn&gt;1','oracle delete rows','','inherit','open','open','','185-revision-v1','','','2013-12-31 10:38:09','2013-12-31 02:38:09','',185,'http://localhost/wordpress/?p=186',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (187,1,'2014-01-08 15:47:57','2014-01-08 07:47:57','如果在连接oracle数据库时采用basic类型 测试连接未通过时（抛开数据库正常）\r\nBasic\r\nIn Basic mode, Navicat Oracle connects to Oracle through the OracleCall Interface (OCI). OCI is an application programming interfacethat allows an application developer to use a third-generationlanguage\'s native procedure or function calls to access the Oracledatabase server and control all phases of SQL statement execution.OCI is a library of standard database access and retrievalfunctions in the form of a dynamic-link library.\r\n\r\n可能存在版本问题 注意替换安装目录下的 oci.dll文件','导航猫连接问题','','publish','open','open','','%e5%af%bc%e8%88%aa%e7%8c%ab%e8%bf%9e%e6%8e%a5%e9%97%ae%e9%a2%98','','','2014-01-08 15:47:57','2014-01-08 07:47:57','',0,'http://localhost/wordpress/?p=187',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (188,1,'2014-01-08 15:47:57','2014-01-08 07:47:57','如果在连接oracle数据库时采用basic类型 测试连接未通过时（抛开数据库正常）\r\nBasic\r\nIn Basic mode, Navicat Oracle connects to Oracle through the OracleCall Interface (OCI). OCI is an application programming interfacethat allows an application developer to use a third-generationlanguage\'s native procedure or function calls to access the Oracledatabase server and control all phases of SQL statement execution.OCI is a library of standard database access and retrievalfunctions in the form of a dynamic-link library.\r\n\r\n可能存在版本问题 注意替换安装目录下的 oci.dll文件','导航猫连接问题','','inherit','open','open','','187-revision-v1','','','2014-01-08 15:47:57','2014-01-08 07:47:57','',187,'http://localhost/wordpress/?p=188',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (190,1,'2014-02-12 15:29:57','2014-02-12 07:29:57','由于缓冲区 buffersize 的限制我们在测试我们的脚本的时候 输出可能会受到限制 无法直接一行输出 需要分割字符串进行输出因此 在处理的时候这样做\r\n\r\n&nbsp;\r\n\r\nfor i in 1..ceil(length(str_sql)/255)+1 loop\r\ndbms_output.put_line(substr(str_sql,(i-1)*255,255));\r\nend loop;','oracle dbms_output.put_line()','','publish','open','open','','oracle-dbms_output-put_line','','','2014-02-12 15:29:57','2014-02-12 07:29:57','',0,'http://localhost/wordpress/?p=190',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (191,1,'2014-02-12 15:29:57','2014-02-12 07:29:57','由于缓冲区 buffersize 的限制我们在测试我们的脚本的时候 输出可能会受到限制 无法直接一行输出 需要分割字符串进行输出因此 在处理的时候这样做\r\n\r\n&nbsp;\r\n\r\nfor i in 1..ceil(length(str_sql)/255)+1 loop\r\ndbms_output.put_line(substr(str_sql,(i-1)*255,255));\r\nend loop;','oracle dbms_output.put_line()','','inherit','open','open','','190-revision-v1','','','2014-02-12 15:29:57','2014-02-12 07:29:57','',190,'http://localhost/wordpress/?p=191',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (192,1,'2014-02-17 12:56:56','2014-02-17 04:56:56','oracle的正则表达式(regular expression)简单介绍\r\n目前，正则表达式已经在很多软件中得到广泛的应用，包括*nix（Linux, Unix等），HP等操作系统，PHP，C#，Java等开发环境。\r\nOracle 10g正则表达式提高了SQL灵活性。有效的解决了数据有效性，重复词的辨认, 无关的空白检测，或者分解多个正则组成的字符串等问题。\r\nOracle 10g支持正则表达式的四个新函数分别是：REGEXP_LIKE、REGEXP_INSTR、REGEXP_SUBSTR、和REGEXP_REPLACE。\r\n它们使用POSIX 正则表达式代替了老的百分号（%）和通配符（_）字符。\r\n特殊字符：\r\n\'^\' 匹配输入字符串的开始位置，在方括号表达式中使用，此时它表示不接受该字符集合。\r\n\'$\' 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 \'\\n\' 或\'\\r\'。\r\n\'.\' 匹配除换行符 \\n之外的任何单字符。\r\n\'?\' 匹配前面的子表达式零次或一次。\r\n\'*\' 匹配前面的子表达式零次或多次。\r\n\'+\' 匹配前面的子表达式一次或多次。\r\n\'( )\' 标记一个子表达式的开始和结束位置。\r\n\'[]\' 标记一个中括号表达式。\r\n\'{m,n}\' 一个精确地出现次数范围，m=&lt;出现次数&lt;=n，\'{m}\'表示出现m次，\'{m,}\'表示至少出现m次。\r\n\'|\' 指明两项之间的一个选择。例子\'^([a-z]+|[0-9]+)$\'表示所有小写字母或数字组合成的字符串。\r\n\\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。\r\n正则表达式的一个很有用的特点是可以保存子表达式以后使用，被称为Backreferencing. 允许复杂的替换能力\r\n如调整一个模式到新的位置或者指示被代替的字符或者单词的位置. 被匹配的子表达式存储在临时缓冲区\r\n\r\n中，缓冲区从左到右编号, 通过\\数字符号访问。 下面的例子列出了把名字 aa bb cc 变成cc, bb, aa.\r\nSelect REGEXP_REPLACE(\'aa bb cc\',\'(.*) (.*) (.*)\', \'\\3, \\2, \\1\') FROM dual；\r\nREGEXP_REPLACE(\'ELLENHILDISMIT\r\ncc, bb, aa\r\n\'\\\' 转义符。\r\n字符簇：\r\n[[:alpha:]] 任何字母。\r\n[[:digit:]] 任何数字。\r\n[[:alnum:]] 任何字母和数字。\r\n[[:space:]] 任何白字符。\r\n[[:upper:]] 任何大写字母。\r\n[[:lower:]] 任何小写字母。\r\n[[unct:]] 任何标点符号。\r\n[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]。\r\n各种操作符的运算优先级\r\n\\ 转义符\r\n(), (?, (?=), [] 圆括号和方括号\r\n*, +, ?, {n}, {n,}, {n,m} 限定符\r\n^, $, \\anymetacharacter 位置和顺序\r\n| “或”操作\r\n--测试数据\r\ncreate table test(mc varchar2(60));\r\ninsert into test values(\'112233445566778899\');\r\ninsert into test values(\'22113344 5566778899\');\r\ninsert into test values(\'33112244 5566778899\');\r\ninsert into test values(\'44112233 5566 778899\');\r\ninsert into test values(\'5511 2233 4466778899\');\r\ninsert into test values(\'661122334455778899\');\r\ninsert into test values(\'771122334455668899\');\r\ninsert into test values(\'881122334455667799\');\r\ninsert into test values(\'991122334455667788\');\r\ninsert into test values(\'aabbccddee\');\r\ninsert into test values(\'bbaaaccddee\');\r\ninsert into test values(\'ccabbddee\');\r\ninsert into test values(\'ddaabbccee\');\r\ninsert into test values(\'eeaabbccdd\');\r\ninsert into test values(\'ab123\');\r\ninsert into test values(\'123xy\');\r\ninsert into test values(\'007ab\');\r\ninsert into test values(\'abcxy\');\r\ninsert into test values(\'The final test is is is how to find duplicate words.\');\r\ncommit;\r\n一、REGEXP_LIKE\r\nselect * from test where regexp_like(mc,\'^a{1,3}\');\r\nselect * from test where regexp_like(mc,\'a{1,3}\');\r\nselect * from test where regexp_like(mc,\'^a.*e$\');\r\nselect * from test where regexp_like(mc,\'^[[:lower:]]|[[:digit:]]\');\r\nselect * from test where regexp_like(mc,\'^[[:lower:]]\');\r\nSelect mc FROM test Where REGEXP_LIKE(mc,\'[^[:digit:]]\');\r\nSelect mc FROM test Where REGEXP_LIKE(mc,\'^[^[:digit:]]\');\r\n二、REGEXP_INSTR\r\nSelect REGEXP_INSTR(mc,\'[[:digit:]]$\') from test;\r\nSelect REGEXP_INSTR(mc,\'[[:digit:]]+$\') from test;\r\nSelect REGEXP_INSTR(\'The price is $400.\',\'\\$[[:digit:]]+\') FROM DUAL;\r\nSelect REGEXP_INSTR(\'onetwothree\',\'[^[[:lower:]]]\') FROM DUAL;\r\nSelect REGEXP_INSTR(\',,,,,\',\'[^,]*\') FROM DUAL;\r\nSelect REGEXP_INSTR(\',,,,,\',\'[^,]\') FROM DUAL;\r\n三、REGEXP_SUBSTR\r\nSELECT REGEXP_SUBSTR(mc,\'[a-z]+\') FROM test;\r\nSELECT REGEXP_SUBSTR(mc,\'[0-9]+\') FROM test;\r\nSELECT REGEXP_SUBSTR(\'aababcde\',\'^a.*b\') FROM DUAL;\r\n四、REGEXP_REPLACE\r\nSelect REGEXP_REPLACE(\'Joe Smith\',\'( ){2,}\', \',\') AS RX_REPLACE FROM dual;\r\nSelect REGEXP_REPLACE(\'aa bb cc\',\'(.*) (.*) (.*)\', \'\\3, \\2, \\1\') FROM dual\r\n\r\n四个函数是:regexp_like.regexp_instr.regexp_substr.与 regexp_replace.它们在用法上与oracle sql 函数like.instr.substr 与replace 用法,但是它们使用posix 正则表达式代替了老的百分号（%）与通配符（_）字符. 【推荐阅读:My SQL数据库引擎快速指导】\r\n\r\nregexp_like 与like 操作符相似.如果第一个参数匹配正则表达式它就解析为true.例如where regexp_like(ename,^j[ao],i) 将在ename 以ja 或jo 开始的情况下返回一行数据.i 参数指定正则表达式是大小写敏感的.另外还可以在check 约束与函数索引中指定regexp_like.例如: 【扩展信息:MYSQL基本数据库术语】\r\n^ 表示字符串的开始 $ 表示字符串的结束 . 表示任何字符 字符的范围,比如说[a-z],表示任何ascii 小写字母,与字符类\"[[:lower:]]\"\" 等价 ? 允许一个后继字符匹配零次或一次 + 允许一个后继字符匹配一次或多次 * 表示零次或多次\r\n\r\n可以使用\"{m,n}\" 指定一个精确地出现范围,其意思是“出现从m 次到n 次”;\"{m}\" 表示“正好m次”;而\"{m,}\" 表示“至少m次”.还可以使用圆括号组合字符的集合,使用\"|\"（竖线）表示可替换.例如,字符串^([a-z]+|[0-9]+)$将匹配所有由小写字母或数字组合成的字符串.\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n---\r\n\r\n后向引用\r\n\r\n正则表达式的一个有用的特性是能够存储子表达式供以后重用；这也被称为后向引用（在表 10 中对其进行了概述）。它允许复杂的替换功能，如在新的位置上交换模式或显示重复出现的单词或字母。子表达式的匹配部分保存在临时缓冲区中。缓冲区从左至右进行编号，并利用 \\digit 符号进行访问，其中 digit 是 1 到 9 之间的一个数字，它匹配第 digit 个子表达式，子表达式用一组圆括号来显示。\r\n\r\n接下来的例子显示了通过按编号引用各个子表达式将姓名 Ellen Hildi Smith 转变为 Smith, Ellen Hildi。\r\n\r\nSELECT REGEXP_REPLACE(\r\n\'Ellen Hildi Smith\',\r\n\'(.*) (.*) (.*)\', \'\\3, \\1 \\2\')\r\nFROM dual\r\nREGEXP_REPLACE(\'EL\r\n------------------\r\nSmith, Ellen Hildi\r\n\r\n该 SQL 语句显示了用圆括号括住的三个单独的子表达式。每一个单独的子表达式包含一个匹配元字符 (.)，并紧跟着 * 元字符，表示任何字符（除换行符之外）都必须匹配零次或更多次。空格将各个子表达式分开，空格也必须匹配。圆括号创建获取值的子表达式，并且可以用 \\digit 来引用。第一个子表达式被赋值为 \\1 ，第二个 \\2，以此类推。这些后向引用被用在这个函数的最后一个参数 (\\3, \\1 \\2) 中，这个函数有效地返回了替换子字符串，并按期望的格式来排列它们（包括逗号和空格）','OCP 047-002 REGEXP','','publish','open','open','','oracle-regexp_like','','','2014-04-16 00:26:18','2014-04-15 16:26:18','',0,'http://localhost/wordpress/?p=192',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (193,1,'2014-02-17 12:56:56','2014-02-17 04:56:56','oracle regexp_like介绍和例子\r\n\r\nORACLE中的支持正则表达式的函数主要有下面四个：\r\n1，REGEXP_LIKE ：与LIKE的功能相似\r\n2，REGEXP_INSTR ：与INSTR的功能相似\r\n3，REGEXP_SUBSTR ：与SUBSTR的功能相似\r\n4，REGEXP_REPLACE ：与REPLACE的功能相似\r\n它们在用法上与Oracle SQL 函数LIKE、INSTR、SUBSTR 和REPLACE 用法相同，\r\n但是它们使用POSIX 正则表达式代替了老的百分号（%）和通配符（_）字符。\r\nPOSIX 正则表达式由标准的元字符（metacharacters）所构成：\r\n\'^\' 匹配输入字符串的开始位置，在方括号表达式中使用，此时它表示不接受该字符集合。\r\n\'$\' 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹\r\n配 \'\\n\' 或 \'\\r\'。\r\n\'.\' 匹配除换行符之外的任何单字符。\r\n\'?\' 匹配前面的子表达式零次或一次。\r\n\'+\' 匹配前面的子表达式一次或多次。\r\n\'*\' 匹配前面的子表达式零次或多次。\r\n\'|\' 指明两项之间的一个选择。例子\'^([a-z]+|[0-9]+)$\'表示所有小写字母或数字组合成的\r\n字符串。\r\n\'( )\' 标记一个子表达式的开始和结束位置。\r\n\'[]\' 标记一个中括号表达式。\r\n\'{m,n}\' 一个精确地出现次数范围，m=&lt;出现次数&lt;=n，\'{m}\'表示出现m次，\'{m,}\'表示至少\r\n出现m次。\r\n\\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。\r\n字符簇：\r\n[[:alpha:]] 任何字母。\r\n[[:digit:]] 任何数字。\r\n[[:alnum:]] 任何字母和数字。\r\n[[:space:]] 任何白字符。\r\n[[:upper:]] 任何大写字母。\r\n[[:lower:]] 任何小写字母。\r\n[[:punct:]] 任何标点符号。\r\n[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]。\r\n各种操作符的运算优先级\r\n\\转义符\r\n(), (?:), (?=), [] 圆括号和方括号\r\n*, +, ?, {n}, {n,}, {n,m} 限定符\r\n^, $, anymetacharacter 位置和顺序\r\n|\r\n*/\r\n--创建表\r\ncreate table fzq\r\n(\r\nid varchar(4),\r\nvalue varchar(10)\r\n);\r\n--数据插入\r\ninsert into fzq values\r\n(\'1\',\'1234560\');\r\ninsert into fzq values\r\n(\'2\',\'1234560\');\r\ninsert into fzq values\r\n(\'3\',\'1b3b560\');\r\ninsert into fzq values\r\n(\'4\',\'abc\');\r\ninsert into fzq values\r\n(\'5\',\'abcde\');\r\ninsert into fzq values\r\n(\'6\',\'ADREasx\');\r\ninsert into fzq values\r\n(\'7\',\'123 45\');\r\ninsert into fzq values\r\n(\'8\',\'adc de\');\r\ninsert into fzq values\r\n(\'9\',\'adc,.de\');\r\ninsert into fzq values\r\n(\'10\',\'1B\');\r\ninsert into fzq values\r\n(\'10\',\'abcbvbnb\');\r\ninsert into fzq values\r\n(\'11\',\'11114560\');\r\ninsert into fzq values\r\n(\'11\',\'11124560\');\r\n--regexp_like\r\n--查询value中以1开头60结束的记录并且长度是7位\r\nselect * from fzq where value like \'1____60\';\r\nselect * from fzq where regexp_like(value,\'1....60\');\r\n--查询value中以1开头60结束的记录并且长度是7位并且全部是数字的记录。\r\n--使用like就不是很好实现了。\r\nselect * from fzq where regexp_like(value,\'1[0-9]{4}60\');\r\n-- 也可以这样实现，使用字符集。\r\nselect * from fzq where regexp_like(value,\'1[[:digit:]]{4}60\');\r\n-- 查询value中不是纯数字的记录\r\nselect * from fzq where not regexp_like(value,\'^[[:digit:]]+$\');\r\n-- 查询value中不包含任何数字的记录。\r\nselect * from fzq where regexp_like(value,\'^[^[:digit:]]+$\');\r\n--查询以12或者1b开头的记录.不区分大小写。\r\nselect * from fzq where regexp_like(value,\'^1[2b]\',\'i\');\r\n--查询以12或者1b开头的记录.区分大小写。\r\nselect * from fzq where regexp_like(value,\'^1[2B]\');\r\n-- 查询数据中包含空白的记录。\r\nselect * from fzq where regexp_like(value,\'[[:space:]]\');\r\n--查询所有包含小写字母或者数字的记录。\r\nselect * from fzq where regexp_like(value,\'^([a-z]+|[0-9]+)$\');\r\n--查询任何包含标点符号的记录。\r\nselect * from fzq where regexp_like(value,\'[[:punct:]]\');\r\n\r\n例子：判断姓名是否为空，少于两个字符，包含数字和字母\r\n\r\ncreate or replace\r\nFUNCTION CheckName(NameStr in VARCHAR2) RETURN integer\r\nAs\r\nBEGIN\r\n--符合返回1，不符合返回0\r\nif(NameStr is null or length(NameStr)&lt;2) then\r\nreturn 0;\r\nelse\r\nif(NameStr like \'%未取名%\') then\r\nRETURN 0;\r\nend if;\r\nif regexp_like(NameStr,\'^([a-z]+|[0-9]+|[A-Z]+)$\') then\r\nreturn 0;\r\nend if;\r\nreturn 1;\r\nend if;\r\nEND CheckName;','oracle regexp_like','','inherit','open','open','','192-revision-v1','','','2014-02-17 12:56:56','2014-02-17 04:56:56','',192,'http://localhost/wordpress/?p=193',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (195,1,'2014-03-11 16:32:49','2014-03-11 08:32:49','MQ和MB的特性，以及他们的区别与联系\r\n\r\n首先从概念上来说，MQ是消息中间件（号称：一旦发出保证送达），MB是ESB产品\r\n\r\nMQ负责在两个系统之间传递消息，这两个系统可以是异构的，处于不同硬件、不同操作系统、用不同语言编写，只需要简单的调用几个MQ的API，就可以互相通讯，你不必考虑底层系统和网络的复杂性。MQ作为IBM的一个拳头产品，虽然功能看上去很简单，就是个消息队列，但他却是IBM中间件的核心，也是相比其他厂商（比如BEA）的一个优势。MQ不仅有很高的性能，而且对各种平台的支持非常好，几乎你能想到的硬件和操作系统平台以及编程语言，MQ都有专门的API支持。\r\n\r\n但MQ的功能仅限于消息队列，至于应用A发给应用B的消息格式是怎样的、能不能被应用B解析，MQ管不了，他只是尽力将消息发到目的地（MQ能够应付多种异常情况，例如网络阻塞、临时中断等等）。此外，如果应用的数目多了，那互相之间都要建立MQ连接，网络拓扑就成了蜘蛛网了（就好像是最初的电话系统）\r\n\r\n因此，我们将网络的星型拓扑引入系统架构中，把一对一的MQ换成一个中心节点，即ESB，MB即是IBM的ESB产品。\r\n\r\nMB处于系统的中心，起到一个总线的作用，所有应用都直接连接到MB（一般是通过MB主动调应用），而不是应用之间直接互联，这样的好处不言而喻，可以极大的降低应用之间的耦合性。由此引出MB的两大核心功能：消息路由和数据转换\r\n因为各个应用都插入到MB上，所以应用A只管把消息丢给MB，MB自动根据消息字段、以及业务逻辑，判断要把消息交给谁，这就像路由器一样，根据数据包的头把包路由到相应地址。MB内部的业务逻辑由开发人员设定，当然利用MB的Toolkit，编写业务逻辑也非常简单：拖一些节点，用箭头把它们连起来，就像是画流程图一样，非常形象简单。再用MB的脚本语言（类似sql的脚本）实现逻辑判断，通俗地说就是判断要走哪个逻辑分支（if...else.....）。\r\n\r\n不过各个应用是怎样与MB连接的呢？MB提供了三种方式：MQ、文件和web service（好像不单三种http、tcp/ip）\r\n\r\nMQ方式即是利用MQ将MB与应用互联；文件方式则是指定某个目录，MB会自动监视那个文件目录，一旦文件有改变则认为是新的消息到来，MB自动读取指定文件的内容；而web service就不用解释了，直接利用web service进行通讯。MB支持这些互联方式也是为了最大化兼容性，特别是对于那些遗留系统或是不支持主流通讯方式的系统\r\n\r\n最后说说一个比较偏门的ESB产品：websphere ESB。听过的人可能不多，因为IBM在中国推广的比较少，这个WESB很像是MB的精简版，只支持JMS、WS等少数几种J2EE的通讯方式，所以是为J2EE专门准备的。不像MB，支持数十种平台和通讯方式，例如FTP，甚至很多你根本没听说过的很古老的通信协议。这两者的性能相差不少，价格也有三四倍的差距。更要命的是，原先在WESB上开发的东西，是不能迁移到MB使用的，IBM似乎铁了心要狠狠宰我们，唯一的方法是再买一个MB，然后用MQ把WESB和MB连接起来，各跑各的\r\n\r\n漏了一个DataPower，这东西我只是略有了解，它的卖点在于硬件支持XML，所以性能比较好，此外还支持一下web service安全方面的东东。因此，WESB是最小功能集，而MB与datapower功能上有一定重叠，如XML，可对数据进行格式转换（貌似还可以提供JAVA接口做更复杂的个性化的格式转换）',' IBM MB与MQ 对比','','publish','open','open','','ibm-mb%e4%b8%8emq-%e5%af%b9%e6%af%94','','','2014-03-11 16:33:00','2014-03-11 08:33:00','',0,'http://localhost/wordpress/?p=195',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (196,1,'2014-03-11 16:32:49','2014-03-11 08:32:49','MQ和MB的特性，以及他们的区别与联系\r\n\r\n首先从概念上来说，MQ是消息中间件（号称：一旦发出保证送达），MB是ESB产品\r\n\r\nMQ负责在两个系统之间传递消息，这两个系统可以是异构的，处于不同硬件、不同操作系统、用不同语言编写，只需要简单的调用几个MQ的API，就可以互相通讯，你不必考虑底层系统和网络的复杂性。MQ作为IBM的一个拳头产品，虽然功能看上去很简单，就是个消息队列，但他却是IBM中间件的核心，也是相比其他厂商（比如BEA）的一个优势。MQ不仅有很高的性能，而且对各种平台的支持非常好，几乎你能想到的硬件和操作系统平台以及编程语言，MQ都有专门的API支持。\r\n\r\n但MQ的功能仅限于消息队列，至于应用A发给应用B的消息格式是怎样的、能不能被应用B解析，MQ管不了，他只是尽力将消息发到目的地（MQ能够应付多种异常情况，例如网络阻塞、临时中断等等）。此外，如果应用的数目多了，那互相之间都要建立MQ连接，网络拓扑就成了蜘蛛网了（就好像是最初的电话系统）\r\n\r\n因此，我们将网络的星型拓扑引入系统架构中，把一对一的MQ换成一个中心节点，即ESB，MB即是IBM的ESB产品。\r\n\r\nMB处于系统的中心，起到一个总线的作用，所有应用都直接连接到MB（一般是通过MB主动调应用），而不是应用之间直接互联，这样的好处不言而喻，可以极大的降低应用之间的耦合性。由此引出MB的两大核心功能：消息路由和数据转换\r\n因为各个应用都插入到MB上，所以应用A只管把消息丢给MB，MB自动根据消息字段、以及业务逻辑，判断要把消息交给谁，这就像路由器一样，根据数据包的头把包路由到相应地址。MB内部的业务逻辑由开发人员设定，当然利用MB的Toolkit，编写业务逻辑也非常简单：拖一些节点，用箭头把它们连起来，就像是画流程图一样，非常形象简单。再用MB的脚本语言（类似sql的脚本）实现逻辑判断，通俗地说就是判断要走哪个逻辑分支（if...else.....）。\r\n\r\n不过各个应用是怎样与MB连接的呢？MB提供了三种方式：MQ、文件和web service（好像不单三种http、tcp/ip）\r\n\r\nMQ方式即是利用MQ将MB与应用互联；文件方式则是指定某个目录，MB会自动监视那个文件目录，一旦文件有改变则认为是新的消息到来，MB自动读取指定文件的内容；而web service就不用解释了，直接利用web service进行通讯。MB支持这些互联方式也是为了最大化兼容性，特别是对于那些遗留系统或是不支持主流通讯方式的系统\r\n\r\n最后说说一个比较偏门的ESB产品：websphere ESB。听过的人可能不多，因为IBM在中国推广的比较少，这个WESB很像是MB的精简版，只支持JMS、WS等少数几种J2EE的通讯方式，所以是为J2EE专门准备的。不像MB，支持数十种平台和通讯方式，例如FTP，甚至很多你根本没听说过的很古老的通信协议。这两者的性能相差不少，价格也有三四倍的差距。更要命的是，原先在WESB上开发的东西，是不能迁移到MB使用的，IBM似乎铁了心要狠狠宰我们，唯一的方法是再买一个MB，然后用MQ把WESB和MB连接起来，各跑各的\r\n\r\n漏了一个DataPower，这东西我只是略有了解，它的卖点在于硬件支持XML，所以性能比较好，此外还支持一下web service安全方面的东东。因此，WESB是最小功能集，而MB与datapower功能上有一定重叠，如XML，可对数据进行格式转换（貌似还可以提供JAVA接口做更复杂的个性化的格式转换）',' IBM MB与MQ 对比','','inherit','open','open','','195-revision-v1','','','2014-03-11 16:32:49','2014-03-11 08:32:49','',195,'http://localhost/wordpress/?p=196',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (197,1,'2014-03-11 16:33:55','2014-03-11 08:33:55','IBM ESB产品之间的比较（一）\r\n\r\n本文首先介绍了企业级应用程序的发展以及ESB的定义；随后，分析了ESB在SOA解决方案中所起的作用，并比较介绍了三款ESB产品在支持实现一个ESB解决方案中所起的作用。\r\n\r\n企业应用的发展概述\r\n\r\n在介绍企业服务总线之前，有必要花一些笔墨来介绍企业应用架构的发展和变迁。企业级应用架构的发展经历了以下几个阶段：\r\n\r\n·独立应用系统\r\n·EAI阶段\r\n·SOA阶段\r\n\r\n20世纪60到70年代，企业应用处于独立应用系统阶段，当时的企业应用是一种用来替代重复性劳动的简单设计，其目的是用计算机代替孤立的，体力性质的工作环节，将相关联的企业信息或数据管理起来。这些系统大部分是独立的系统——有独立的数据库、应用服务器、用户界面。因此有时候这类应用也叫“竖井型”的应用。\r\n\r\n但是，随着业务和信息的不断扩展，独立应用系统渐渐不能满足企业对IT的需求，表现在大量的信息冗余，因为在建立一个新的应用的时候需要重新建立一套数据库；功能的重新设计，相似的功能存在于多个系统中；例如，客户信息在一个公司中可能有多个拷贝分别存在于多个数据库中，不同时期建立的应用系统所使用的技术也会不同。对于获取客户资料这样的功能，必然存在于多个系统中，而且在不同的系统中其实现方式可能是Java/J2EE、Delphi、C/C++。\r\n\r\n20世纪80到90年代，一些公司或集成商意识到应用集成的价值和必要性。EAI是一种将多个不同平台、用不同方案建立的异构的应用集成的一种技术和方法。它的目标包括以下几个方面：各个分离的系统间的相互通讯，消除信息孤岛，实现信息的共享。从功能的角度来看，EAI包括信息接收、转换、翻译、路由、传播和业务流程管理。从架构上看有两种方式：Hub/Spoke方式和Bus方式。\r\n\r\n图1所示的Hub/Spoke结构使用一个中心代理（Hub）和多个适配器（Spoke）将Hub和应用连接起来。适配器负责将应用的数据格式转换成Hub可以理解的格式，Hub将数据再转换成目标系统可以理解的格式，并执行消息的路由。Hub/Spoke方式的弊端在于只有一个代理中心，当连接的应用种类增加或者消息量增大时，代理中心的性能将成为整个系统的瓶颈，在可扩展性方面也存在着一定的问题。\r\n\r\n\r\n\r\n图1. Hub/Spoke结构的EAI集成\r\n\r\n图2所示的Bus结构使用一个中心总线，应用程序通过Adapter将消息发送给总线，总线负责消息的路由，接受方的应用程序也有自己的Adapter来转换接受到的消息。Bus结构和Hub/Spoke结构的最大区别在于在Bus结构中，Adapter位于应用程序中，而Hub/Spoke结构中，Adapter由Hub来统一管理。这样在Bus结构中，加入一个新的应用变得很简单，可扩展性得到了很大的提高，但是应用程序方的负担加重了。\r\n\r\n\r\n\r\n图2. Bus结构的EAI集成\r\n\r\nSOA阶段\r\n\r\nSOA将应用资源看成一个个独立的，自包含并良好定义的服务，通过这些服务的组装，编排可以产生新的应用。每一个服务可以完成一个独立业务功能，并且不依赖于业务上下文或者其他服务的状态。服务的定义是标准的且被广泛支持的，比如Web Service。在SOA的架构中，人们都用标准的方式来封装自己的服务，使得任何一个客户端程序都可以容易的和后台系统实施连接。而ESB是SOA架构中的一个核心基石，在几乎所有的SOA架构中，都将ESB放在核心的位置。图3是IBM SOA Reference architecture，从中我们可以看出ESB在一个SOA架构中的地位，对该图的详细解释不在本文介绍范围之内，有兴趣的读者可以参考一下IBM SOA专区的相关文章。\r\n\r\n\r\n\r\n图3. IBM的SOA参考架构\r\n\r\n下面我们来介绍一下ESB。\r\n\r\n什么是ESB？ESB严格来说不是某一个产品，而是一种框架，设计模式。不同的提供商对ESB的理解也各有不同。\r\n\r\n“ESBs are essentially integration systems， not SOA systems. SOA is about tearing down application silos， but integration systems reinforce those silos. [...] an ESB is especially good for bridging to legacy applications， and therefore it is a useful component in a services infrastructure”\r\n\r\n----Anne Thomas Manes， Research Director with Burton Group\r\n\r\n“An Enterprise Service Bus (ESB) is a distributed middleware system for integrating enterprise IT assets using a service-oriented approach.”\r\n\r\n----Ron Ten-Hove ， Sun Microsystems and JBI Spec Lead\r\n\r\n“A Web-services-capable infrastructure that supports intelligently directed communication and mediated relationships among loosely coupled and decoupled business components.”\r\n\r\n--Gartner\r\n\r\n“An enterprise service bus (ESB) is a pattern of middleware that unifies and connects services， applications and resources within a business. Put another way， it is the framework within which the capabilities of a business\' applications are made available for reuse by other applications throughout the organization and beyond. The ESB is not a new software product — it\'s a new way of looking at how to integrate applications， coordinate resources and manipulate information ”\r\n\r\n从IBM的立场来说，ESB不仅仅是一个概念，而是一种中间件模式；它不是某个产品，而是一种全新的集成应用，协调资源和操纵信息的框架。\r\n\r\n下面来介绍ESB或可以称为ESB的中间件产品保护一些特征，有些是必须的，有些是可选的：\r\n\r\nESB必须提供一种支持服务交互的桥梁，它必须支持多协议(protocol)之间的连接。不仅要提供对消息和面向事件的中间件的支持，还要提供和现有EAI技术的连接。连接性是ESB不可缺少的特征之一。\r\n\r\n服务交互可以理解为ESB的一个目的之一，ESB作为SOA架构的核心，必然要支持服务的交互，要在服务的请求者和提供者架起一个坚实的桥梁，让服务的请求者和提供者只需要关心各自的业务逻辑，而不需要在发布和消费服务的环节花很大力气。服务交互也是ESB的必备特征。\r\n\r\n集成的概念是对于系统而言的，ESB不仅要能集成那些很容易封装服务的系统，也要集成不能方便地封装服务的系统，例如SAP， ERP， CRM， Siebel等EAI系统、遗留系统。集成也是ESB的核心特征之一。\r\n\r\n在集成的过程中，必须要面对的是消息处理，在不同的应用系统中，消息的描述格式是不一样的。在集成环境中，必须要提供一种统一的格式来处理系统间的交互，从ASBO(Application Specific Business Object)到GBO(Generic Business Object) 之间的互转是ESB的核心特征之一。\r\n\r\n对于一个具有ESB特征的产品，管理也是一个重要的方面。例如，当一个服务从一个地址切换到另一个地址，在结构等不发生任何改变的时候，ESB产品应该提供一个方便的途径适应这种改变。\r\n\r\n对于服务交互来说，QoS也是一个重要的特征，比如针对不同的服务请求者提供不同质量的服务响应。有些服务的请求需要在事务中完成，有些服务的交互需要保证其可靠性。一个ESB产品应该提供给开发者定义QoS的接口。\r\n\r\n安全的必要性不言而喻，系统和系统之间的交互必然需要认证，授权，加密，签名等安全性。一个优秀的ESB产品应该提供可靠的，可灵活配置的安全支持。\r\n\r\nIBM有三款ESB产品：WebSphere ESB(WESB)，WebSphere Message Broker(WMB)，DataPower。这三款ESB产品都提供了ESB所必备的特征，但是它们各有侧重，WESB主要构建与WebSphere Application Server之上，侧重于对标准协议和消息的支持，更适合于J2EE，Web-Service为主要特征的集成环境；WMB提供了一个高级的ESB，它构建于WebSphere Message Queue之上，提供了百种以上协议的连接和数据格式的转换机制。Datapower是一款比较新的ESB产品，除了提供必备的ESB的特性之外，Datapower更侧重于安全。众所周知，在XML的环境中，安全对于性能的影响是巨大的，Datapower给企业ESB提供了强大的安全保障。下面分别介绍这三款ESB产品。\r\n\r\nWebSphere ESB\r\n\r\n从图4中可以看出ESB构建与WAS ND之上，它使用了WAS ND及WAS对于安全，用户注册表，事务，消息引擎的支持，在其之上增加了对服务集成、消息流处理、建模以及ESB编程模型的支持等等。从图中还可以看出WebSphere Process Server是构建与WESB之上，并扩展了服务编排和流程管理方面的支持。\r\n\r\n\r\n\r\n图4. WESB在WAS产品线的位置\r\n\r\n下面介绍在WESB上实现一个SOA ESB解决方案上的以下九个方面的特点，这九个方面的特点来源于上文中介绍的ESB的特性，或者特性的细化：\r\n\r\nWESB所处理的消息为XML格式的数据，对于非XML结构的数据WESB不能处理。对于XML结构的数据，在WESB的消息流中数据以SMO形式存在，WESB可以对XML消息树的内容进行修改，包括改变某个节点的内容，增加新的节点以及删除某个节点等等。\r\n\r\nWESB支持符合SOA标准的协议，比如SOAP/HTTP、SOAP/JMS、WSDL V1.1、UDDI V3.0，WebSphere MQ等。也就是说WESB目前只支持SOAP方式来描述服务，传输协议可以是HTTP、JMS记忆原生的WebSphere MQ的连接。对于多传输协议的基础，建议使用MB来做ESB的解决方案，参考MB的介绍部分。\r\n\r\n消息的路由在WESB中有良好的支持，开发环境WID中提供了一个节点专门来负责消息路由，WID也提供了良好的对路由规则定义的开发支持，开发人员可以很容易的定制负责的路由规则。若要实现动态路由的功能，则需要和一个服务的存储单元中来动态的查找服务，目前WSRR是一款优秀的提供该功能的工具。WESB从V6.1开始提供了Endpoint lookup节点来支持WSRR的集成，简化了开发过程。如果要实现简单的动态服务路由的功能，则可把服务的定义存放在数据库中，在WESB中通过DB lookup来查找服务的 Endpoint， 然后注入到消息流中，WESB V6.1之前的版本就已经支持与数据库的集成。\r\n\r\nWESB天生运行在J2EE的环境里面，对Web Service有着天然的支持。\r\n\r\n在消息流中，我们需要跟踪消息各节点的状态，以满足统计和出错处理的要求，在WESB中，通过CEI机制来处理消息。\r\n\r\n·与遗留系统的集成\r\n\r\nWESB通过Adapter与遗留系统进行集成，支持IBM Websphere Adapter和JCA Adapter，通过JCA我们就可以将遗留系统里面的服务和数据通过标准（SCA/SDO）的形式整合到集成环境中。\r\n\r\nWESB没有对安全做特殊的处理，使用WAS的安全支持来实现ESB的安全。\r\n\r\nWESB是一个纯Java的应用，运行效率上有些限制，同时可以处理的消息流的数量级为几十到几百之间。\r\n\r\n开发工具是WID，一个ESB的消息流在WID中被称为Mediation Module，它是一个J2EE应用，开发和部署工作无异于普通的企业级应用。\r\n\r\nWMB是IBM的应用整合中间件，是IBM ESB架构重要的产品组成部分之一，用于企业应用整合领域。WMB目前的版本是6.1.2，它的前身是MQSeries Integrator。本质上看，WMB是MQ的衍生产品，它使用MQ作为内部通信的机制。然后，WMB提供的接入方式远不止MQ一种，包括JMS、HTTP(S)、SCADA等常见的新一代接口规范。在消息转化过程中，WMB能够识别XML、C结构、SOAP等各种自定义的消息格式。\r\n\r\n如图5所示，WMB可以分为开发环境和运行环境两大部分。其中开发环境由开发工具（Toolkit）和调试环境（Rational Agent Controller）组成，运行环境是WMB核心，也叫Broker Domain，由三部分组成，配置管理器（Configuration Manager）、用户名服务器（User Name Server）和代理（Broker）。\r\n\r\n\r\n\r\n图5. WMB组件\r\n原文出处：http://www.ibm.com/developerworks/cn/webservices/0811_magy_esb/index.html','IBM ESB 产品一览','','publish','open','open','','ibm-esb-%e4%ba%a7%e5%93%81%e4%b8%80%e8%a7%88','','','2014-03-11 16:33:55','2014-03-11 08:33:55','',0,'http://localhost/wordpress/?p=197',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (198,1,'2014-03-11 16:33:55','2014-03-11 08:33:55','IBM ESB产品之间的比较（一）\r\n\r\n本文首先介绍了企业级应用程序的发展以及ESB的定义；随后，分析了ESB在SOA解决方案中所起的作用，并比较介绍了三款ESB产品在支持实现一个ESB解决方案中所起的作用。\r\n\r\n企业应用的发展概述\r\n\r\n在介绍企业服务总线之前，有必要花一些笔墨来介绍企业应用架构的发展和变迁。企业级应用架构的发展经历了以下几个阶段：\r\n\r\n·独立应用系统\r\n·EAI阶段\r\n·SOA阶段\r\n\r\n20世纪60到70年代，企业应用处于独立应用系统阶段，当时的企业应用是一种用来替代重复性劳动的简单设计，其目的是用计算机代替孤立的，体力性质的工作环节，将相关联的企业信息或数据管理起来。这些系统大部分是独立的系统——有独立的数据库、应用服务器、用户界面。因此有时候这类应用也叫“竖井型”的应用。\r\n\r\n但是，随着业务和信息的不断扩展，独立应用系统渐渐不能满足企业对IT的需求，表现在大量的信息冗余，因为在建立一个新的应用的时候需要重新建立一套数据库；功能的重新设计，相似的功能存在于多个系统中；例如，客户信息在一个公司中可能有多个拷贝分别存在于多个数据库中，不同时期建立的应用系统所使用的技术也会不同。对于获取客户资料这样的功能，必然存在于多个系统中，而且在不同的系统中其实现方式可能是Java/J2EE、Delphi、C/C++。\r\n\r\n20世纪80到90年代，一些公司或集成商意识到应用集成的价值和必要性。EAI是一种将多个不同平台、用不同方案建立的异构的应用集成的一种技术和方法。它的目标包括以下几个方面：各个分离的系统间的相互通讯，消除信息孤岛，实现信息的共享。从功能的角度来看，EAI包括信息接收、转换、翻译、路由、传播和业务流程管理。从架构上看有两种方式：Hub/Spoke方式和Bus方式。\r\n\r\n图1所示的Hub/Spoke结构使用一个中心代理（Hub）和多个适配器（Spoke）将Hub和应用连接起来。适配器负责将应用的数据格式转换成Hub可以理解的格式，Hub将数据再转换成目标系统可以理解的格式，并执行消息的路由。Hub/Spoke方式的弊端在于只有一个代理中心，当连接的应用种类增加或者消息量增大时，代理中心的性能将成为整个系统的瓶颈，在可扩展性方面也存在着一定的问题。\r\n\r\n\r\n\r\n图1. Hub/Spoke结构的EAI集成\r\n\r\n图2所示的Bus结构使用一个中心总线，应用程序通过Adapter将消息发送给总线，总线负责消息的路由，接受方的应用程序也有自己的Adapter来转换接受到的消息。Bus结构和Hub/Spoke结构的最大区别在于在Bus结构中，Adapter位于应用程序中，而Hub/Spoke结构中，Adapter由Hub来统一管理。这样在Bus结构中，加入一个新的应用变得很简单，可扩展性得到了很大的提高，但是应用程序方的负担加重了。\r\n\r\n\r\n\r\n图2. Bus结构的EAI集成\r\n\r\nSOA阶段\r\n\r\nSOA将应用资源看成一个个独立的，自包含并良好定义的服务，通过这些服务的组装，编排可以产生新的应用。每一个服务可以完成一个独立业务功能，并且不依赖于业务上下文或者其他服务的状态。服务的定义是标准的且被广泛支持的，比如Web Service。在SOA的架构中，人们都用标准的方式来封装自己的服务，使得任何一个客户端程序都可以容易的和后台系统实施连接。而ESB是SOA架构中的一个核心基石，在几乎所有的SOA架构中，都将ESB放在核心的位置。图3是IBM SOA Reference architecture，从中我们可以看出ESB在一个SOA架构中的地位，对该图的详细解释不在本文介绍范围之内，有兴趣的读者可以参考一下IBM SOA专区的相关文章。\r\n\r\n\r\n\r\n图3. IBM的SOA参考架构\r\n\r\n下面我们来介绍一下ESB。\r\n\r\n什么是ESB？ESB严格来说不是某一个产品，而是一种框架，设计模式。不同的提供商对ESB的理解也各有不同。\r\n\r\n“ESBs are essentially integration systems， not SOA systems. SOA is about tearing down application silos， but integration systems reinforce those silos. [...] an ESB is especially good for bridging to legacy applications， and therefore it is a useful component in a services infrastructure”\r\n\r\n----Anne Thomas Manes， Research Director with Burton Group\r\n\r\n“An Enterprise Service Bus (ESB) is a distributed middleware system for integrating enterprise IT assets using a service-oriented approach.”\r\n\r\n----Ron Ten-Hove ， Sun Microsystems and JBI Spec Lead\r\n\r\n“A Web-services-capable infrastructure that supports intelligently directed communication and mediated relationships among loosely coupled and decoupled business components.”\r\n\r\n--Gartner\r\n\r\n“An enterprise service bus (ESB) is a pattern of middleware that unifies and connects services， applications and resources within a business. Put another way， it is the framework within which the capabilities of a business\' applications are made available for reuse by other applications throughout the organization and beyond. The ESB is not a new software product — it\'s a new way of looking at how to integrate applications， coordinate resources and manipulate information ”\r\n\r\n从IBM的立场来说，ESB不仅仅是一个概念，而是一种中间件模式；它不是某个产品，而是一种全新的集成应用，协调资源和操纵信息的框架。\r\n\r\n下面来介绍ESB或可以称为ESB的中间件产品保护一些特征，有些是必须的，有些是可选的：\r\n\r\nESB必须提供一种支持服务交互的桥梁，它必须支持多协议(protocol)之间的连接。不仅要提供对消息和面向事件的中间件的支持，还要提供和现有EAI技术的连接。连接性是ESB不可缺少的特征之一。\r\n\r\n服务交互可以理解为ESB的一个目的之一，ESB作为SOA架构的核心，必然要支持服务的交互，要在服务的请求者和提供者架起一个坚实的桥梁，让服务的请求者和提供者只需要关心各自的业务逻辑，而不需要在发布和消费服务的环节花很大力气。服务交互也是ESB的必备特征。\r\n\r\n集成的概念是对于系统而言的，ESB不仅要能集成那些很容易封装服务的系统，也要集成不能方便地封装服务的系统，例如SAP， ERP， CRM， Siebel等EAI系统、遗留系统。集成也是ESB的核心特征之一。\r\n\r\n在集成的过程中，必须要面对的是消息处理，在不同的应用系统中，消息的描述格式是不一样的。在集成环境中，必须要提供一种统一的格式来处理系统间的交互，从ASBO(Application Specific Business Object)到GBO(Generic Business Object) 之间的互转是ESB的核心特征之一。\r\n\r\n对于一个具有ESB特征的产品，管理也是一个重要的方面。例如，当一个服务从一个地址切换到另一个地址，在结构等不发生任何改变的时候，ESB产品应该提供一个方便的途径适应这种改变。\r\n\r\n对于服务交互来说，QoS也是一个重要的特征，比如针对不同的服务请求者提供不同质量的服务响应。有些服务的请求需要在事务中完成，有些服务的交互需要保证其可靠性。一个ESB产品应该提供给开发者定义QoS的接口。\r\n\r\n安全的必要性不言而喻，系统和系统之间的交互必然需要认证，授权，加密，签名等安全性。一个优秀的ESB产品应该提供可靠的，可灵活配置的安全支持。\r\n\r\nIBM有三款ESB产品：WebSphere ESB(WESB)，WebSphere Message Broker(WMB)，DataPower。这三款ESB产品都提供了ESB所必备的特征，但是它们各有侧重，WESB主要构建与WebSphere Application Server之上，侧重于对标准协议和消息的支持，更适合于J2EE，Web-Service为主要特征的集成环境；WMB提供了一个高级的ESB，它构建于WebSphere Message Queue之上，提供了百种以上协议的连接和数据格式的转换机制。Datapower是一款比较新的ESB产品，除了提供必备的ESB的特性之外，Datapower更侧重于安全。众所周知，在XML的环境中，安全对于性能的影响是巨大的，Datapower给企业ESB提供了强大的安全保障。下面分别介绍这三款ESB产品。\r\n\r\nWebSphere ESB\r\n\r\n从图4中可以看出ESB构建与WAS ND之上，它使用了WAS ND及WAS对于安全，用户注册表，事务，消息引擎的支持，在其之上增加了对服务集成、消息流处理、建模以及ESB编程模型的支持等等。从图中还可以看出WebSphere Process Server是构建与WESB之上，并扩展了服务编排和流程管理方面的支持。\r\n\r\n\r\n\r\n图4. WESB在WAS产品线的位置\r\n\r\n下面介绍在WESB上实现一个SOA ESB解决方案上的以下九个方面的特点，这九个方面的特点来源于上文中介绍的ESB的特性，或者特性的细化：\r\n\r\nWESB所处理的消息为XML格式的数据，对于非XML结构的数据WESB不能处理。对于XML结构的数据，在WESB的消息流中数据以SMO形式存在，WESB可以对XML消息树的内容进行修改，包括改变某个节点的内容，增加新的节点以及删除某个节点等等。\r\n\r\nWESB支持符合SOA标准的协议，比如SOAP/HTTP、SOAP/JMS、WSDL V1.1、UDDI V3.0，WebSphere MQ等。也就是说WESB目前只支持SOAP方式来描述服务，传输协议可以是HTTP、JMS记忆原生的WebSphere MQ的连接。对于多传输协议的基础，建议使用MB来做ESB的解决方案，参考MB的介绍部分。\r\n\r\n消息的路由在WESB中有良好的支持，开发环境WID中提供了一个节点专门来负责消息路由，WID也提供了良好的对路由规则定义的开发支持，开发人员可以很容易的定制负责的路由规则。若要实现动态路由的功能，则需要和一个服务的存储单元中来动态的查找服务，目前WSRR是一款优秀的提供该功能的工具。WESB从V6.1开始提供了Endpoint lookup节点来支持WSRR的集成，简化了开发过程。如果要实现简单的动态服务路由的功能，则可把服务的定义存放在数据库中，在WESB中通过DB lookup来查找服务的 Endpoint， 然后注入到消息流中，WESB V6.1之前的版本就已经支持与数据库的集成。\r\n\r\nWESB天生运行在J2EE的环境里面，对Web Service有着天然的支持。\r\n\r\n在消息流中，我们需要跟踪消息各节点的状态，以满足统计和出错处理的要求，在WESB中，通过CEI机制来处理消息。\r\n\r\n·与遗留系统的集成\r\n\r\nWESB通过Adapter与遗留系统进行集成，支持IBM Websphere Adapter和JCA Adapter，通过JCA我们就可以将遗留系统里面的服务和数据通过标准（SCA/SDO）的形式整合到集成环境中。\r\n\r\nWESB没有对安全做特殊的处理，使用WAS的安全支持来实现ESB的安全。\r\n\r\nWESB是一个纯Java的应用，运行效率上有些限制，同时可以处理的消息流的数量级为几十到几百之间。\r\n\r\n开发工具是WID，一个ESB的消息流在WID中被称为Mediation Module，它是一个J2EE应用，开发和部署工作无异于普通的企业级应用。\r\n\r\nWMB是IBM的应用整合中间件，是IBM ESB架构重要的产品组成部分之一，用于企业应用整合领域。WMB目前的版本是6.1.2，它的前身是MQSeries Integrator。本质上看，WMB是MQ的衍生产品，它使用MQ作为内部通信的机制。然后，WMB提供的接入方式远不止MQ一种，包括JMS、HTTP(S)、SCADA等常见的新一代接口规范。在消息转化过程中，WMB能够识别XML、C结构、SOAP等各种自定义的消息格式。\r\n\r\n如图5所示，WMB可以分为开发环境和运行环境两大部分。其中开发环境由开发工具（Toolkit）和调试环境（Rational Agent Controller）组成，运行环境是WMB核心，也叫Broker Domain，由三部分组成，配置管理器（Configuration Manager）、用户名服务器（User Name Server）和代理（Broker）。\r\n\r\n\r\n\r\n图5. WMB组件\r\n原文出处：http://www.ibm.com/developerworks/cn/webservices/0811_magy_esb/index.html','IBM ESB 产品一览','','inherit','open','open','','197-revision-v1','','','2014-03-11 16:33:55','2014-03-11 08:33:55','',197,'http://localhost/wordpress/?p=198',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (199,1,'2014-03-24 21:49:24','2014-03-24 13:49:24','Multi-table Insert, Inserting into mutiple target table when a given condition match or insert into all tables the same data\r\nSyntax\r\n\r\n{INSERT {ALL | FIRST}\r\n[WHEN &lt;condition-1&gt; THEN]\r\nINTO &lt;table1&gt; [(col1, col2�.)]\r\n[VALUES (val1, val2�..)]\r\n\r\n[WHEN &lt;condition-2&gt; THEN]\r\nINTO &lt;table2&gt; [(col1, col2�.)]\r\n[VALUES (val1, val3�..)]\r\n.\r\n.\r\n[WHEN &lt;condition-n&gt; THEN]\r\nINTO &lt;table2&gt; [(col1, col2�.)]\r\n[VALUES (val1, val3�..)]\r\n\r\n[ELSE\r\nINTO &lt;table3&gt; [(col1, col2�.)]\r\n[VALUES (val5, val6�..)]\r\n]\r\n{Sub-query-definition}\r\n}\r\n\r\n--------------------etc---------\r\nInsert command:\r\n\r\nINSERT ALL\r\nWHEN column3 like �Smith� THEN\r\nINTO EMP_TARGET (EID, NAME)\r\n[VALUES (column1, column2)]\r\nELSE\r\nINTO logtable (ID, NAME, SALARY, DESCRIPTION)\r\nVALUES (column1, column2, column4, ERR_MSG)\r\n\r\nSELECT t1.ID AS column1, (t1.FNAME|| t1.LNAME) AS column2,\r\nt1.LNAME AS column3, t2.SALARY AS column4\r\nFROM EMP t1, SALARY t2\r\nINNER JOIN ON (t1.ID = t2.EID)\r\nWHERE (t1.ID &gt; 1000 AND t2.SALARY &gt; 5000)','OCP 047-001 oracle 多表插入','','publish','open','open','','ocp-047-oracle-%e5%a4%9a%e8%a1%a8%e6%8f%92%e5%85%a5','','','2014-03-24 22:25:58','2014-03-24 14:25:58','',0,'http://localhost/wordpress/?p=199',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (200,1,'2014-03-24 21:49:24','2014-03-24 13:49:24','Multi-table Insert, Inserting into mutiple target table when a given condition match or insert into all tables the same data\r\nSyntax\r\n\r\n{INSERT {ALL | FIRST}\r\n[WHEN &lt;condition-1&gt; THEN]\r\nINTO &lt;table1&gt; [(col1, col2�.)]\r\n[VALUES (val1, val2�..)]\r\n\r\n\r\n[WHEN &lt;condition-2&gt; THEN]\r\nINTO &lt;table2&gt; [(col1, col2�.)]\r\n[VALUES (val1, val3�..)]\r\n.\r\n.\r\n[WHEN &lt;condition-n&gt; THEN]\r\nINTO &lt;table2&gt; [(col1, col2�.)]\r\n[VALUES (val1, val3�..)]\r\n\r\n\r\n[ELSE\r\nINTO &lt;table3&gt; [(col1, col2�.)]\r\n[VALUES (val5, val6�..)]\r\n]\r\n{Sub-query-definition}\r\n}\r\n\r\n--------------------etc---------\r\nInsert command:\r\n\r\nINSERT ALL\r\nWHEN column3 like �Smith� THEN\r\nINTO EMP_TARGET (EID, NAME)\r\n[VALUES (column1, column2)]\r\nELSE\r\nINTO logtable (ID, NAME, SALARY, DESCRIPTION)\r\nVALUES (column1, column2, column4, ERR_MSG)\r\n\r\n\r\nSELECT t1.ID AS column1, (t1.FNAME|| t1.LNAME) AS column2,\r\nt1.LNAME AS column3, t2.SALARY AS column4\r\nFROM EMP t1, SALARY t2\r\nINNER JOIN ON (t1.ID = t2.EID)\r\nWHERE (t1.ID &gt; 1000 AND t2.SALARY &gt; 5000)','OCP 047 oracle 多表插入','','inherit','open','open','','199-revision-v1','','','2014-03-24 21:49:24','2014-03-24 13:49:24','',199,'http://localhost/wordpress/?p=200',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (203,1,'2014-03-24 22:19:19','2014-03-24 14:19:19','Multi-table Insert, Inserting into mutiple target table when a given condition match or insert into all tables the same data\r\nSyntax\r\n\r\n{INSERT {ALL | FIRST}\r\n[WHEN &lt;condition-1&gt; THEN]\r\nINTO &lt;table1&gt; [(col1, col2�.)]\r\n[VALUES (val1, val2�..)]\r\n\r\n[WHEN &lt;condition-2&gt; THEN]\r\nINTO &lt;table2&gt; [(col1, col2�.)]\r\n[VALUES (val1, val3�..)]\r\n.\r\n.\r\n[WHEN &lt;condition-n&gt; THEN]\r\nINTO &lt;table2&gt; [(col1, col2�.)]\r\n[VALUES (val1, val3�..)]\r\n\r\n[ELSE\r\nINTO &lt;table3&gt; [(col1, col2�.)]\r\n[VALUES (val5, val6�..)]\r\n]\r\n{Sub-query-definition}\r\n}\r\n\r\n--------------------etc---------\r\nInsert command:\r\n\r\nINSERT ALL\r\nWHEN column3 like �Smith� THEN\r\nINTO EMP_TARGET (EID, NAME)\r\n[VALUES (column1, column2)]\r\nELSE\r\nINTO logtable (ID, NAME, SALARY, DESCRIPTION)\r\nVALUES (column1, column2, column4, ERR_MSG)\r\n\r\nSELECT t1.ID AS column1, (t1.FNAME|| t1.LNAME) AS column2,\r\nt1.LNAME AS column3, t2.SALARY AS column4\r\nFROM EMP t1, SALARY t2\r\nINNER JOIN ON (t1.ID = t2.EID)\r\nWHERE (t1.ID &gt; 1000 AND t2.SALARY &gt; 5000)','OCP 047 oracle 多表插入 1','','inherit','open','open','','199-revision-v1','','','2014-03-24 22:19:19','2014-03-24 14:19:19','',199,'http://localhost/wordpress/?p=203',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (205,1,'2014-03-24 22:20:39','2014-03-24 14:20:39','oracle regexp_like介绍和例子\r\n\r\nORACLE中的支持正则表达式的函数主要有下面四个：\r\n1，REGEXP_LIKE ：与LIKE的功能相似\r\n2，REGEXP_INSTR ：与INSTR的功能相似\r\n3，REGEXP_SUBSTR ：与SUBSTR的功能相似\r\n4，REGEXP_REPLACE ：与REPLACE的功能相似\r\n它们在用法上与Oracle SQL 函数LIKE、INSTR、SUBSTR 和REPLACE 用法相同，\r\n但是它们使用POSIX 正则表达式代替了老的百分号（%）和通配符（_）字符。\r\nPOSIX 正则表达式由标准的元字符（metacharacters）所构成：\r\n\'^\' 匹配输入字符串的开始位置，在方括号表达式中使用，此时它表示不接受该字符集合。\r\n\'$\' 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹\r\n配 \'\\n\' 或 \'\\r\'。\r\n\'.\' 匹配除换行符之外的任何单字符。\r\n\'?\' 匹配前面的子表达式零次或一次。\r\n\'+\' 匹配前面的子表达式一次或多次。\r\n\'*\' 匹配前面的子表达式零次或多次。\r\n\'|\' 指明两项之间的一个选择。例子\'^([a-z]+|[0-9]+)$\'表示所有小写字母或数字组合成的\r\n字符串。\r\n\'( )\' 标记一个子表达式的开始和结束位置。\r\n\'[]\' 标记一个中括号表达式。\r\n\'{m,n}\' 一个精确地出现次数范围，m=&lt;出现次数&lt;=n，\'{m}\'表示出现m次，\'{m,}\'表示至少\r\n出现m次。\r\n\\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。\r\n字符簇：\r\n[[:alpha:]] 任何字母。\r\n[[:digit:]] 任何数字。\r\n[[:alnum:]] 任何字母和数字。\r\n[[:space:]] 任何白字符。\r\n[[:upper:]] 任何大写字母。\r\n[[:lower:]] 任何小写字母。\r\n[[:punct:]] 任何标点符号。\r\n[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]。\r\n各种操作符的运算优先级\r\n\\转义符\r\n(), (?:), (?=), [] 圆括号和方括号\r\n*, +, ?, {n}, {n,}, {n,m} 限定符\r\n^, $, anymetacharacter 位置和顺序\r\n|\r\n*/\r\n--创建表\r\ncreate table fzq\r\n(\r\nid varchar(4),\r\nvalue varchar(10)\r\n);\r\n--数据插入\r\ninsert into fzq values\r\n(\'1\',\'1234560\');\r\ninsert into fzq values\r\n(\'2\',\'1234560\');\r\ninsert into fzq values\r\n(\'3\',\'1b3b560\');\r\ninsert into fzq values\r\n(\'4\',\'abc\');\r\ninsert into fzq values\r\n(\'5\',\'abcde\');\r\ninsert into fzq values\r\n(\'6\',\'ADREasx\');\r\ninsert into fzq values\r\n(\'7\',\'123 45\');\r\ninsert into fzq values\r\n(\'8\',\'adc de\');\r\ninsert into fzq values\r\n(\'9\',\'adc,.de\');\r\ninsert into fzq values\r\n(\'10\',\'1B\');\r\ninsert into fzq values\r\n(\'10\',\'abcbvbnb\');\r\ninsert into fzq values\r\n(\'11\',\'11114560\');\r\ninsert into fzq values\r\n(\'11\',\'11124560\');\r\n--regexp_like\r\n--查询value中以1开头60结束的记录并且长度是7位\r\nselect * from fzq where value like \'1____60\';\r\nselect * from fzq where regexp_like(value,\'1....60\');\r\n--查询value中以1开头60结束的记录并且长度是7位并且全部是数字的记录。\r\n--使用like就不是很好实现了。\r\nselect * from fzq where regexp_like(value,\'1[0-9]{4}60\');\r\n-- 也可以这样实现，使用字符集。\r\nselect * from fzq where regexp_like(value,\'1[[:digit:]]{4}60\');\r\n-- 查询value中不是纯数字的记录\r\nselect * from fzq where not regexp_like(value,\'^[[:digit:]]+$\');\r\n-- 查询value中不包含任何数字的记录。\r\nselect * from fzq where regexp_like(value,\'^[^[:digit:]]+$\');\r\n--查询以12或者1b开头的记录.不区分大小写。\r\nselect * from fzq where regexp_like(value,\'^1[2b]\',\'i\');\r\n--查询以12或者1b开头的记录.区分大小写。\r\nselect * from fzq where regexp_like(value,\'^1[2B]\');\r\n-- 查询数据中包含空白的记录。\r\nselect * from fzq where regexp_like(value,\'[[:space:]]\');\r\n--查询所有包含小写字母或者数字的记录。\r\nselect * from fzq where regexp_like(value,\'^([a-z]+|[0-9]+)$\');\r\n--查询任何包含标点符号的记录。\r\nselect * from fzq where regexp_like(value,\'[[:punct:]]\');\r\n\r\n例子：判断姓名是否为空，少于两个字符，包含数字和字母\r\n\r\ncreate or replace\r\nFUNCTION CheckName(NameStr in VARCHAR2) RETURN integer\r\nAs\r\nBEGIN\r\n--符合返回1，不符合返回0\r\nif(NameStr is null or length(NameStr)&lt;2) then\r\nreturn 0;\r\nelse\r\nif(NameStr like \'%未取名%\') then\r\nRETURN 0;\r\nend if;\r\nif regexp_like(NameStr,\'^([a-z]+|[0-9]+|[A-Z]+)$\') then\r\nreturn 0;\r\nend if;\r\nreturn 1;\r\nend if;\r\nEND CheckName;','OCP 047 REGEXP_LIKE 2','','inherit','open','open','','192-revision-v1','','','2014-03-24 22:20:39','2014-03-24 14:20:39','',192,'http://localhost/wordpress/?p=205',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (206,1,'2014-03-24 22:20:55','2014-03-24 14:20:55','oracle regexp_like介绍和例子\r\n\r\nORACLE中的支持正则表达式的函数主要有下面四个：\r\n1，REGEXP_LIKE ：与LIKE的功能相似\r\n2，REGEXP_INSTR ：与INSTR的功能相似\r\n3，REGEXP_SUBSTR ：与SUBSTR的功能相似\r\n4，REGEXP_REPLACE ：与REPLACE的功能相似\r\n它们在用法上与Oracle SQL 函数LIKE、INSTR、SUBSTR 和REPLACE 用法相同，\r\n但是它们使用POSIX 正则表达式代替了老的百分号（%）和通配符（_）字符。\r\nPOSIX 正则表达式由标准的元字符（metacharacters）所构成：\r\n\'^\' 匹配输入字符串的开始位置，在方括号表达式中使用，此时它表示不接受该字符集合。\r\n\'$\' 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹\r\n配 \'\\n\' 或 \'\\r\'。\r\n\'.\' 匹配除换行符之外的任何单字符。\r\n\'?\' 匹配前面的子表达式零次或一次。\r\n\'+\' 匹配前面的子表达式一次或多次。\r\n\'*\' 匹配前面的子表达式零次或多次。\r\n\'|\' 指明两项之间的一个选择。例子\'^([a-z]+|[0-9]+)$\'表示所有小写字母或数字组合成的\r\n字符串。\r\n\'( )\' 标记一个子表达式的开始和结束位置。\r\n\'[]\' 标记一个中括号表达式。\r\n\'{m,n}\' 一个精确地出现次数范围，m=&lt;出现次数&lt;=n，\'{m}\'表示出现m次，\'{m,}\'表示至少\r\n出现m次。\r\n\\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。\r\n字符簇：\r\n[[:alpha:]] 任何字母。\r\n[[:digit:]] 任何数字。\r\n[[:alnum:]] 任何字母和数字。\r\n[[:space:]] 任何白字符。\r\n[[:upper:]] 任何大写字母。\r\n[[:lower:]] 任何小写字母。\r\n[[:punct:]] 任何标点符号。\r\n[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]。\r\n各种操作符的运算优先级\r\n\\转义符\r\n(), (?:), (?=), [] 圆括号和方括号\r\n*, +, ?, {n}, {n,}, {n,m} 限定符\r\n^, $, anymetacharacter 位置和顺序\r\n|\r\n*/\r\n--创建表\r\ncreate table fzq\r\n(\r\nid varchar(4),\r\nvalue varchar(10)\r\n);\r\n--数据插入\r\ninsert into fzq values\r\n(\'1\',\'1234560\');\r\ninsert into fzq values\r\n(\'2\',\'1234560\');\r\ninsert into fzq values\r\n(\'3\',\'1b3b560\');\r\ninsert into fzq values\r\n(\'4\',\'abc\');\r\ninsert into fzq values\r\n(\'5\',\'abcde\');\r\ninsert into fzq values\r\n(\'6\',\'ADREasx\');\r\ninsert into fzq values\r\n(\'7\',\'123 45\');\r\ninsert into fzq values\r\n(\'8\',\'adc de\');\r\ninsert into fzq values\r\n(\'9\',\'adc,.de\');\r\ninsert into fzq values\r\n(\'10\',\'1B\');\r\ninsert into fzq values\r\n(\'10\',\'abcbvbnb\');\r\ninsert into fzq values\r\n(\'11\',\'11114560\');\r\ninsert into fzq values\r\n(\'11\',\'11124560\');\r\n--regexp_like\r\n--查询value中以1开头60结束的记录并且长度是7位\r\nselect * from fzq where value like \'1____60\';\r\nselect * from fzq where regexp_like(value,\'1....60\');\r\n--查询value中以1开头60结束的记录并且长度是7位并且全部是数字的记录。\r\n--使用like就不是很好实现了。\r\nselect * from fzq where regexp_like(value,\'1[0-9]{4}60\');\r\n-- 也可以这样实现，使用字符集。\r\nselect * from fzq where regexp_like(value,\'1[[:digit:]]{4}60\');\r\n-- 查询value中不是纯数字的记录\r\nselect * from fzq where not regexp_like(value,\'^[[:digit:]]+$\');\r\n-- 查询value中不包含任何数字的记录。\r\nselect * from fzq where regexp_like(value,\'^[^[:digit:]]+$\');\r\n--查询以12或者1b开头的记录.不区分大小写。\r\nselect * from fzq where regexp_like(value,\'^1[2b]\',\'i\');\r\n--查询以12或者1b开头的记录.区分大小写。\r\nselect * from fzq where regexp_like(value,\'^1[2B]\');\r\n-- 查询数据中包含空白的记录。\r\nselect * from fzq where regexp_like(value,\'[[:space:]]\');\r\n--查询所有包含小写字母或者数字的记录。\r\nselect * from fzq where regexp_like(value,\'^([a-z]+|[0-9]+)$\');\r\n--查询任何包含标点符号的记录。\r\nselect * from fzq where regexp_like(value,\'[[:punct:]]\');\r\n\r\n例子：判断姓名是否为空，少于两个字符，包含数字和字母\r\n\r\ncreate or replace\r\nFUNCTION CheckName(NameStr in VARCHAR2) RETURN integer\r\nAs\r\nBEGIN\r\n--符合返回1，不符合返回0\r\nif(NameStr is null or length(NameStr)&lt;2) then\r\nreturn 0;\r\nelse\r\nif(NameStr like \'%未取名%\') then\r\nRETURN 0;\r\nend if;\r\nif regexp_like(NameStr,\'^([a-z]+|[0-9]+|[A-Z]+)$\') then\r\nreturn 0;\r\nend if;\r\nreturn 1;\r\nend if;\r\nEND CheckName;','OCP 047-002 REGEXP_LIKE','','inherit','open','open','','192-revision-v1','','','2014-03-24 22:20:55','2014-03-24 14:20:55','',192,'http://localhost/wordpress/?p=206',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (207,1,'2014-03-24 22:21:17','2014-03-24 14:21:17','Multi-table Insert, Inserting into mutiple target table when a given condition match or insert into all tables the same data\r\nSyntax\r\n\r\n{INSERT {ALL | FIRST}\r\n[WHEN &lt;condition-1&gt; THEN]\r\nINTO &lt;table1&gt; [(col1, col2�.)]\r\n[VALUES (val1, val2�..)]\r\n\r\n[WHEN &lt;condition-2&gt; THEN]\r\nINTO &lt;table2&gt; [(col1, col2�.)]\r\n[VALUES (val1, val3�..)]\r\n.\r\n.\r\n[WHEN &lt;condition-n&gt; THEN]\r\nINTO &lt;table2&gt; [(col1, col2�.)]\r\n[VALUES (val1, val3�..)]\r\n\r\n[ELSE\r\nINTO &lt;table3&gt; [(col1, col2�.)]\r\n[VALUES (val5, val6�..)]\r\n]\r\n{Sub-query-definition}\r\n}\r\n\r\n--------------------etc---------\r\nInsert command:\r\n\r\nINSERT ALL\r\nWHEN column3 like �Smith� THEN\r\nINTO EMP_TARGET (EID, NAME)\r\n[VALUES (column1, column2)]\r\nELSE\r\nINTO logtable (ID, NAME, SALARY, DESCRIPTION)\r\nVALUES (column1, column2, column4, ERR_MSG)\r\n\r\nSELECT t1.ID AS column1, (t1.FNAME|| t1.LNAME) AS column2,\r\nt1.LNAME AS column3, t2.SALARY AS column4\r\nFROM EMP t1, SALARY t2\r\nINNER JOIN ON (t1.ID = t2.EID)\r\nWHERE (t1.ID &gt; 1000 AND t2.SALARY &gt; 5000)','OCP 047-001 oracle 多表插入','','inherit','open','open','','199-revision-v1','','','2014-03-24 22:21:17','2014-03-24 14:21:17','',199,'http://localhost/wordpress/?p=207',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (208,1,'2014-03-25 13:55:43','2014-03-25 05:55:43','Which three tasks can be performed using regular expression support in Oracle Database 10g? (Choose three.)\r\nA. It can be used to concatenate two strings.\r\nB. It can be used to find out the total length of the string.\r\nC. It can be used for string manipulation and searching operations.\r\nD. It can be used to format the output for a column or expression having string data.\r\nE. It can be used to find and replace operations for a column or expression having string data.\r\n答案: CDE\r\n分析: 本题考点是正则表达式/REGEXP\r\nOracle 10g支持正则表达式的函数主要有REGEXP_LIKE、REGEXP_INSTR、REGEXP_SUBSTR、REGEXP_REPLACE，用来寻找或替换匹配的字符串\r\nA. 连接两个字符串用符号||，正则表达式没有这个功能。\r\nB. 字符串的长度是用length()函数，正则表达式没有这个功能。','OCP 047-003 regular expression ','','publish','open','open','','ocp-047-003-regular-expression','','','2014-03-25 13:55:43','2014-03-25 05:55:43','',0,'http://localhost/wordpress/?p=208',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (209,1,'2014-03-25 13:55:43','2014-03-25 05:55:43','Which three tasks can be performed using regular expression support in Oracle Database 10g? (Choose three.)\r\nA. It can be used to concatenate two strings.\r\nB. It can be used to find out the total length of the string.\r\nC. It can be used for string manipulation and searching operations.\r\nD. It can be used to format the output for a column or expression having string data.\r\nE. It can be used to find and replace operations for a column or expression having string data.\r\n答案: CDE\r\n分析: 本题考点是正则表达式/REGEXP\r\nOracle 10g支持正则表达式的函数主要有REGEXP_LIKE、REGEXP_INSTR、REGEXP_SUBSTR、REGEXP_REPLACE，用来寻找或替换匹配的字符串\r\nA. 连接两个字符串用符号||，正则表达式没有这个功能。\r\nB. 字符串的长度是用length()函数，正则表达式没有这个功能。','OCP 047-003 regular expression ','','inherit','open','open','','208-revision-v1','','','2014-03-25 13:55:43','2014-03-25 05:55:43','',208,'http://localhost/wordpress/?p=209',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (210,1,'2014-03-25 13:56:50','2014-03-25 05:56:50','View the Exhibit and examine the structure of the EMP table which is not partitioned and not an indexorganized table. Evaluate the following SQL statement:\r\nALTER TABLE emp DROP COLUMN first_name;\r\nWhich two statements are true regarding the above command? (Choose two.)\r\nA. The FIRST_NAME column would be dropped provided it does not contain any data.\r\nB. The FIRST_NAME column would be dropped provided at least one or more columns remain in the table.\r\nC. The FIRST_NAME column can be rolled back provided the SET UNUSED option is added to the above SQL statement.\r\nD. The FIRST_NAME column can be dropped even if it is part of a composite PRIMARY KEY provided the CASCADE option is used.\r\n答案: BD\r\n分析: 本题考点是set unused\r\nEMP表不是分区表也不是所引组织表，drop columns是物理删除，set unused是逻辑删除，两者都不可以通过rollback恢复，所有引用到该列的对象都会失败。\r\nA. 不管列上有没有数据，删除列的命令都可以正常执行。\r\nC. set unused的列无法访问，无法使用rollback撤销unused设置\r\n\r\n-----------\r\n\r\nSET UNUSED的用法\r\n\r\n原理：清楚掉字典信息（撤消存储空间），不可恢复。\r\n\r\n可以使用 SET UNUSED 选项标记一列或者多列不可用。\r\n\r\n使用DROP SET UNUSED 选项删除被被标记为不可用的列。\r\n\r\n语法：\r\n\r\nALTER TABLE table SET UNUSED (COLlist多个) 或者 ALTER TABLE table SET UNUSED COLUMN col单个;\r\n\r\nALTER TABLE table DROP UNUSED COLUMNS;\r\n\r\nset unused不会真地删除字段。\r\n除了alter table drop field外，也可以\r\nalter table set unused field;\r\nalter table drop unused;\r\nset unused系统开销比较小，速度较快，所以可以先set unuased，然后在系统负载较小时，再drop。如系统负载不大，也可以直接drop。\r\n不管用何种方法，都不会收回空间。\r\n\r\n如果你有这个需求，要删除某一个表格上的某些栏位，但是由於这个表格拥有非常大量的资料，如果你在尖峰时间直接执行 ALTER TABLE ABC DROP （COLUMN）；可能会收到 ORA-01562 - failed to extend rollback segment number string，\r\n这是因为在这个删除栏位的过程中你可能会消耗光整个RBS，造成这样的错误出现，因此这样的做法并不是一个好方法，就算你拼命的加大RBS空间来应付这个问题，也不会是个好主意。\r\n\r\n我的建议做法：\r\n\r\n1&gt;\r\n\r\nCREATE TABLE T1 （A NUMBER，B NUMBER）；\r\n\r\nSQL&gt; begin 2 for i in 1 …… 100000 3 loop 4 insert into t1 values （i，100）；5 end loop；6 commit；7 end；\r\n\r\nSQL&gt; select count（*） from t1；\r\n\r\nCOUNT（*）\r\n\r\n100000\r\n\r\n2&gt;\r\n\r\nSQL&gt; ALTER TABLE T1 SET UNUSED COLUMN A CASCADE CONSTRAINTS；\r\n\r\n不要马上drop column，应该先set unused让column无法使用，避开系统尖峰时间再来处理删除栏位里的资料，要注意的是一但你set unused column，这个栏位是无法再回复使用的。\r\n\r\n3&gt;\r\n\r\n重点来了，若你的栏位有一百万笔资料，我们应该避免一次写入那么多的undo log，所以我准备每删除一千笔资料就commit一次。\r\n\r\nSQL&gt; alter table t1 drop unused columns checkpoint 1000；\r\n\r\nTable altered.\r\n\r\n在离峰的时间进行这样的动作，应该可以避免 ORA-01562 的错误发生。\r\n\r\n刚才有个人问我如何修复被设置为UNUSED的字段，我考虑了一下，以下的方法可以恢复（以下步骤执行前要做好备份），没有经验的DBA不要轻易尝试。\r\n\r\n1、创建实验表TTTA\r\n\r\nSQL&gt; CREATE TABLE TTTA ( A INTEGER,B INTEGER,C VARCHAR2(10),D INTEGER);\r\n\r\n表已创建。\r\n\r\nSQL&gt; INSERT INTO TTTA VALUES (1,2,\'3\',4);\r\n\r\n已创建 1 行。\r\n\r\nSQL&gt; INSERT INTO TTTA VALUES (2,3,\'4\',5);\r\n\r\n已创建 1 行。\r\n\r\nSQL&gt; COMMIT;\r\n\r\n提交完成。\r\nALTER TABLE TTTA SET UNUSED COLUMN C;\r\n\r\n2、以下进行恢复\r\n\r\nSQL&gt; SELECT OBJ# FROM OBJ$ WHERE NAME=\'TTTA\';\r\n\r\nOBJ#\r\n----------\r\n32067\r\n\r\nSELECT COL#,INTCOL#,NAME FROM COL$ WHERE OBJ#=32067;\r\nCOL# INTCOL# NAME\r\n---------- ---------- ------------------------------\r\n1 1 A\r\n2 2 B\r\n0 3 SYS_C00003_08031720:09:55$ 被UNUSED的字段\r\n3 4 D\r\n\r\nSQL&gt; SELECT COLS FROM TAB$ WHERE OBJ#=32067;\r\n\r\nCOLS\r\n----------\r\n3 ------字段数变为3了\r\n\r\nSQL&gt; UPDATE COL$ SET COL#=INTCOL# WHERE OBJ#=32067;\r\n\r\n已更新4行。\r\n\r\nSQL&gt; UPDATE TAB$ SET COLS=COLS+1 WHERE OBJ#=32067;\r\n\r\n已更新 1 行。\r\n\r\nUPDATE COL$ SET NAME=\'C\' WHERE OBJ#=32067 AND COL#=3;\r\n\r\nUPDATE COL$ SET PROPERTY=0 WHERE OBJ#=32067;\r\nSQL&gt; COMMIT;\r\n\r\n3、重启数据库\r\nSQL&gt; SELECT * FROM SCOTT.TTTA;\r\n\r\nA B C D\r\n---------- ---------- ---------- ----------\r\n1 2 3 4\r\n2 3 4 5\r\n\r\n恢复完成\r\n\r\n也就是说可以通过修改SYS用户下的系统表来恢复 这种情况是在于只适用unused的方法来恢复 如果使用drop则是物理删除','OCP 047-004 set unused','','publish','open','open','','ocp-047-004-set-unused','','','2014-03-25 14:42:08','2014-03-25 06:42:08','',0,'http://localhost/wordpress/?p=210',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (211,1,'2014-03-25 13:56:50','2014-03-25 05:56:50','View the Exhibit and examine the structure of the EMP table which is not partitioned and not an indexorganized table. Evaluate the following SQL statement:\r\nALTER TABLE emp DROP COLUMN first_name;\r\nWhich two statements are true regarding the above command? (Choose two.)\r\nA. The FIRST_NAME column would be dropped provided it does not contain any data.\r\nB. The FIRST_NAME column would be dropped provided at least one or more columns remain in the table.\r\nC. The FIRST_NAME column can be rolled back provided the SET UNUSED option is added to the above SQL statement.\r\nD. The FIRST_NAME column can be dropped even if it is part of a composite PRIMARY KEY provided the CASCADE option is used.\r\n答案: BD\r\n分析: 本题考点是set unused\r\nEMP表不是分区表也不是所引组织表，drop columns是物理删除，set unused是逻辑删除，两者都不可以通过rollback恢复，所有引用到该列的对象都会失败。\r\nA. 不管列上有没有数据，删除列的命令都可以正常执行。\r\nC. set unused的列无法访问，无法使用rollback撤销unused设置','OCP 047-004 set unused','','inherit','open','open','','210-revision-v1','','','2014-03-25 13:56:50','2014-03-25 05:56:50','',210,'http://localhost/wordpress/?p=211',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (212,1,'2014-03-25 14:00:41','2014-03-25 06:00:41','View the Exhibit and examine the structure of the EMP table which is not partitioned and not an indexorganized table. Evaluate the following SQL statement:\r\nALTER TABLE emp DROP COLUMN first_name;\r\nWhich two statements are true regarding the above command? (Choose two.)\r\nA. The FIRST_NAME column would be dropped provided it does not contain any data.\r\nB. The FIRST_NAME column would be dropped provided at least one or more columns remain in the table.\r\nC. The FIRST_NAME column can be rolled back provided the SET UNUSED option is added to the above SQL statement.\r\nD. The FIRST_NAME column can be dropped even if it is part of a composite PRIMARY KEY provided the CASCADE option is used.\r\n答案: BD\r\n分析: 本题考点是set unused\r\nEMP表不是分区表也不是所引组织表，drop columns是物理删除，set unused是逻辑删除，两者都不可以通过rollback恢复，所有引用到该列的对象都会失败。\r\nA. 不管列上有没有数据，删除列的命令都可以正常执行。\r\nC. set unused的列无法访问，无法使用rollback撤销unused设置\r\n\r\n-----------\r\n\r\nSET UNUSED的用法\r\n\r\n\r\n原理：清楚掉字典信息（撤消存储空间），不可恢复。\r\n\r\n可以使用 SET UNUSED 选项标记一列或者多列不可用。\r\n\r\n使用DROP SET UNUSED 选项删除被被标记为不可用的列。\r\n\r\n语法：\r\n\r\nALTER TABLE table SET UNUSED (COLlist多个) 或者 ALTER TABLE table SET UNUSED COLUMN col单个;\r\n\r\nALTER TABLE table DROP UNUSED COLUMNS;\r\n\r\n\r\nset unused不会真地删除字段。\r\n除了alter table drop field外，也可以\r\nalter table set unused field;\r\nalter table drop unused;\r\nset unused系统开销比较小，速度较快，所以可以先set unuased，然后在系统负载较小时，再drop。如系统负载不大，也可以直接drop。\r\n不管用何种方法，都不会收回空间。\r\n\r\n\r\n如果你有这个需求，要删除某一个表格上的某些栏位，但是由於这个表格拥有非常大量的资料，如果你在尖峰时间直接执行 ALTER TABLE ABC DROP （COLUMN）；可能会收到 ORA-01562 - failed to extend rollback segment number string，\r\n这是因为在这个删除栏位的过程中你可能会消耗光整个RBS，造成这样的错误出现，因此这样的做法并不是一个好方法，就算你拼命的加大RBS空间来应付这个问题，也不会是个好主意。\r\n\r\n我的建议做法：\r\n\r\n1&gt;\r\n\r\nCREATE TABLE T1 （A NUMBER，B NUMBER）；\r\n\r\nSQL&gt; begin 2 for i in 1 …… 100000 3 loop 4 insert into t1 values （i，100）；5 end loop；6 commit；7 end；\r\n\r\nSQL&gt; select count（*） from t1；\r\n\r\nCOUNT（*）\r\n\r\n100000\r\n\r\n2&gt;\r\n\r\nSQL&gt; ALTER TABLE T1 SET UNUSED COLUMN A CASCADE CONSTRAINTS；\r\n\r\n不要马上drop column，应该先set unused让column无法使用，避开系统尖峰时间再来处理删除栏位里的资料，要注意的是一但你set unused column，这个栏位是无法再回复使用的。\r\n\r\n3&gt;\r\n\r\n重点来了，若你的栏位有一百万笔资料，我们应该避免一次写入那么多的undo log，所以我准备每删除一千笔资料就commit一次。\r\n\r\nSQL&gt; alter table t1 drop unused columns checkpoint 1000；\r\n\r\nTable altered.\r\n\r\n在离峰的时间进行这样的动作，应该可以避免 ORA-01562 的错误发生。\r\n\r\n\r\n\r\n刚才有个人问我如何修复被设置为UNUSED的字段，我考虑了一下，以下的方法可以恢复（以下步骤执行前要做好备份），没有经验的DBA不要轻易尝试。\r\n\r\n1、创建实验表TTTA\r\n\r\nSQL&gt; CREATE TABLE TTTA ( A INTEGER,B INTEGER,C VARCHAR2(10),D INTEGER);\r\n\r\n表已创建。\r\n\r\nSQL&gt; INSERT INTO TTTA VALUES (1,2,\'3\',4);\r\n\r\n已创建 1 行。\r\n\r\nSQL&gt; INSERT INTO TTTA VALUES (2,3,\'4\',5);\r\n\r\n已创建 1 行。\r\n\r\nSQL&gt; COMMIT;\r\n\r\n提交完成。\r\nALTER TABLE TTTA SET UNUSED COLUMN C;\r\n\r\n2、以下进行恢复\r\n\r\nSQL&gt; SELECT OBJ# FROM OBJ$ WHERE NAME=\'TTTA\';\r\n\r\nOBJ#\r\n----------\r\n32067\r\n\r\nSELECT COL#,INTCOL#,NAME FROM COL$ WHERE OBJ#=32067;\r\nCOL# INTCOL# NAME\r\n---------- ---------- ------------------------------\r\n1 1 A\r\n2 2 B\r\n0 3 SYS_C00003_08031720:09:55$ 被UNUSED的字段\r\n3 4 D\r\n\r\nSQL&gt; SELECT COLS FROM TAB$ WHERE OBJ#=32067;\r\n\r\nCOLS\r\n----------\r\n3 ------字段数变为3了\r\n\r\n\r\n\r\n\r\nSQL&gt; UPDATE COL$ SET COL#=INTCOL# WHERE OBJ#=32067;\r\n\r\n已更新4行。\r\n\r\nSQL&gt; UPDATE TAB$ SET COLS=COLS+1 WHERE OBJ#=32067;\r\n\r\n已更新 1 行。\r\n\r\nUPDATE COL$ SET NAME=\'C\' WHERE OBJ#=32067 AND COL#=3;\r\n\r\nUPDATE COL$ SET PROPERTY=0 WHERE OBJ#=32067;\r\nSQL&gt; COMMIT;\r\n\r\n3、重启数据库\r\nSQL&gt; SELECT * FROM SCOTT.TTTA;\r\n\r\nA B C D\r\n---------- ---------- ---------- ----------\r\n1 2 3 4\r\n2 3 4 5\r\n\r\n恢复完成','OCP 047-004 set unused','','inherit','open','open','','210-revision-v1','','','2014-03-25 14:00:41','2014-03-25 06:00:41','',210,'http://localhost/wordpress/?p=212',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (213,1,'2014-03-25 14:42:04','2014-03-25 06:42:04','View the Exhibit and examine the structure of the EMP table which is not partitioned and not an indexorganized table. Evaluate the following SQL statement:\nALTER TABLE emp DROP COLUMN first_name;\nWhich two statements are true regarding the above command? (Choose two.)\nA. The FIRST_NAME column would be dropped provided it does not contain any data.\nB. The FIRST_NAME column would be dropped provided at least one or more columns remain in the table.\nC. The FIRST_NAME column can be rolled back provided the SET UNUSED option is added to the above SQL statement.\nD. The FIRST_NAME column can be dropped even if it is part of a composite PRIMARY KEY provided the CASCADE option is used.\n答案: BD\n分析: 本题考点是set unused\nEMP表不是分区表也不是所引组织表，drop columns是物理删除，set unused是逻辑删除，两者都不可以通过rollback恢复，所有引用到该列的对象都会失败。\nA. 不管列上有没有数据，删除列的命令都可以正常执行。\nC. set unused的列无法访问，无法使用rollback撤销unused设置\n\n-----------\n\nSET UNUSED的用法\n\n原理：清楚掉字典信息（撤消存储空间），不可恢复。\n\n可以使用 SET UNUSED 选项标记一列或者多列不可用。\n\n使用DROP SET UNUSED 选项删除被被标记为不可用的列。\n\n语法：\n\nALTER TABLE table SET UNUSED (COLlist多个) 或者 ALTER TABLE table SET UNUSED COLUMN col单个;\n\nALTER TABLE table DROP UNUSED COLUMNS;\n\nset unused不会真地删除字段。\n除了alter table drop field外，也可以\nalter table set unused field;\nalter table drop unused;\nset unused系统开销比较小，速度较快，所以可以先set unuased，然后在系统负载较小时，再drop。如系统负载不大，也可以直接drop。\n不管用何种方法，都不会收回空间。\n\n如果你有这个需求，要删除某一个表格上的某些栏位，但是由於这个表格拥有非常大量的资料，如果你在尖峰时间直接执行 ALTER TABLE ABC DROP （COLUMN）；可能会收到 ORA-01562 - failed to extend rollback segment number string，\n这是因为在这个删除栏位的过程中你可能会消耗光整个RBS，造成这样的错误出现，因此这样的做法并不是一个好方法，就算你拼命的加大RBS空间来应付这个问题，也不会是个好主意。\n\n我的建议做法：\n\n1&gt;\n\nCREATE TABLE T1 （A NUMBER，B NUMBER）；\n\nSQL&gt; begin 2 for i in 1 …… 100000 3 loop 4 insert into t1 values （i，100）；5 end loop；6 commit；7 end；\n\nSQL&gt; select count（*） from t1；\n\nCOUNT（*）\n\n100000\n\n2&gt;\n\nSQL&gt; ALTER TABLE T1 SET UNUSED COLUMN A CASCADE CONSTRAINTS；\n\n不要马上drop column，应该先set unused让column无法使用，避开系统尖峰时间再来处理删除栏位里的资料，要注意的是一但你set unused column，这个栏位是无法再回复使用的。\n\n3&gt;\n\n重点来了，若你的栏位有一百万笔资料，我们应该避免一次写入那么多的undo log，所以我准备每删除一千笔资料就commit一次。\n\nSQL&gt; alter table t1 drop unused columns checkpoint 1000；\n\nTable altered.\n\n在离峰的时间进行这样的动作，应该可以避免 ORA-01562 的错误发生。\n\n刚才有个人问我如何修复被设置为UNUSED的字段，我考虑了一下，以下的方法可以恢复（以下步骤执行前要做好备份），没有经验的DBA不要轻易尝试。\n\n1、创建实验表TTTA\n\nSQL&gt; CREATE TABLE TTTA ( A INTEGER,B INTEGER,C VARCHAR2(10),D INTEGER);\n\n表已创建。\n\nSQL&gt; INSERT INTO TTTA VALUES (1,2,\'3\',4);\n\n已创建 1 行。\n\nSQL&gt; INSERT INTO TTTA VALUES (2,3,\'4\',5);\n\n已创建 1 行。\n\nSQL&gt; COMMIT;\n\n提交完成。\nALTER TABLE TTTA SET UNUSED COLUMN C;\n\n2、以下进行恢复\n\nSQL&gt; SELECT OBJ# FROM OBJ$ WHERE NAME=\'TTTA\';\n\nOBJ#\n----------\n32067\n\nSELECT COL#,INTCOL#,NAME FROM COL$ WHERE OBJ#=32067;\nCOL# INTCOL# NAME\n---------- ---------- ------------------------------\n1 1 A\n2 2 B\n0 3 SYS_C00003_08031720:09:55$ 被UNUSED的字段\n3 4 D\n\nSQL&gt; SELECT COLS FROM TAB$ WHERE OBJ#=32067;\n\nCOLS\n----------\n3 ------字段数变为3了\n\nSQL&gt; UPDATE COL$ SET COL#=INTCOL# WHERE OBJ#=32067;\n\n已更新4行。\n\nSQL&gt; UPDATE TAB$ SET COLS=COLS+1 WHERE OBJ#=32067;\n\n已更新 1 行。\n\nUPDATE COL$ SET NAME=\'C\' WHERE OBJ#=32067 AND COL#=3;\n\nUPDATE COL$ SET PROPERTY=0 WHERE OBJ#=32067;\nSQL&gt; COMMIT;\n\n3、重启数据库\nSQL&gt; SELECT * FROM SCOTT.TTTA;\n\nA B C D\n---------- ---------- ---------- ----------\n1 2 3 4\n2 3 4 5\n\n恢复完成\n\n也就是说可以通过修改SYS用户下的系统表来恢复 这种情况是在于只适用unused的方法来恢复 如果使用drop则是物理删除','OCP 047-004 set unused','','inherit','open','open','','210-autosave-v1','','','2014-03-25 14:42:04','2014-03-25 06:42:04','',210,'http://localhost/wordpress/?p=213',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (214,1,'2014-03-25 14:42:08','2014-03-25 06:42:08','View the Exhibit and examine the structure of the EMP table which is not partitioned and not an indexorganized table. Evaluate the following SQL statement:\r\nALTER TABLE emp DROP COLUMN first_name;\r\nWhich two statements are true regarding the above command? (Choose two.)\r\nA. The FIRST_NAME column would be dropped provided it does not contain any data.\r\nB. The FIRST_NAME column would be dropped provided at least one or more columns remain in the table.\r\nC. The FIRST_NAME column can be rolled back provided the SET UNUSED option is added to the above SQL statement.\r\nD. The FIRST_NAME column can be dropped even if it is part of a composite PRIMARY KEY provided the CASCADE option is used.\r\n答案: BD\r\n分析: 本题考点是set unused\r\nEMP表不是分区表也不是所引组织表，drop columns是物理删除，set unused是逻辑删除，两者都不可以通过rollback恢复，所有引用到该列的对象都会失败。\r\nA. 不管列上有没有数据，删除列的命令都可以正常执行。\r\nC. set unused的列无法访问，无法使用rollback撤销unused设置\r\n\r\n-----------\r\n\r\nSET UNUSED的用法\r\n\r\n原理：清楚掉字典信息（撤消存储空间），不可恢复。\r\n\r\n可以使用 SET UNUSED 选项标记一列或者多列不可用。\r\n\r\n使用DROP SET UNUSED 选项删除被被标记为不可用的列。\r\n\r\n语法：\r\n\r\nALTER TABLE table SET UNUSED (COLlist多个) 或者 ALTER TABLE table SET UNUSED COLUMN col单个;\r\n\r\nALTER TABLE table DROP UNUSED COLUMNS;\r\n\r\nset unused不会真地删除字段。\r\n除了alter table drop field外，也可以\r\nalter table set unused field;\r\nalter table drop unused;\r\nset unused系统开销比较小，速度较快，所以可以先set unuased，然后在系统负载较小时，再drop。如系统负载不大，也可以直接drop。\r\n不管用何种方法，都不会收回空间。\r\n\r\n如果你有这个需求，要删除某一个表格上的某些栏位，但是由於这个表格拥有非常大量的资料，如果你在尖峰时间直接执行 ALTER TABLE ABC DROP （COLUMN）；可能会收到 ORA-01562 - failed to extend rollback segment number string，\r\n这是因为在这个删除栏位的过程中你可能会消耗光整个RBS，造成这样的错误出现，因此这样的做法并不是一个好方法，就算你拼命的加大RBS空间来应付这个问题，也不会是个好主意。\r\n\r\n我的建议做法：\r\n\r\n1&gt;\r\n\r\nCREATE TABLE T1 （A NUMBER，B NUMBER）；\r\n\r\nSQL&gt; begin 2 for i in 1 …… 100000 3 loop 4 insert into t1 values （i，100）；5 end loop；6 commit；7 end；\r\n\r\nSQL&gt; select count（*） from t1；\r\n\r\nCOUNT（*）\r\n\r\n100000\r\n\r\n2&gt;\r\n\r\nSQL&gt; ALTER TABLE T1 SET UNUSED COLUMN A CASCADE CONSTRAINTS；\r\n\r\n不要马上drop column，应该先set unused让column无法使用，避开系统尖峰时间再来处理删除栏位里的资料，要注意的是一但你set unused column，这个栏位是无法再回复使用的。\r\n\r\n3&gt;\r\n\r\n重点来了，若你的栏位有一百万笔资料，我们应该避免一次写入那么多的undo log，所以我准备每删除一千笔资料就commit一次。\r\n\r\nSQL&gt; alter table t1 drop unused columns checkpoint 1000；\r\n\r\nTable altered.\r\n\r\n在离峰的时间进行这样的动作，应该可以避免 ORA-01562 的错误发生。\r\n\r\n刚才有个人问我如何修复被设置为UNUSED的字段，我考虑了一下，以下的方法可以恢复（以下步骤执行前要做好备份），没有经验的DBA不要轻易尝试。\r\n\r\n1、创建实验表TTTA\r\n\r\nSQL&gt; CREATE TABLE TTTA ( A INTEGER,B INTEGER,C VARCHAR2(10),D INTEGER);\r\n\r\n表已创建。\r\n\r\nSQL&gt; INSERT INTO TTTA VALUES (1,2,\'3\',4);\r\n\r\n已创建 1 行。\r\n\r\nSQL&gt; INSERT INTO TTTA VALUES (2,3,\'4\',5);\r\n\r\n已创建 1 行。\r\n\r\nSQL&gt; COMMIT;\r\n\r\n提交完成。\r\nALTER TABLE TTTA SET UNUSED COLUMN C;\r\n\r\n2、以下进行恢复\r\n\r\nSQL&gt; SELECT OBJ# FROM OBJ$ WHERE NAME=\'TTTA\';\r\n\r\nOBJ#\r\n----------\r\n32067\r\n\r\nSELECT COL#,INTCOL#,NAME FROM COL$ WHERE OBJ#=32067;\r\nCOL# INTCOL# NAME\r\n---------- ---------- ------------------------------\r\n1 1 A\r\n2 2 B\r\n0 3 SYS_C00003_08031720:09:55$ 被UNUSED的字段\r\n3 4 D\r\n\r\nSQL&gt; SELECT COLS FROM TAB$ WHERE OBJ#=32067;\r\n\r\nCOLS\r\n----------\r\n3 ------字段数变为3了\r\n\r\nSQL&gt; UPDATE COL$ SET COL#=INTCOL# WHERE OBJ#=32067;\r\n\r\n已更新4行。\r\n\r\nSQL&gt; UPDATE TAB$ SET COLS=COLS+1 WHERE OBJ#=32067;\r\n\r\n已更新 1 行。\r\n\r\nUPDATE COL$ SET NAME=\'C\' WHERE OBJ#=32067 AND COL#=3;\r\n\r\nUPDATE COL$ SET PROPERTY=0 WHERE OBJ#=32067;\r\nSQL&gt; COMMIT;\r\n\r\n3、重启数据库\r\nSQL&gt; SELECT * FROM SCOTT.TTTA;\r\n\r\nA B C D\r\n---------- ---------- ---------- ----------\r\n1 2 3 4\r\n2 3 4 5\r\n\r\n恢复完成\r\n\r\n也就是说可以通过修改SYS用户下的系统表来恢复 这种情况是在于只适用unused的方法来恢复 如果使用drop则是物理删除','OCP 047-004 set unused','','inherit','open','open','','210-revision-v1','','','2014-03-25 14:42:08','2014-03-25 06:42:08','',210,'http://localhost/wordpress/?p=214',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (215,1,'2014-03-25 14:46:33','2014-03-25 06:46:33','Evaluate the CREATE TABLE statement:\r\nCREATE TABLE products (product_id NUMBER(6) CONSTRAINT prod_id_pk PRIMARY KEY, product_name VARCHAR2(15));\r\nWhich statement is true regarding the PROD_ID_PK constraint?\r\nA. It would be created only if a unique index is manually created first.\r\nB. It would be created and would use an automatically created unique index.\r\nC. It would be created and would use an automatically created nonunique index.\r\nD. It would be created and remains in a disabled state because no index is specified in the command.\r\n答案: B\r\n分析: 本题考点是主键约束和唯一性约束自动建立索引\r\nOracle在创建主键约束或唯一性约束时，会自动检测该列是否创建过唯一性索引,如果有则不创建而直接使用,如果没有则自动隐式创建唯一性索引。\r\nA. 创建主键约束不需要首先手动创建唯一性索引，Oracle会自动隐式创建唯一性索引\r\nC. 创建主键约束时，Oracle会自动隐式创建的索引是唯一性索引\r\nD. 创建主键约束时没有指定索引，Oracle会自动寻找唯一性索引，找不到则会自动创建唯一性索引。所有约束创建时默认都是自动生效的','OCP 047-005 主键约束和唯一性约束','','publish','open','open','','ocp-047-005-%e4%b8%bb%e9%94%ae%e7%ba%a6%e6%9d%9f%e5%92%8c%e5%94%af%e4%b8%80%e6%80%a7%e7%ba%a6%e6%9d%9f','','','2014-03-25 14:46:33','2014-03-25 06:46:33','',0,'http://localhost/wordpress/?p=215',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (216,1,'2014-03-25 14:46:33','2014-03-25 06:46:33','Evaluate the CREATE TABLE statement:\r\nCREATE TABLE products (product_id NUMBER(6) CONSTRAINT prod_id_pk PRIMARY KEY, product_name VARCHAR2(15));\r\nWhich statement is true regarding the PROD_ID_PK constraint?\r\nA. It would be created only if a unique index is manually created first.\r\nB. It would be created and would use an automatically created unique index.\r\nC. It would be created and would use an automatically created nonunique index.\r\nD. It would be created and remains in a disabled state because no index is specified in the command.\r\n答案: B\r\n分析: 本题考点是主键约束和唯一性约束自动建立索引\r\nOracle在创建主键约束或唯一性约束时，会自动检测该列是否创建过唯一性索引,如果有则不创建而直接使用,如果没有则自动隐式创建唯一性索引。\r\nA. 创建主键约束不需要首先手动创建唯一性索引，Oracle会自动隐式创建唯一性索引\r\nC. 创建主键约束时，Oracle会自动隐式创建的索引是唯一性索引\r\nD. 创建主键约束时没有指定索引，Oracle会自动寻找唯一性索引，找不到则会自动创建唯一性索引。所有约束创建时默认都是自动生效的','OCP 047-005 主键约束和唯一性约束','','inherit','open','open','','215-revision-v1','','','2014-03-25 14:46:33','2014-03-25 06:46:33','',215,'http://localhost/wordpress/?p=216',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (218,1,'2014-04-10 22:33:07','2014-04-10 14:33:07','1 Oracle的GROUP BY语句除了最基本的语法外，还支持ROLLUP和CUBE语句。如果是ROLLUP(A, B, C)的话，首先会对(A、B、C)进行GROUP BY，然后对(A、B)进行GROUP BY，然后是(A)进行GROUP BY，最后对全表进行GROUP BY操作。如果是GROUP BY CUBE(A, B, C)，则首先会对(A、B、C)进行GROUP BY，然后依次是(A、B)，(A、C)，(A)，(B、C)，(B)，(C)，最后对全表进行GROUP BY操作。\r\n\r\n2 用GROUP BY GROUPING SETS来代替GROUP BY CUBE。你可以应用来指定你感兴趣的总数组合。因为它不必计算它不需要集合（也不会产生太多结果），所以对SQL引擎来说更为高效。\r\n其格式为：\r\nGROUP BY GROUPING SETS ((list), (list) ... )','OCP 047-011 Group by rollup | grouping','','publish','open','open','','ocp-047-011-group-by-rollup-grouping','','','2014-04-10 22:33:58','2014-04-10 14:33:58','',0,'http://localhost/wordpress/?p=218',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (219,1,'2014-04-10 22:33:07','2014-04-10 14:33:07','1 Oracle的GROUP BY语句除了最基本的语法外，还支持ROLLUP和CUBE语句。如果是ROLLUP(A, B, C)的话，首先会对(A、B、C)进行GROUP BY，然后对(A、B)进行GROUP BY，然后是(A)进行GROUP BY，最后对全表进行GROUP BY操作。如果是GROUP BY CUBE(A, B, C)，则首先会对(A、B、C)进行GROUP BY，然后依次是(A、B)，(A、C)，(A)，(B、C)，(B)，(C)，最后对全表进行GROUP BY操作。\r\n\r\n2 用GROUP BY GROUPING SETS来代替GROUP BY CUBE。你可以应用来指定你感兴趣的总数组合。因为它不必计算它不需要集合（也不会产生太多结果），所以对SQL引擎来说更为高效。\r\n其格式为：\r\nGROUP BY GROUPING SETS ((list), (list) ... )','OCP 047-011 Group by rollup | grouping','','inherit','open','open','','218-revision-v1','','','2014-04-10 22:33:07','2014-04-10 14:33:07','',218,'http://localhost/wordpress/?p=219',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (220,1,'2014-04-10 23:05:25','2014-04-10 15:05:25','oracle中 connect by prior 递归算法\r\n\r\nOracle中start with...connect by prior子句用法 connect by 是结构化查询中用到的，其基本语法是：\r\nselect ... from tablename start with 条件1\r\nconnect by 条件2\r\nwhere 条件3;\r\n例：\r\nselect * from table\r\nstart with org_id = \'HBHqfWGWPy\'\r\nconnect by prior org_id = parent_id;\r\n\r\n简单说来是将一个树状结构存储在一张表里，比如一个表中存在两个字段:\r\norg_id,parent_id那么通过表示每一条记录的parent是谁，就可以形成一个树状结构。\r\n用上述语法的查询可以取得这棵树的所有记录。\r\n其中：\r\n条件1 是根结点的限定语句，当然可以放宽限定条件，以取得多个根结点，实际就是多棵树。\r\n条件2 是连接条件，其中用PRIOR表示上一条记录，比如 CONNECT BY PRIOR org_id = parent_id就是说上一条记录的org_id 是本条记录的parent_id，即本记录的父亲是上一条记录。\r\n条件3 是过滤条件，用于对返回的所有记录进行过滤。\r\n\r\n简单介绍如下：\r\n早扫描树结构表时，需要依此访问树结构的每个节点，一个节点只能访问一次，其访问的步骤如下：\r\n第一步：从根节点开始；\r\n第二步：访问该节点；\r\n第三步：判断该节点有无未被访问的子节点，若有，则转向它最左侧的未被访问的子节，并执行第二步，否则执行第四步；\r\n第四步：若该节点为根节点，则访问完毕，否则执行第五步；\r\n第五步：返回到该节点的父节点，并执行第三步骤。\r\n\r\n总之：扫描整个树结构的过程也即是中序遍历树的过程。\r\n\r\n1． 树结构的描述\r\n树结构的数据存放在表中，数据之间的层次关系即父子关系，通过表中的列与列间的关系来描述，如EMP表中的EMPNO和MGR。EMPNO表示该雇员的编号，MGR表示领导该雇员的人的编号，即子节点的MGR值等于父节点的EMPNO值。在表的每一行中都有一个表示父节点的MGR（除根节点外），通过每个节点的父节点，就可以确定整个树结构。\r\n在SELECT命令中使用CONNECT BY 和蔼START WITH 子句可以查询表中的树型结构关系。其命令格式如下：\r\nSELECT 。。。\r\nCONNECT BY {PRIOR 列名1=列名2|列名1=PRIOR 裂名2}\r\n[START WITH]；\r\n其中：CONNECT BY子句说明每行数据将是按层次顺序检索，并规定将表中的数据连入树型结构的关系中。PRIORY运算符必须放置在连接关系的两列中某一个的前面。对于节点间的父子关系，PRIOR运算符在一侧表示父节点，在另一侧表示子节点，从而确定查找树结构是的顺序是自顶向下还是自底向上。在连接关系中，除了可以使用列名外，还允许使用列表达式。START WITH 子句为可选项，用来标识哪个节点作为查找树型结构的根节点。若该子句被省略，则表示所有满足查询条件的行作为根节点。\r\nSTART WITH： 不但可以指定一个根节点，还可以指定多个根节点。\r\n2． 关于PRIOR\r\n运算符PRIOR被放置于等号前后的位置，决定着查询时的检索顺序。\r\nPRIOR被置于CONNECT BY子句中等号的前面时，则强制从根节点到叶节点的顺序检索，即由父节点向子节点方向通过树结构，我们称之为自顶向下的方式。如：\r\nCONNECT BY PRIOR EMPNO=MGR\r\nPIROR运算符被置于CONNECT BY 子句中等号的后面时，则强制从叶节点到根节点的顺序检索，即由子节点向父节点方向通过树结构，我们称之为自底向上的方式。例如：\r\nCONNECT BY EMPNO=PRIOR MGR\r\n在这种方式中也应指定一个开始的节点。\r\n3． 定义查找起始节点\r\n在自顶向下查询树结构时，不但可以从根节点开始，还可以定义任何节点为起始节点，以此开始向下查找。这样查找的结果就是以该节点为开始的结构树的一枝。\r\n4．使用LEVEL\r\n在具有树结构的表中，每一行数据都是树结构中的一个节点，由于节点所处的层次位置不同，所以每行记录都可以有一个层号。层号根据节点与根节点的距离确定。不论从哪个节点开始，该起始根节点的层号始终为1，根节点的子节点为2， 依此类推。\r\n5．节点和分支的裁剪\r\n在对树结构进行查询时，可以去掉表中的某些行，也可以剪掉树中的一个分支，使用WHERE子句来限定树型结构中的单个节点，以去掉树中的单个节点，但它却不影响其后代节点（自顶向下检索时）或前辈节点（自底向顶检索时）。\r\n6．排序显示\r\n象在其它查询中一样，在树结构查询中也可以使用ORDER BY 子句，改变查询结果的显示顺序，而不必按照遍历树结构的顺序','OCP 047 - 012 connect by prior','','publish','open','open','','ocp-047-012-connect-by-prior','','','2014-04-10 23:05:25','2014-04-10 15:05:25','',0,'http://localhost/wordpress/?p=220',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (221,1,'2014-04-10 23:05:25','2014-04-10 15:05:25','oracle中 connect by prior 递归算法\r\n\r\nOracle中start with...connect by prior子句用法 connect by 是结构化查询中用到的，其基本语法是：\r\nselect ... from tablename start with 条件1\r\nconnect by 条件2\r\nwhere 条件3;\r\n例：\r\nselect * from table\r\nstart with org_id = \'HBHqfWGWPy\'\r\nconnect by prior org_id = parent_id;\r\n\r\n简单说来是将一个树状结构存储在一张表里，比如一个表中存在两个字段:\r\norg_id,parent_id那么通过表示每一条记录的parent是谁，就可以形成一个树状结构。\r\n用上述语法的查询可以取得这棵树的所有记录。\r\n其中：\r\n条件1 是根结点的限定语句，当然可以放宽限定条件，以取得多个根结点，实际就是多棵树。\r\n条件2 是连接条件，其中用PRIOR表示上一条记录，比如 CONNECT BY PRIOR org_id = parent_id就是说上一条记录的org_id 是本条记录的parent_id，即本记录的父亲是上一条记录。\r\n条件3 是过滤条件，用于对返回的所有记录进行过滤。\r\n\r\n简单介绍如下：\r\n早扫描树结构表时，需要依此访问树结构的每个节点，一个节点只能访问一次，其访问的步骤如下：\r\n第一步：从根节点开始；\r\n第二步：访问该节点；\r\n第三步：判断该节点有无未被访问的子节点，若有，则转向它最左侧的未被访问的子节，并执行第二步，否则执行第四步；\r\n第四步：若该节点为根节点，则访问完毕，否则执行第五步；\r\n第五步：返回到该节点的父节点，并执行第三步骤。\r\n\r\n总之：扫描整个树结构的过程也即是中序遍历树的过程。\r\n\r\n1． 树结构的描述\r\n树结构的数据存放在表中，数据之间的层次关系即父子关系，通过表中的列与列间的关系来描述，如EMP表中的EMPNO和MGR。EMPNO表示该雇员的编号，MGR表示领导该雇员的人的编号，即子节点的MGR值等于父节点的EMPNO值。在表的每一行中都有一个表示父节点的MGR（除根节点外），通过每个节点的父节点，就可以确定整个树结构。\r\n在SELECT命令中使用CONNECT BY 和蔼START WITH 子句可以查询表中的树型结构关系。其命令格式如下：\r\nSELECT 。。。\r\nCONNECT BY {PRIOR 列名1=列名2|列名1=PRIOR 裂名2}\r\n[START WITH]；\r\n其中：CONNECT BY子句说明每行数据将是按层次顺序检索，并规定将表中的数据连入树型结构的关系中。PRIORY运算符必须放置在连接关系的两列中某一个的前面。对于节点间的父子关系，PRIOR运算符在一侧表示父节点，在另一侧表示子节点，从而确定查找树结构是的顺序是自顶向下还是自底向上。在连接关系中，除了可以使用列名外，还允许使用列表达式。START WITH 子句为可选项，用来标识哪个节点作为查找树型结构的根节点。若该子句被省略，则表示所有满足查询条件的行作为根节点。\r\nSTART WITH： 不但可以指定一个根节点，还可以指定多个根节点。\r\n2． 关于PRIOR\r\n运算符PRIOR被放置于等号前后的位置，决定着查询时的检索顺序。\r\nPRIOR被置于CONNECT BY子句中等号的前面时，则强制从根节点到叶节点的顺序检索，即由父节点向子节点方向通过树结构，我们称之为自顶向下的方式。如：\r\nCONNECT BY PRIOR EMPNO=MGR\r\nPIROR运算符被置于CONNECT BY 子句中等号的后面时，则强制从叶节点到根节点的顺序检索，即由子节点向父节点方向通过树结构，我们称之为自底向上的方式。例如：\r\nCONNECT BY EMPNO=PRIOR MGR\r\n在这种方式中也应指定一个开始的节点。\r\n3． 定义查找起始节点\r\n在自顶向下查询树结构时，不但可以从根节点开始，还可以定义任何节点为起始节点，以此开始向下查找。这样查找的结果就是以该节点为开始的结构树的一枝。\r\n4．使用LEVEL\r\n在具有树结构的表中，每一行数据都是树结构中的一个节点，由于节点所处的层次位置不同，所以每行记录都可以有一个层号。层号根据节点与根节点的距离确定。不论从哪个节点开始，该起始根节点的层号始终为1，根节点的子节点为2， 依此类推。\r\n5．节点和分支的裁剪\r\n在对树结构进行查询时，可以去掉表中的某些行，也可以剪掉树中的一个分支，使用WHERE子句来限定树型结构中的单个节点，以去掉树中的单个节点，但它却不影响其后代节点（自顶向下检索时）或前辈节点（自底向顶检索时）。\r\n6．排序显示\r\n象在其它查询中一样，在树结构查询中也可以使用ORDER BY 子句，改变查询结果的显示顺序，而不必按照遍历树结构的顺序','OCP 047 - 012 connect by prior','','inherit','open','open','','220-revision-v1','','','2014-04-10 23:05:25','2014-04-10 15:05:25','',220,'http://localhost/wordpress/?p=221',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (222,1,'2014-04-16 00:19:26','2014-04-15 16:19:26','oracle的正则表达式(regular expression)简单介绍\r\n目前，正则表达式已经在很多软件中得到广泛的应用，包括*nix（Linux, Unix等），HP等操作系统，PHP，C#，Java等开发环境。\r\nOracle 10g正则表达式提高了SQL灵活性。有效的解决了数据有效性，重复词的辨认, 无关的空白检测，或者分解多个正则组成的字符串等问题。\r\nOracle 10g支持正则表达式的四个新函数分别是：REGEXP_LIKE、REGEXP_INSTR、REGEXP_SUBSTR、和REGEXP_REPLACE。\r\n它们使用POSIX 正则表达式代替了老的百分号（%）和通配符（_）字符。\r\n特殊字符：\r\n\'^\' 匹配输入字符串的开始位置，在方括号表达式中使用，此时它表示不接受该字符集合。\r\n\'$\' 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 \'\\n\' 或\'\\r\'。\r\n\'.\' 匹配除换行符 \\n之外的任何单字符。\r\n\'?\' 匹配前面的子表达式零次或一次。\r\n\'*\' 匹配前面的子表达式零次或多次。\r\n\'+\' 匹配前面的子表达式一次或多次。\r\n\'( )\' 标记一个子表达式的开始和结束位置。\r\n\'[]\' 标记一个中括号表达式。\r\n\'{m,n}\' 一个精确地出现次数范围，m=&lt;出现次数&lt;=n，\'{m}\'表示出现m次，\'{m,}\'表示至少出现m次。\r\n\'|\' 指明两项之间的一个选择。例子\'^([a-z]+|[0-9]+)$\'表示所有小写字母或数字组合成的字符串。\r\n\\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。\r\n正则表达式的一个很有用的特点是可以保存子表达式以后使用，被称为Backreferencing. 允许复杂的替换能力\r\n如调整一个模式到新的位置或者指示被代替的字符或者单词的位置. 被匹配的子表达式存储在临时缓冲区\r\n\r\n中，缓冲区从左到右编号, 通过\\数字符号访问。 下面的例子列出了把名字 aa bb cc 变成cc, bb, aa.\r\nSelect REGEXP_REPLACE(\'aa bb cc\',\'(.*) (.*) (.*)\', \'\\3, \\2, \\1\') FROM dual；\r\nREGEXP_REPLACE(\'ELLENHILDISMIT\r\ncc, bb, aa\r\n\'\\\' 转义符。\r\n字符簇：\r\n[[:alpha:]] 任何字母。\r\n[[:digit:]] 任何数字。\r\n[[:alnum:]] 任何字母和数字。\r\n[[:space:]] 任何白字符。\r\n[[:upper:]] 任何大写字母。\r\n[[:lower:]] 任何小写字母。\r\n[[unct:]] 任何标点符号。\r\n[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]。\r\n各种操作符的运算优先级\r\n\\ 转义符\r\n(), (?, (?=), [] 圆括号和方括号\r\n*, +, ?, {n}, {n,}, {n,m} 限定符\r\n^, $, \\anymetacharacter 位置和顺序\r\n| “或”操作\r\n--测试数据\r\ncreate table test(mc varchar2(60));\r\ninsert into test values(\'112233445566778899\');\r\ninsert into test values(\'22113344 5566778899\');\r\ninsert into test values(\'33112244 5566778899\');\r\ninsert into test values(\'44112233 5566 778899\');\r\ninsert into test values(\'5511 2233 4466778899\');\r\ninsert into test values(\'661122334455778899\');\r\ninsert into test values(\'771122334455668899\');\r\ninsert into test values(\'881122334455667799\');\r\ninsert into test values(\'991122334455667788\');\r\ninsert into test values(\'aabbccddee\');\r\ninsert into test values(\'bbaaaccddee\');\r\ninsert into test values(\'ccabbddee\');\r\ninsert into test values(\'ddaabbccee\');\r\ninsert into test values(\'eeaabbccdd\');\r\ninsert into test values(\'ab123\');\r\ninsert into test values(\'123xy\');\r\ninsert into test values(\'007ab\');\r\ninsert into test values(\'abcxy\');\r\ninsert into test values(\'The final test is is is how to find duplicate words.\');\r\ncommit;\r\n一、REGEXP_LIKE\r\nselect * from test where regexp_like(mc,\'^a{1,3}\');\r\nselect * from test where regexp_like(mc,\'a{1,3}\');\r\nselect * from test where regexp_like(mc,\'^a.*e$\');\r\nselect * from test where regexp_like(mc,\'^[[:lower:]]|[[:digit:]]\');\r\nselect * from test where regexp_like(mc,\'^[[:lower:]]\');\r\nSelect mc FROM test Where REGEXP_LIKE(mc,\'[^[:digit:]]\');\r\nSelect mc FROM test Where REGEXP_LIKE(mc,\'^[^[:digit:]]\');\r\n二、REGEXP_INSTR\r\nSelect REGEXP_INSTR(mc,\'[[:digit:]]$\') from test;\r\nSelect REGEXP_INSTR(mc,\'[[:digit:]]+$\') from test;\r\nSelect REGEXP_INSTR(\'The price is $400.\',\'\\$[[:digit:]]+\') FROM DUAL;\r\nSelect REGEXP_INSTR(\'onetwothree\',\'[^[[:lower:]]]\') FROM DUAL;\r\nSelect REGEXP_INSTR(\',,,,,\',\'[^,]*\') FROM DUAL;\r\nSelect REGEXP_INSTR(\',,,,,\',\'[^,]\') FROM DUAL;\r\n三、REGEXP_SUBSTR\r\nSELECT REGEXP_SUBSTR(mc,\'[a-z]+\') FROM test;\r\nSELECT REGEXP_SUBSTR(mc,\'[0-9]+\') FROM test;\r\nSELECT REGEXP_SUBSTR(\'aababcde\',\'^a.*b\') FROM DUAL;\r\n四、REGEXP_REPLACE\r\nSelect REGEXP_REPLACE(\'Joe Smith\',\'( ){2,}\', \',\') AS RX_REPLACE FROM dual;\r\nSelect REGEXP_REPLACE(\'aa bb cc\',\'(.*) (.*) (.*)\', \'\\3, \\2, \\1\') FROM dual\r\n\r\n四个函数是:regexp_like.regexp_instr.regexp_substr.与 regexp_replace.它们在用法上与oracle sql 函数like.instr.substr 与replace 用法,但是它们使用posix 正则表达式代替了老的百分号（%）与通配符（_）字符. 【推荐阅读:My SQL数据库引擎快速指导】\r\n\r\nregexp_like 与like 操作符相似.如果第一个参数匹配正则表达式它就解析为true.例如where regexp_like(ename,^j[ao],i) 将在ename 以ja 或jo 开始的情况下返回一行数据.i 参数指定正则表达式是大小写敏感的.另外还可以在check 约束与函数索引中指定regexp_like.例如: 【扩展信息:MYSQL基本数据库术语】\r\n^ 表示字符串的开始 $ 表示字符串的结束 . 表示任何字符 字符的范围,比如说[a-z],表示任何ascii 小写字母,与字符类\"[[:lower:]]\"\" 等价 ? 允许一个后继字符匹配零次或一次 + 允许一个后继字符匹配一次或多次 * 表示零次或多次\r\n\r\n可以使用\"{m,n}\" 指定一个精确地出现范围,其意思是“出现从m 次到n 次”;\"{m}\" 表示“正好m次”;而\"{m,}\" 表示“至少m次”.还可以使用圆括号组合字符的集合,使用\"|\"（竖线）表示可替换.例如,字符串^([a-z]+|[0-9]+)$将匹配所有由小写字母或数字组合成的字符串.','OCP 047-002 REGEXP','','inherit','open','open','','192-revision-v1','','','2014-04-16 00:19:26','2014-04-15 16:19:26','',192,'http://localhost/wordpress/?p=222',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (223,1,'2014-04-16 00:26:18','2014-04-15 16:26:18','oracle的正则表达式(regular expression)简单介绍\r\n目前，正则表达式已经在很多软件中得到广泛的应用，包括*nix（Linux, Unix等），HP等操作系统，PHP，C#，Java等开发环境。\r\nOracle 10g正则表达式提高了SQL灵活性。有效的解决了数据有效性，重复词的辨认, 无关的空白检测，或者分解多个正则组成的字符串等问题。\r\nOracle 10g支持正则表达式的四个新函数分别是：REGEXP_LIKE、REGEXP_INSTR、REGEXP_SUBSTR、和REGEXP_REPLACE。\r\n它们使用POSIX 正则表达式代替了老的百分号（%）和通配符（_）字符。\r\n特殊字符：\r\n\'^\' 匹配输入字符串的开始位置，在方括号表达式中使用，此时它表示不接受该字符集合。\r\n\'$\' 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 \'\\n\' 或\'\\r\'。\r\n\'.\' 匹配除换行符 \\n之外的任何单字符。\r\n\'?\' 匹配前面的子表达式零次或一次。\r\n\'*\' 匹配前面的子表达式零次或多次。\r\n\'+\' 匹配前面的子表达式一次或多次。\r\n\'( )\' 标记一个子表达式的开始和结束位置。\r\n\'[]\' 标记一个中括号表达式。\r\n\'{m,n}\' 一个精确地出现次数范围，m=&lt;出现次数&lt;=n，\'{m}\'表示出现m次，\'{m,}\'表示至少出现m次。\r\n\'|\' 指明两项之间的一个选择。例子\'^([a-z]+|[0-9]+)$\'表示所有小写字母或数字组合成的字符串。\r\n\\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。\r\n正则表达式的一个很有用的特点是可以保存子表达式以后使用，被称为Backreferencing. 允许复杂的替换能力\r\n如调整一个模式到新的位置或者指示被代替的字符或者单词的位置. 被匹配的子表达式存储在临时缓冲区\r\n\r\n中，缓冲区从左到右编号, 通过\\数字符号访问。 下面的例子列出了把名字 aa bb cc 变成cc, bb, aa.\r\nSelect REGEXP_REPLACE(\'aa bb cc\',\'(.*) (.*) (.*)\', \'\\3, \\2, \\1\') FROM dual；\r\nREGEXP_REPLACE(\'ELLENHILDISMIT\r\ncc, bb, aa\r\n\'\\\' 转义符。\r\n字符簇：\r\n[[:alpha:]] 任何字母。\r\n[[:digit:]] 任何数字。\r\n[[:alnum:]] 任何字母和数字。\r\n[[:space:]] 任何白字符。\r\n[[:upper:]] 任何大写字母。\r\n[[:lower:]] 任何小写字母。\r\n[[unct:]] 任何标点符号。\r\n[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]。\r\n各种操作符的运算优先级\r\n\\ 转义符\r\n(), (?, (?=), [] 圆括号和方括号\r\n*, +, ?, {n}, {n,}, {n,m} 限定符\r\n^, $, \\anymetacharacter 位置和顺序\r\n| “或”操作\r\n--测试数据\r\ncreate table test(mc varchar2(60));\r\ninsert into test values(\'112233445566778899\');\r\ninsert into test values(\'22113344 5566778899\');\r\ninsert into test values(\'33112244 5566778899\');\r\ninsert into test values(\'44112233 5566 778899\');\r\ninsert into test values(\'5511 2233 4466778899\');\r\ninsert into test values(\'661122334455778899\');\r\ninsert into test values(\'771122334455668899\');\r\ninsert into test values(\'881122334455667799\');\r\ninsert into test values(\'991122334455667788\');\r\ninsert into test values(\'aabbccddee\');\r\ninsert into test values(\'bbaaaccddee\');\r\ninsert into test values(\'ccabbddee\');\r\ninsert into test values(\'ddaabbccee\');\r\ninsert into test values(\'eeaabbccdd\');\r\ninsert into test values(\'ab123\');\r\ninsert into test values(\'123xy\');\r\ninsert into test values(\'007ab\');\r\ninsert into test values(\'abcxy\');\r\ninsert into test values(\'The final test is is is how to find duplicate words.\');\r\ncommit;\r\n一、REGEXP_LIKE\r\nselect * from test where regexp_like(mc,\'^a{1,3}\');\r\nselect * from test where regexp_like(mc,\'a{1,3}\');\r\nselect * from test where regexp_like(mc,\'^a.*e$\');\r\nselect * from test where regexp_like(mc,\'^[[:lower:]]|[[:digit:]]\');\r\nselect * from test where regexp_like(mc,\'^[[:lower:]]\');\r\nSelect mc FROM test Where REGEXP_LIKE(mc,\'[^[:digit:]]\');\r\nSelect mc FROM test Where REGEXP_LIKE(mc,\'^[^[:digit:]]\');\r\n二、REGEXP_INSTR\r\nSelect REGEXP_INSTR(mc,\'[[:digit:]]$\') from test;\r\nSelect REGEXP_INSTR(mc,\'[[:digit:]]+$\') from test;\r\nSelect REGEXP_INSTR(\'The price is $400.\',\'\\$[[:digit:]]+\') FROM DUAL;\r\nSelect REGEXP_INSTR(\'onetwothree\',\'[^[[:lower:]]]\') FROM DUAL;\r\nSelect REGEXP_INSTR(\',,,,,\',\'[^,]*\') FROM DUAL;\r\nSelect REGEXP_INSTR(\',,,,,\',\'[^,]\') FROM DUAL;\r\n三、REGEXP_SUBSTR\r\nSELECT REGEXP_SUBSTR(mc,\'[a-z]+\') FROM test;\r\nSELECT REGEXP_SUBSTR(mc,\'[0-9]+\') FROM test;\r\nSELECT REGEXP_SUBSTR(\'aababcde\',\'^a.*b\') FROM DUAL;\r\n四、REGEXP_REPLACE\r\nSelect REGEXP_REPLACE(\'Joe Smith\',\'( ){2,}\', \',\') AS RX_REPLACE FROM dual;\r\nSelect REGEXP_REPLACE(\'aa bb cc\',\'(.*) (.*) (.*)\', \'\\3, \\2, \\1\') FROM dual\r\n\r\n四个函数是:regexp_like.regexp_instr.regexp_substr.与 regexp_replace.它们在用法上与oracle sql 函数like.instr.substr 与replace 用法,但是它们使用posix 正则表达式代替了老的百分号（%）与通配符（_）字符. 【推荐阅读:My SQL数据库引擎快速指导】\r\n\r\nregexp_like 与like 操作符相似.如果第一个参数匹配正则表达式它就解析为true.例如where regexp_like(ename,^j[ao],i) 将在ename 以ja 或jo 开始的情况下返回一行数据.i 参数指定正则表达式是大小写敏感的.另外还可以在check 约束与函数索引中指定regexp_like.例如: 【扩展信息:MYSQL基本数据库术语】\r\n^ 表示字符串的开始 $ 表示字符串的结束 . 表示任何字符 字符的范围,比如说[a-z],表示任何ascii 小写字母,与字符类\"[[:lower:]]\"\" 等价 ? 允许一个后继字符匹配零次或一次 + 允许一个后继字符匹配一次或多次 * 表示零次或多次\r\n\r\n可以使用\"{m,n}\" 指定一个精确地出现范围,其意思是“出现从m 次到n 次”;\"{m}\" 表示“正好m次”;而\"{m,}\" 表示“至少m次”.还可以使用圆括号组合字符的集合,使用\"|\"（竖线）表示可替换.例如,字符串^([a-z]+|[0-9]+)$将匹配所有由小写字母或数字组合成的字符串.\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n---\r\n\r\n后向引用\r\n\r\n正则表达式的一个有用的特性是能够存储子表达式供以后重用；这也被称为后向引用（在表 10 中对其进行了概述）。它允许复杂的替换功能，如在新的位置上交换模式或显示重复出现的单词或字母。子表达式的匹配部分保存在临时缓冲区中。缓冲区从左至右进行编号，并利用 \\digit 符号进行访问，其中 digit 是 1 到 9 之间的一个数字，它匹配第 digit 个子表达式，子表达式用一组圆括号来显示。\r\n\r\n接下来的例子显示了通过按编号引用各个子表达式将姓名 Ellen Hildi Smith 转变为 Smith, Ellen Hildi。\r\n\r\nSELECT REGEXP_REPLACE(\r\n\'Ellen Hildi Smith\',\r\n\'(.*) (.*) (.*)\', \'\\3, \\1 \\2\')\r\nFROM dual\r\nREGEXP_REPLACE(\'EL\r\n------------------\r\nSmith, Ellen Hildi\r\n\r\n该 SQL 语句显示了用圆括号括住的三个单独的子表达式。每一个单独的子表达式包含一个匹配元字符 (.)，并紧跟着 * 元字符，表示任何字符（除换行符之外）都必须匹配零次或更多次。空格将各个子表达式分开，空格也必须匹配。圆括号创建获取值的子表达式，并且可以用 \\digit 来引用。第一个子表达式被赋值为 \\1 ，第二个 \\2，以此类推。这些后向引用被用在这个函数的最后一个参数 (\\3, \\1 \\2) 中，这个函数有效地返回了替换子字符串，并按期望的格式来排列它们（包括逗号和空格）','OCP 047-002 REGEXP','','inherit','open','open','','192-revision-v1','','','2014-04-16 00:26:18','2014-04-15 16:26:18','',192,'http://localhost/wordpress/?p=223',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (225,1,'2014-05-14 23:07:02','2014-05-14 15:07:02','增量备份是针对于上一次备份（无论是哪种备份）：备份上一次备份后，所有发生变化的文件。\r\n（增量备份过程中，只备份有标记的选中的文件和文件夹，它清除标记，即：备份后标记文件，换言之，清除存档属性。）\r\n增量备份是指在一次全备份或上一次增量备份后，以后每次的备份只需备份与前一次相比增加或者被修改的文件。这就意味着，第一次增量备份的对象是进行全备后所产生的增加和修改的文件；第二次增量备份的对象是进行第一次增量备份后所产生的增加和修改的文件，如此类推。这种备份方式最显著的优点就是：没有重复的备份数据，因此备份的数据量不大，备份所需的时间很短。但增量备份的数据恢复是比较麻烦的。您必须具有上一次全备份和所有增量备份磁带（一旦丢失或损坏其中的一盘磁带，就会造成恢复的失败），并且它们必须沿着从全备份到依次增量备份的时间顺序逐个反推恢复，因此这就极大地延长了恢复时间。\r\n\r\n完全备份：备份全部选中的文件夹，并不依赖文件的存档属性来确定备份那些文件。（在备份过程中，任何现有的标记都被清除，每个文件都被标记为已备份，换言之，清除存档属性）。\r\n差异备份：差异备份是针对完全备份：备份上一次的完全备份后发生变化的所有文件。（差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，既：备份后不标记为已备份文件，换言之，不清除存档属性）说白了就是：差异将把前一次的数据都备份，一定要搞清是前一次的，另外他不管有没有打过标记他都备份，总之好恢复但太占空间。\r\n不同备份类型可以存在一定组合，下面的示例供您参考：\r\n完全备份和差异备份\r\n在星期一进行完全备份，在星期二至星期五进行差异备份。如果在星期五数据被破坏了，则你只需要还原星期一完全的备份和星期四的差异备份。这种策略备份数据需要较多的时间，但还原数据使用较少的时间。\r\n完全备份和增量备份\r\n在星期一进行完全备份，在星期二至星期五进行增量备份。如果在星期五数据被破坏了，则你需要还原星期一正常的备份和从星期二至星期五的所有增量备份。这种策略备份数据需要较少的时间，但还原数据使用较多的时间。\r\nOracle中，增量备份时分等级的，级别从0开始，一级一级递增，不过实际上用的最多的也就是0级和1级了，0级增量备份是后面级别的增量备份的 基础，0级备份实际上就是一个完全备份，与普通的完全备份唯一的不同点是0级备份可以作为其他级别增量备份的基础，而普通的完全备份是不能的。\r\n从级别1开始，Oracle的增量备份分为差异增量备份和积累增量备份两种，其中差异增量备份备份的是自上一次同级别的差异备份或者是上一次更高级 别的备份完成之后的数据库发生改变的数据块；而积累增量备份则是备份的自上一次上一级增量备份完成以来数据库发生改变的数据块。\r\n\r\n&nbsp;\r\n\r\n备注：\r\n\r\noracle 增量备份0级与全备份都是全备份,但是增量备份0级使用rman备份的话就只备份了used block,而全备份备份了used and unused block\r\n\r\n总结一下,二者有两个地方不同\r\n1\r\n全备份不能被用作1级增量备份的基础\r\n2\r\n使用rman备份的时候,全备份备份了used and unused block,0级使用rman备份的话就只备份了used block','OCP 052 备份与恢复','','publish','open','open','','ocp-052-%e5%a4%87%e4%bb%bd%e4%b8%8e%e6%81%a2%e5%a4%8d','','','2014-05-14 23:10:43','2014-05-14 15:10:43','',0,'http://localhost/wordpress/?p=225',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (226,1,'2014-05-14 23:07:02','2014-05-14 15:07:02','增量备份是针对于上一次备份（无论是哪种备份）：备份上一次备份后，所有发生变化的文件。\r\n（增量备份过程中，只备份有标记的选中的文件和文件夹，它清除标记，即：备份后标记文件，换言之，清除存档属性。）\r\n增量备份是指在一次全备份或上一次增量备份后，以后每次的备份只需备份与前一次相比增加或者被修改的文件。这就意味着，第一次增量备份的对象是进行全备后所产生的增加和修改的文件；第二次增量备份的对象是进行第一次增量备份后所产生的增加和修改的文件，如此类推。这种备份方式最显著的优点就是：没有重复的备份数据，因此备份的数据量不大，备份所需的时间很短。但增量备份的数据恢复是比较麻烦的。您必须具有上一次全备份和所有增量备份磁带（一旦丢失或损坏其中的一盘磁带，就会造成恢复的失败），并且它们必须沿着从全备份到依次增量备份的时间顺序逐个反推恢复，因此这就极大地延长了恢复时间。\r\n\r\n完全备份：备份全部选中的文件夹，并不依赖文件的存档属性来确定备份那些文件。（在备份过程中，任何现有的标记都被清除，每个文件都被标记为已备份，换言之，清除存档属性）。\r\n差异备份：差异备份是针对完全备份：备份上一次的完全备份后发生变化的所有文件。（差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，既：备份后不标记为已备份文件，换言之，不清除存档属性）说白了就是：差异将把前一次的数据都备份，一定要搞清是前一次的，另外他不管有没有打过标记他都备份，总之好恢复但太占空间。\r\n不同备份类型可以存在一定组合，下面的示例供您参考：\r\n完全备份和差异备份\r\n在星期一进行完全备份，在星期二至星期五进行差异备份。如果在星期五数据被破坏了，则你只需要还原星期一完全的备份和星期四的差异备份。这种策略备份数据需要较多的时间，但还原数据使用较少的时间。\r\n完全备份和增量备份\r\n在星期一进行完全备份，在星期二至星期五进行增量备份。如果在星期五数据被破坏了，则你需要还原星期一正常的备份和从星期二至星期五的所有增量备份。这种策略备份数据需要较少的时间，但还原数据使用较多的时间。\r\nOracle中，增量备份时分等级的，级别从0开始，一级一级递增，不过实际上用的最多的也就是0级和1级了，0级增量备份是后面级别的增量备份的 基础，0级备份实际上就是一个完全备份，与普通的完全备份唯一的不同点是0级备份可以作为其他级别增量备份的基础，而普通的完全备份是不能的。\r\n从级别1开始，Oracle的增量备份分为差异增量备份和积累增量备份两种，其中差异增量备份备份的是自上一次同级别的差异备份或者是上一次更高级 别的备份完成之后的数据库发生改变的数据块；而积累增量备份则是备份的自上一次上一级增量备份完成以来数据库发生改变的数据块。','OCP 052 备份与恢复','','inherit','open','open','','225-revision-v1','','','2014-05-14 23:07:02','2014-05-14 15:07:02','',225,'http://localhost/wordpress/?p=226',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (227,1,'2014-05-14 23:10:07','2014-05-14 15:10:07','增量备份是针对于上一次备份（无论是哪种备份）：备份上一次备份后，所有发生变化的文件。\n（增量备份过程中，只备份有标记的选中的文件和文件夹，它清除标记，即：备份后标记文件，换言之，清除存档属性。）\n增量备份是指在一次全备份或上一次增量备份后，以后每次的备份只需备份与前一次相比增加或者被修改的文件。这就意味着，第一次增量备份的对象是进行全备后所产生的增加和修改的文件；第二次增量备份的对象是进行第一次增量备份后所产生的增加和修改的文件，如此类推。这种备份方式最显著的优点就是：没有重复的备份数据，因此备份的数据量不大，备份所需的时间很短。但增量备份的数据恢复是比较麻烦的。您必须具有上一次全备份和所有增量备份磁带（一旦丢失或损坏其中的一盘磁带，就会造成恢复的失败），并且它们必须沿着从全备份到依次增量备份的时间顺序逐个反推恢复，因此这就极大地延长了恢复时间。\n\n完全备份：备份全部选中的文件夹，并不依赖文件的存档属性来确定备份那些文件。（在备份过程中，任何现有的标记都被清除，每个文件都被标记为已备份，换言之，清除存档属性）。\n差异备份：差异备份是针对完全备份：备份上一次的完全备份后发生变化的所有文件。（差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，既：备份后不标记为已备份文件，换言之，不清除存档属性）说白了就是：差异将把前一次的数据都备份，一定要搞清是前一次的，另外他不管有没有打过标记他都备份，总之好恢复但太占空间。\n不同备份类型可以存在一定组合，下面的示例供您参考：\n完全备份和差异备份\n在星期一进行完全备份，在星期二至星期五进行差异备份。如果在星期五数据被破坏了，则你只需要还原星期一完全的备份和星期四的差异备份。这种策略备份数据需要较多的时间，但还原数据使用较少的时间。\n完全备份和增量备份\n在星期一进行完全备份，在星期二至星期五进行增量备份。如果在星期五数据被破坏了，则你需要还原星期一正常的备份和从星期二至星期五的所有增量备份。这种策略备份数据需要较少的时间，但还原数据使用较多的时间。\nOracle中，增量备份时分等级的，级别从0开始，一级一级递增，不过实际上用的最多的也就是0级和1级了，0级增量备份是后面级别的增量备份的 基础，0级备份实际上就是一个完全备份，与普通的完全备份唯一的不同点是0级备份可以作为其他级别增量备份的基础，而普通的完全备份是不能的。\n从级别1开始，Oracle的增量备份分为差异增量备份和积累增量备份两种，其中差异增量备份备份的是自上一次同级别的差异备份或者是上一次更高级 别的备份完成之后的数据库发生改变的数据块；而积累增量备份则是备份的自上一次上一级增量备份完成以来数据库发生改变的数据块。\n\n&nbsp;\n\n备注：\n\noracle 增量备份0级与全备份都是全备份,但是增量备份0级使用rman备份的话就只备份了used block,而全备份备份了used and unused block\n\n总结一下,二者有两个地方不同\n1\n全备份不能被用作1级增量备份的基础\n2\n使用rman备份的时候,全备份备份了used and unused block,0级使用rman备份的话就只备份了used block','OCP 052 备份与恢复','','inherit','open','open','','225-autosave-v1','','','2014-05-14 23:10:07','2014-05-14 15:10:07','',225,'http://localhost/wordpress/?p=227',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (228,1,'2014-05-14 23:10:43','2014-05-14 15:10:43','增量备份是针对于上一次备份（无论是哪种备份）：备份上一次备份后，所有发生变化的文件。\r\n（增量备份过程中，只备份有标记的选中的文件和文件夹，它清除标记，即：备份后标记文件，换言之，清除存档属性。）\r\n增量备份是指在一次全备份或上一次增量备份后，以后每次的备份只需备份与前一次相比增加或者被修改的文件。这就意味着，第一次增量备份的对象是进行全备后所产生的增加和修改的文件；第二次增量备份的对象是进行第一次增量备份后所产生的增加和修改的文件，如此类推。这种备份方式最显著的优点就是：没有重复的备份数据，因此备份的数据量不大，备份所需的时间很短。但增量备份的数据恢复是比较麻烦的。您必须具有上一次全备份和所有增量备份磁带（一旦丢失或损坏其中的一盘磁带，就会造成恢复的失败），并且它们必须沿着从全备份到依次增量备份的时间顺序逐个反推恢复，因此这就极大地延长了恢复时间。\r\n\r\n完全备份：备份全部选中的文件夹，并不依赖文件的存档属性来确定备份那些文件。（在备份过程中，任何现有的标记都被清除，每个文件都被标记为已备份，换言之，清除存档属性）。\r\n差异备份：差异备份是针对完全备份：备份上一次的完全备份后发生变化的所有文件。（差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，既：备份后不标记为已备份文件，换言之，不清除存档属性）说白了就是：差异将把前一次的数据都备份，一定要搞清是前一次的，另外他不管有没有打过标记他都备份，总之好恢复但太占空间。\r\n不同备份类型可以存在一定组合，下面的示例供您参考：\r\n完全备份和差异备份\r\n在星期一进行完全备份，在星期二至星期五进行差异备份。如果在星期五数据被破坏了，则你只需要还原星期一完全的备份和星期四的差异备份。这种策略备份数据需要较多的时间，但还原数据使用较少的时间。\r\n完全备份和增量备份\r\n在星期一进行完全备份，在星期二至星期五进行增量备份。如果在星期五数据被破坏了，则你需要还原星期一正常的备份和从星期二至星期五的所有增量备份。这种策略备份数据需要较少的时间，但还原数据使用较多的时间。\r\nOracle中，增量备份时分等级的，级别从0开始，一级一级递增，不过实际上用的最多的也就是0级和1级了，0级增量备份是后面级别的增量备份的 基础，0级备份实际上就是一个完全备份，与普通的完全备份唯一的不同点是0级备份可以作为其他级别增量备份的基础，而普通的完全备份是不能的。\r\n从级别1开始，Oracle的增量备份分为差异增量备份和积累增量备份两种，其中差异增量备份备份的是自上一次同级别的差异备份或者是上一次更高级 别的备份完成之后的数据库发生改变的数据块；而积累增量备份则是备份的自上一次上一级增量备份完成以来数据库发生改变的数据块。\r\n\r\n&nbsp;\r\n\r\n备注：\r\n\r\noracle 增量备份0级与全备份都是全备份,但是增量备份0级使用rman备份的话就只备份了used block,而全备份备份了used and unused block\r\n\r\n总结一下,二者有两个地方不同\r\n1\r\n全备份不能被用作1级增量备份的基础\r\n2\r\n使用rman备份的时候,全备份备份了used and unused block,0级使用rman备份的话就只备份了used block','OCP 052 备份与恢复','','inherit','open','open','','225-revision-v1','','','2014-05-14 23:10:43','2014-05-14 15:10:43','',225,'http://localhost/wordpress/?p=228',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (229,1,'2014-05-15 01:03:10','2014-05-14 17:03:10','Auto Memory Management是Oracle10g提出来的一个新特性，在最新的Oracle11g数据库中又得到了进一步的发展。通过使用自动内存管理，Oracle数据库中的PGA和SGA内存之间可以互相转换，根据当前的工作负载来自动设定Oracle内存区域中的PGA和SGA的大小。这种间接的内存转换依赖于操作系统的共享内存的释放机制来获得内部实例的调优。目前这种技术可以应用于Linux, Solaris, HPUX, AIX 和Windows等操作系统上。\r\n\r\n首先我们来回顾下Oracle10g的自动内存管理特性。在Oracle10g的数据库中，只有SHARED_POOL_SIZE、DB_CACHE_SIZE、LARGE_POOL_SIZE、JAVA_POOL_SIZE、STREAMS_POOL_SIZE五个SGA组件可以被自动调整，其中PGA的最大值由初始化参数PGA_AGGREGATE_TARGET决定，SGA的最大值由初始化参数SGA_TARGET决定。\r\n\r\n在Oracle11g数据库中，使用自动内存管理特性不再需要设定参数PGA_AGGREGATE_TARGET和SGA_TARGET，因为这两个参数都已经被修改成自动调优的，除非想指定PGA和SGA的最小值才需要设定这两个参数。在Oracle11g数据库中，则需要设置一个叫做MEMORY_TARGET的初始化参数，这个参数是指整个Oracle实例所能使用的内存大小，包括PGA和SGA的整体大小，在MEMORY_TARGET的内存大小之内，PGA和SGA所用的内存可以根据当前负载情况自动相互转换。如果当初始设定的MEMORY_TARGET的内存不够当前数据库使用的时候，Oracle11g还提供了另外一个初始化参数MEMORY_MAX_TARGET，当原始设定的内存不够使用的时候，可以手工来动态 调节MEMORY_TARGET的大小，但是不允许超过MEMORY_MAX_TARGET的值。','OCP 052 AMM 自动内存管理','','publish','open','open','','ocp-052-amm-%e8%87%aa%e5%8a%a8%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86','','','2014-05-15 01:11:01','2014-05-14 17:11:01','',0,'http://localhost/wordpress/?p=229',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (230,1,'2014-05-15 01:03:10','2014-05-14 17:03:10','Auto Memory Management是Oracle10g提出来的一个新特性，在最新的Oracle11g数据库中又得到了进一步的发展。通过使用自动内存管理，Oracle数据库中的PGA和SGA内存之间可以互相转换，根据当前的工作负载来自动设定Oracle内存区域中的PGA和SGA的大小。这种间接的内存转换依赖于操作系统的共享内存的释放机制来获得内部实例的调优。目前这种技术可以应用于Linux, Solaris, HPUX, AIX 和Windows等操作系统上。\r\n\r\n首先我们来回顾下Oracle10g的自动内存管理特性。在Oracle10g的数据库中，只有SHARED_POOL_SIZE、DB_CACHE_SIZE、LARGE_POOL_SIZE、JAVA_POOL_SIZE、STREAMS_POOL_SIZE五个SGA组件可以被自动调整，其中PGA的最大值由初始化参数PGA_AGGREGATE_TARGET决定，SGA的最大值由初始化参数SGA_TARGET决定。\r\n\r\n在Oracle11g数据库中，使用自动内存管理特性不再需要设定参数PGA_AGGREGATE_TARGET和SGA_TARGET，因为这两个参数都已经被修改成自动调优的，除非想指定PGA和SGA的最小值才需要设定这两个参数。在Oracle11g数据库中，则需要设置一个叫做MEMORY_TARGET的初始化参数，这个参数是指整个Oracle实例所能使用的内存大小，包括PGA和SGA的整体大小，在MEMORY_TARGET的内存大小之内，PGA和SGA所用的内存可以根据当前负载情况自动相互转换。如果当初始设定的MEMORY_TARGET的内存不够当前数据库使用的时候，Oracle11g还提供了另外一个初始化参数MEMORY_MAX_TARGET，当原始设定的内存不够使用的时候，可以手工来动态 调节MEMORY_TARGET的大小，但是不允许超过MEMORY_MAX_TARGET的值。','OCP 052 AMM 自动内存管理','','inherit','open','open','','229-revision-v1','','','2014-05-15 01:03:10','2014-05-14 17:03:10','',229,'http://localhost/wordpress/?p=230',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (231,1,'2014-05-15 01:56:57','2014-05-14 17:56:57','1、block：是Oracle中存储数据块的最小单位，所以数据最终都是存储在block中。它也被称为逻辑blocks或是页（pages）。每个操作系统都有自己的block size。而这里的block是Oracle自己的，不同于OS的blocks。可以通过设置DB_BLOCK_SIZE设置Oracle的block为OS的block的几倍，从而减少不必要的I/O。不管block中存放的数据是表、索引还是cluster data，block的结构都是一致：\r\n@ block header: 这里主要存储一些数据块的基本信息，如数据块地址，块类型(table data, index等)，以及一些事务信息。为了加强理解，我们dump一下block看看：\r\nSQL&gt; select dbms_rowid.rowid_relative_fno(rowid) as fno, dbms_rowid.rowid_block_number(rowid) from t1 where b=1;\r\nFNO DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)\r\n———- ————————————\r\n4 388\r\nSQL&gt; alter system dump datafile 4 block 388;\r\n在dump file中，我们看到\r\nBlock header dump: 0×01000184\r\nObject id on Block? Y\r\nseg/obj: 0xcd17 csc: 0×00.8d80b itc: 2 flg: E typ: 1 – DATA\r\nbrn: 0 bdba: 0×1000181 ver: 0×01 opc: 0\r\ninc: 0 exflg: 0\r\n# 以下是一些比较重要的事务信息，每当一个事务开始时，都要获得一个ITL entry， 否则将会出现ITL 等待。\r\nItl Xid Uba Flag Lck Scn/Fsc\r\n0×01 0×0002.005.0000010b 0×00800024.0128.32 –U- 66 fsc 0×0000.0008d8f3\r\n0×02 0×0000.000.00000000 0×00000000.0000.00 —- 0 fsc 0×0000.00000000\r\ndata_block_dump,data header at 0xceb6864\r\n@ table directory 记录该块中 table rows 的信息，如下所示：\r\n===============\r\ntsiz: 0×1f98\r\nhsiz: 0×96\r\npbl: 0×0ceb6864\r\nbdba: 0×01000184\r\n76543210\r\nflag=——–\r\nntab=1 // no. of tables, 除了cluster 以外，一般情况都为一\r\nnrow=66 // 该block 上 rows 的数目\r\nfrre=-1\r\nfsbo=0×96\r\nfseo=0×402\r\navsp=0×36c\r\ntosp=0×36c\r\n@ row directroy 记录该块中记录的每一条记录的地址信息。如下所示：\r\n0×12:pri[0] offs=0×402\r\n0×14:pri[1] offs=0×46d\r\n0×16:pri[2] offs=0×4d8\r\n…\r\n…\r\n0×92:pri[64] offs=0×1ec2\r\n0×94:pri[65] offs=0×1f2d\r\n最终的记录条数应该和table directory 中的nrows相等。这部分空间一旦被分配，将不可能收回，只能在有新行insert时被重用。\r\n** overhead：在block中，上述的header、table directory和row directory被合称为overhead。\r\n@ row data 记录表中的实际数据。\r\n@ free space 该部分主要用于update，insert等操作。 同时ITL entry 也可以在该部分获得。\r\n附注：\r\n## 在data block中的free space的使用与优化：当数据被delete或update时，可能引起block产生free space对此：①如果有insert语句与相应释放block space的语句在同一个transaction中，则insert可以使用刚刚释放的block space；②如果insert语句与相应的释放block space的语句不在同一个transaction中，则释放的block space只有在事务被commit之后才能被使用。Oracle当发生以下两种情况会进行free space的合并：insert或update操作视图使用一个有足够free space的block；free space存在大量碎片，无法进行数据的insert等。\r\n## row的链接与迁移：当一条记录row的数据太大时，可能无法放在一个block中，这种情况下Oracle往往会使用chain（链接）的方法；此外，当one row被update后，数据量增大，当前的block已经不能完全容纳时，Oracle会把该row数据整个迁移（migrates）到其他的数据块中，但在原来row的位置上保存一个指针，链接到新的地址上，大量的迁移、链接将会降低DB的I/O性能。\r\n\r\n2、extent：extent 是每次分配给一个对象的逻辑最小单位，是由一定数量连续的block组成。一个或多个extent又组成了一个segment。\r\n@ Extent的分配：对于本地管理表空间，DB会先确定能够分配extent的候选datafile，随后查询该datafile的bitmap，确定是否有所需大小的连续空闲blocks，直到找到满足的datafile。如果使用dictionary managed tablespace，则是去查询数据字典，而不是datafile头部的bitmap信息。另外，由于某些原因，如果想手工非配extent时，可以使用alter table table_name allocate extent。\r\n@ Extent的收回： 当一个extent被分配给了某个object，除非这个obj被drop，否则extent将不会被其他obj所使用。除非 trauncate … drop storage.或者alter table … dealocate unused.（以上两种方法都不适用于index）。另外，对于rollback segments，如果指定了optimal参数，oracle会自己dealocate一些extent。\r\n在dictionary managed tablespace中，如果所请求的ext 大于各个free extents 大小，这是oracle将聚合临近的extent，形成一个更大的extent。在local managed tablespace中，则无此限制。 一旦extent 被分配和回收，相应的文件头bitmap或者数据字典都会被更新。\r\n\r\n3、segment：它是extents的集合，它包含了在表空间中所包含的具体逻辑存储机构的所有extents。例如一个未分区的table，index, cluster被成为一个段，一个被分区的index，table的一个partition 被成为一个段。对于temporary segment，主要用于排序等操作，只有当DB的内存无法存放相应的排序操作并无法找到其他更好的解决办法时，才会在临时表空间中创建temporary segment。以下语句都可能要创建temporary segment。\r\nCREATE INDEX\r\nSELECT ... ORDER BY\r\nSELECT DISTINCT ...\r\nSELECT ... GROUP BY\r\nSELECT . . . UNION\r\nSELECT ... INTERSECT\r\nSELECT ... MINUS\r\n\r\n&nbsp;\r\n\r\n补充：\r\n\r\n数据文件和日志文件是数据库中最重要的文件。它们是数据存储的地方。每个数据库至少有一个与之相关的数据文件，通常情况下不只一个，有很多。数据在数据文件中是如何组织的？要了解这些内容我们首先必须理解什么是表空间（tablespace）、段（segment）、区（extent）、块（block），这些都是oracle数据库在数据文件中组织数据的基本单元。现在我们来理解这些概念。\r\n块是数据存储的物理单位，也是数据文件中最基础的单位，数据直接存储在块上。是oracle空间分配的最小单位。oracle中的块大小常见的有三种，2KB、4KB、8KB。块的大小在数据库创建时就已经固定下来，数据库中每个块的大小都是相同的，而且所有的块都有相同的格式，由“块头＋表目录＋行目录＋空闲空间＋数据空间”组成。块头包含着块类型（比如是表块、还是索引块）的信息、磁盘上块的位置等信息。表目录（table directory），如果有的话，包含着此块中存储各行的表的信息（如果一个块中存有多个表中的数据）。行目录（row directory）包含着数据行的描述信息，它是一个指针数组，指示了每一行在数据块中的物理位置。块头、表目录、行目录统称为块开销（block overhead），是oracle原来统计、管理块本身的。剩下的两部分很简单，已经存有数据的就是数据空间，暂时没存的就是空闲空间。\r\n区又叫盘区，是数据文件中一个连续的分配空间，它比块要大，由块组成。有些对象分配空间时可能至少需要两个盘区，比如回滚段，而这两个盘区不一定要求相连。区的大小从一个块到2GB不等\r\n段是oracle数据库中的分配单位，对象如表、索引等都是以段为单位进行分配。当创建一个表时将创建一个表段，创建一个索引时就创建一个索引段。每一个消耗存储空间的对象最终被存储到一个单一的段中。有回滚段、临时段、聚簇段、索引段等。\r\n表空间是一个逻辑容器，它和数据文件关联起来，一个表空间至少有一个数据文件与之关联。一个表空间可以有多个段，一个段只能属于一个表空间。\r\n方案（schema）又叫模式，是比表空间小一级的逻辑概念，它也是一个逻辑容器。多个用户可能共用一个表空间，那如何区分开每一个用户？那么在表空间中对每个用户都有一个对应的方案，用于保存单个用户的信息。\r\noracle中存储的层次结构总结如下：\r\n一、数据库由一个或多个表空间组成\r\n二、表空间由一个或多个数据文件组成，一个表空间包含多个段\r\n三、段由一个或多个区组成\r\n四、区是数据文件中一个连续的分配空间，由一个或多个块组成\r\n五、块是数据库中最小、最基本的单位，是数据库使用的最小的I/O单元\r\n六、每个用户都有一个对应的方案','Oracle中block、extent、segment tablespace的关系','','publish','open','open','','oracle%e4%b8%adblock%e3%80%81extent%e3%80%81segment%e7%9a%84%e5%85%b3%e7%b3%bb','','','2014-05-15 02:05:16','2014-05-14 18:05:16','',0,'http://localhost/wordpress/?p=231',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (232,1,'2014-05-15 01:56:57','2014-05-14 17:56:57','1、block：是Oracle中存储数据块的最小单位，所以数据最终都是存储在block中。它也被称为逻辑blocks或是页（pages）。每个操作系统都有自己的block size。而这里的block是Oracle自己的，不同于OS的blocks。可以通过设置DB_BLOCK_SIZE设置Oracle的block为OS的block的几倍，从而减少不必要的I/O。不管block中存放的数据是表、索引还是cluster data，block的结构都是一致：\r\n@ block header: 这里主要存储一些数据块的基本信息，如数据块地址，块类型(table data, index等)，以及一些事务信息。为了加强理解，我们dump一下block看看：\r\nSQL&gt; select dbms_rowid.rowid_relative_fno(rowid) as fno, dbms_rowid.rowid_block_number(rowid) from t1 where b=1;\r\nFNO DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)\r\n———- ————————————\r\n4 388\r\nSQL&gt; alter system dump datafile 4 block 388;\r\n在dump file中，我们看到\r\nBlock header dump: 0×01000184\r\nObject id on Block? Y\r\nseg/obj: 0xcd17 csc: 0×00.8d80b itc: 2 flg: E typ: 1 – DATA\r\nbrn: 0 bdba: 0×1000181 ver: 0×01 opc: 0\r\ninc: 0 exflg: 0\r\n# 以下是一些比较重要的事务信息，每当一个事务开始时，都要获得一个ITL entry， 否则将会出现ITL 等待。\r\nItl Xid Uba Flag Lck Scn/Fsc\r\n0×01 0×0002.005.0000010b 0×00800024.0128.32 –U- 66 fsc 0×0000.0008d8f3\r\n0×02 0×0000.000.00000000 0×00000000.0000.00 —- 0 fsc 0×0000.00000000\r\ndata_block_dump,data header at 0xceb6864\r\n@ table directory 记录该块中 table rows 的信息，如下所示：\r\n===============\r\ntsiz: 0×1f98\r\nhsiz: 0×96\r\npbl: 0×0ceb6864\r\nbdba: 0×01000184\r\n76543210\r\nflag=——–\r\nntab=1 // no. of tables, 除了cluster 以外，一般情况都为一\r\nnrow=66 // 该block 上 rows 的数目\r\nfrre=-1\r\nfsbo=0×96\r\nfseo=0×402\r\navsp=0×36c\r\ntosp=0×36c\r\n@ row directroy 记录该块中记录的每一条记录的地址信息。如下所示：\r\n0×12:pri[0] offs=0×402\r\n0×14:pri[1] offs=0×46d\r\n0×16:pri[2] offs=0×4d8\r\n…\r\n…\r\n0×92:pri[64] offs=0×1ec2\r\n0×94:pri[65] offs=0×1f2d\r\n最终的记录条数应该和table directory 中的nrows相等。这部分空间一旦被分配，将不可能收回，只能在有新行insert时被重用。\r\n** overhead：在block中，上述的header、table directory和row directory被合称为overhead。\r\n@ row data 记录表中的实际数据。\r\n@ free space 该部分主要用于update，insert等操作。 同时ITL entry 也可以在该部分获得。\r\n附注：\r\n## 在data block中的free space的使用与优化：当数据被delete或update时，可能引起block产生free space对此：①如果有insert语句与相应释放block space的语句在同一个transaction中，则insert可以使用刚刚释放的block space；②如果insert语句与相应的释放block space的语句不在同一个transaction中，则释放的block space只有在事务被commit之后才能被使用。Oracle当发生以下两种情况会进行free space的合并：insert或update操作视图使用一个有足够free space的block；free space存在大量碎片，无法进行数据的insert等。\r\n## row的链接与迁移：当一条记录row的数据太大时，可能无法放在一个block中，这种情况下Oracle往往会使用chain（链接）的方法；此外，当one row被update后，数据量增大，当前的block已经不能完全容纳时，Oracle会把该row数据整个迁移（migrates）到其他的数据块中，但在原来row的位置上保存一个指针，链接到新的地址上，大量的迁移、链接将会降低DB的I/O性能。\r\n\r\n2、extent：extent 是每次分配给一个对象的逻辑最小单位，是由一定数量连续的block组成。一个或多个extent又组成了一个segment。\r\n@ Extent的分配：对于本地管理表空间，DB会先确定能够分配extent的候选datafile，随后查询该datafile的bitmap，确定是否有所需大小的连续空闲blocks，直到找到满足的datafile。如果使用dictionary managed tablespace，则是去查询数据字典，而不是datafile头部的bitmap信息。另外，由于某些原因，如果想手工非配extent时，可以使用alter table table_name allocate extent。\r\n@ Extent的收回： 当一个extent被分配给了某个object，除非这个obj被drop，否则extent将不会被其他obj所使用。除非 trauncate … drop storage.或者alter table … dealocate unused.（以上两种方法都不适用于index）。另外，对于rollback segments，如果指定了optimal参数，oracle会自己dealocate一些extent。\r\n在dictionary managed tablespace中，如果所请求的ext 大于各个free extents 大小，这是oracle将聚合临近的extent，形成一个更大的extent。在local managed tablespace中，则无此限制。 一旦extent 被分配和回收，相应的文件头bitmap或者数据字典都会被更新。\r\n\r\n3、segment：它是extents的集合，它包含了在表空间中所包含的具体逻辑存储机构的所有extents。例如一个未分区的table，index, cluster被成为一个段，一个被分区的index，table的一个partition 被成为一个段。对于temporary segment，主要用于排序等操作，只有当DB的内存无法存放相应的排序操作并无法找到其他更好的解决办法时，才会在临时表空间中创建temporary segment。以下语句都可能要创建temporary segment。\r\nCREATE INDEX\r\nSELECT ... ORDER BY\r\nSELECT DISTINCT ...\r\nSELECT ... GROUP BY\r\nSELECT . . . UNION\r\nSELECT ... INTERSECT\r\nSELECT ... MINUS','Oracle中block、extent、segment的关系','','inherit','open','open','','231-revision-v1','','','2014-05-15 01:56:57','2014-05-14 17:56:57','',231,'http://localhost/wordpress/?p=232',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (233,1,'2014-05-15 02:05:02','2014-05-14 18:05:02','1、block：是Oracle中存储数据块的最小单位，所以数据最终都是存储在block中。它也被称为逻辑blocks或是页（pages）。每个操作系统都有自己的block size。而这里的block是Oracle自己的，不同于OS的blocks。可以通过设置DB_BLOCK_SIZE设置Oracle的block为OS的block的几倍，从而减少不必要的I/O。不管block中存放的数据是表、索引还是cluster data，block的结构都是一致：\n@ block header: 这里主要存储一些数据块的基本信息，如数据块地址，块类型(table data, index等)，以及一些事务信息。为了加强理解，我们dump一下block看看：\nSQL&gt; select dbms_rowid.rowid_relative_fno(rowid) as fno, dbms_rowid.rowid_block_number(rowid) from t1 where b=1;\nFNO DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)\n———- ————————————\n4 388\nSQL&gt; alter system dump datafile 4 block 388;\n在dump file中，我们看到\nBlock header dump: 0×01000184\nObject id on Block? Y\nseg/obj: 0xcd17 csc: 0×00.8d80b itc: 2 flg: E typ: 1 – DATA\nbrn: 0 bdba: 0×1000181 ver: 0×01 opc: 0\ninc: 0 exflg: 0\n# 以下是一些比较重要的事务信息，每当一个事务开始时，都要获得一个ITL entry， 否则将会出现ITL 等待。\nItl Xid Uba Flag Lck Scn/Fsc\n0×01 0×0002.005.0000010b 0×00800024.0128.32 –U- 66 fsc 0×0000.0008d8f3\n0×02 0×0000.000.00000000 0×00000000.0000.00 —- 0 fsc 0×0000.00000000\ndata_block_dump,data header at 0xceb6864\n@ table directory 记录该块中 table rows 的信息，如下所示：\n===============\ntsiz: 0×1f98\nhsiz: 0×96\npbl: 0×0ceb6864\nbdba: 0×01000184\n76543210\nflag=——–\nntab=1 // no. of tables, 除了cluster 以外，一般情况都为一\nnrow=66 // 该block 上 rows 的数目\nfrre=-1\nfsbo=0×96\nfseo=0×402\navsp=0×36c\ntosp=0×36c\n@ row directroy 记录该块中记录的每一条记录的地址信息。如下所示：\n0×12:pri[0] offs=0×402\n0×14:pri[1] offs=0×46d\n0×16:pri[2] offs=0×4d8\n…\n…\n0×92:pri[64] offs=0×1ec2\n0×94:pri[65] offs=0×1f2d\n最终的记录条数应该和table directory 中的nrows相等。这部分空间一旦被分配，将不可能收回，只能在有新行insert时被重用。\n** overhead：在block中，上述的header、table directory和row directory被合称为overhead。\n@ row data 记录表中的实际数据。\n@ free space 该部分主要用于update，insert等操作。 同时ITL entry 也可以在该部分获得。\n附注：\n## 在data block中的free space的使用与优化：当数据被delete或update时，可能引起block产生free space对此：①如果有insert语句与相应释放block space的语句在同一个transaction中，则insert可以使用刚刚释放的block space；②如果insert语句与相应的释放block space的语句不在同一个transaction中，则释放的block space只有在事务被commit之后才能被使用。Oracle当发生以下两种情况会进行free space的合并：insert或update操作视图使用一个有足够free space的block；free space存在大量碎片，无法进行数据的insert等。\n## row的链接与迁移：当一条记录row的数据太大时，可能无法放在一个block中，这种情况下Oracle往往会使用chain（链接）的方法；此外，当one row被update后，数据量增大，当前的block已经不能完全容纳时，Oracle会把该row数据整个迁移（migrates）到其他的数据块中，但在原来row的位置上保存一个指针，链接到新的地址上，大量的迁移、链接将会降低DB的I/O性能。\n\n2、extent：extent 是每次分配给一个对象的逻辑最小单位，是由一定数量连续的block组成。一个或多个extent又组成了一个segment。\n@ Extent的分配：对于本地管理表空间，DB会先确定能够分配extent的候选datafile，随后查询该datafile的bitmap，确定是否有所需大小的连续空闲blocks，直到找到满足的datafile。如果使用dictionary managed tablespace，则是去查询数据字典，而不是datafile头部的bitmap信息。另外，由于某些原因，如果想手工非配extent时，可以使用alter table table_name allocate extent。\n@ Extent的收回： 当一个extent被分配给了某个object，除非这个obj被drop，否则extent将不会被其他obj所使用。除非 trauncate … drop storage.或者alter table … dealocate unused.（以上两种方法都不适用于index）。另外，对于rollback segments，如果指定了optimal参数，oracle会自己dealocate一些extent。\n在dictionary managed tablespace中，如果所请求的ext 大于各个free extents 大小，这是oracle将聚合临近的extent，形成一个更大的extent。在local managed tablespace中，则无此限制。 一旦extent 被分配和回收，相应的文件头bitmap或者数据字典都会被更新。\n\n3、segment：它是extents的集合，它包含了在表空间中所包含的具体逻辑存储机构的所有extents。例如一个未分区的table，index, cluster被成为一个段，一个被分区的index，table的一个partition 被成为一个段。对于temporary segment，主要用于排序等操作，只有当DB的内存无法存放相应的排序操作并无法找到其他更好的解决办法时，才会在临时表空间中创建temporary segment。以下语句都可能要创建temporary segment。\nCREATE INDEX\nSELECT ... ORDER BY\nSELECT DISTINCT ...\nSELECT ... GROUP BY\nSELECT . . . UNION\nSELECT ... INTERSECT\nSELECT ... MINUS\n\n&nbsp;\n\n补充：\n\n数据文件和日志文件是数据库中最重要的文件。它们是数据存储的地方。每个数据库至少有一个与之相关的数据文件，通常情况下不只一个，有很多。数据在数据文件中是如何组织的？要了解这些内容我们首先必须理解什么是表空间（tablespace）、段（segment）、区（extent）、块（block），这些都是oracle数据库在数据文件中组织数据的基本单元。现在我们来理解这些概念。\n块是数据存储的物理单位，也是数据文件中最基础的单位，数据直接存储在块上。是oracle空间分配的最小单位。oracle中的块大小常见的有三种，2KB、4KB、8KB。块的大小在数据库创建时就已经固定下来，数据库中每个块的大小都是相同的，而且所有的块都有相同的格式，由“块头＋表目录＋行目录＋空闲空间＋数据空间”组成。块头包含着块类型（比如是表块、还是索引块）的信息、磁盘上块的位置等信息。表目录（table directory），如果有的话，包含着此块中存储各行的表的信息（如果一个块中存有多个表中的数据）。行目录（row directory）包含着数据行的描述信息，它是一个指针数组，指示了每一行在数据块中的物理位置。块头、表目录、行目录统称为块开销（block overhead），是oracle原来统计、管理块本身的。剩下的两部分很简单，已经存有数据的就是数据空间，暂时没存的就是空闲空间。\n区又叫盘区，是数据文件中一个连续的分配空间，它比块要大，由块组成。有些对象分配空间时可能至少需要两个盘区，比如回滚段，而这两个盘区不一定要求相连。区的大小从一个块到2GB不等\n段是oracle数据库中的分配单位，对象如表、索引等都是以段为单位进行分配。当创建一个表时将创建一个表段，创建一个索引时就创建一个索引段。每一个消耗存储空间的对象最终被存储到一个单一的段中。有回滚段、临时段、聚簇段、索引段等。\n表空间是一个逻辑容器，它和数据文件关联起来，一个表空间至少有一个数据文件与之关联。一个表空间可以有多个段，一个段只能属于一个表空间。\n方案（schema）又叫模式，是比表空间小一级的逻辑概念，它也是一个逻辑容器。多个用户可能共用一个表空间，那如何区分开每一个用户？那么在表空间中对每个用户都有一个对应的方案，用于保存单个用户的信息。\noracle中存储的层次结构总结如下：\n一、数据库由一个或多个表空间组成\n二、表空间由一个或多个数据文件组成，一个表空间包含多个段\n三、段由一个或多个区组成\n四、区是数据文件中一个连续的分配空间，由一个或多个块组成\n五、块是数据库中最小、最基本的单位，是数据库使用的最小的I/O单元\n六、每个用户都有一个对应的方案','Oracle中block、extent、segment table的关系','','inherit','open','open','','231-autosave-v1','','','2014-05-15 02:05:02','2014-05-14 18:05:02','',231,'http://localhost/wordpress/?p=233',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (234,1,'2014-05-15 02:05:16','2014-05-14 18:05:16','1、block：是Oracle中存储数据块的最小单位，所以数据最终都是存储在block中。它也被称为逻辑blocks或是页（pages）。每个操作系统都有自己的block size。而这里的block是Oracle自己的，不同于OS的blocks。可以通过设置DB_BLOCK_SIZE设置Oracle的block为OS的block的几倍，从而减少不必要的I/O。不管block中存放的数据是表、索引还是cluster data，block的结构都是一致：\r\n@ block header: 这里主要存储一些数据块的基本信息，如数据块地址，块类型(table data, index等)，以及一些事务信息。为了加强理解，我们dump一下block看看：\r\nSQL&gt; select dbms_rowid.rowid_relative_fno(rowid) as fno, dbms_rowid.rowid_block_number(rowid) from t1 where b=1;\r\nFNO DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)\r\n———- ————————————\r\n4 388\r\nSQL&gt; alter system dump datafile 4 block 388;\r\n在dump file中，我们看到\r\nBlock header dump: 0×01000184\r\nObject id on Block? Y\r\nseg/obj: 0xcd17 csc: 0×00.8d80b itc: 2 flg: E typ: 1 – DATA\r\nbrn: 0 bdba: 0×1000181 ver: 0×01 opc: 0\r\ninc: 0 exflg: 0\r\n# 以下是一些比较重要的事务信息，每当一个事务开始时，都要获得一个ITL entry， 否则将会出现ITL 等待。\r\nItl Xid Uba Flag Lck Scn/Fsc\r\n0×01 0×0002.005.0000010b 0×00800024.0128.32 –U- 66 fsc 0×0000.0008d8f3\r\n0×02 0×0000.000.00000000 0×00000000.0000.00 —- 0 fsc 0×0000.00000000\r\ndata_block_dump,data header at 0xceb6864\r\n@ table directory 记录该块中 table rows 的信息，如下所示：\r\n===============\r\ntsiz: 0×1f98\r\nhsiz: 0×96\r\npbl: 0×0ceb6864\r\nbdba: 0×01000184\r\n76543210\r\nflag=——–\r\nntab=1 // no. of tables, 除了cluster 以外，一般情况都为一\r\nnrow=66 // 该block 上 rows 的数目\r\nfrre=-1\r\nfsbo=0×96\r\nfseo=0×402\r\navsp=0×36c\r\ntosp=0×36c\r\n@ row directroy 记录该块中记录的每一条记录的地址信息。如下所示：\r\n0×12:pri[0] offs=0×402\r\n0×14:pri[1] offs=0×46d\r\n0×16:pri[2] offs=0×4d8\r\n…\r\n…\r\n0×92:pri[64] offs=0×1ec2\r\n0×94:pri[65] offs=0×1f2d\r\n最终的记录条数应该和table directory 中的nrows相等。这部分空间一旦被分配，将不可能收回，只能在有新行insert时被重用。\r\n** overhead：在block中，上述的header、table directory和row directory被合称为overhead。\r\n@ row data 记录表中的实际数据。\r\n@ free space 该部分主要用于update，insert等操作。 同时ITL entry 也可以在该部分获得。\r\n附注：\r\n## 在data block中的free space的使用与优化：当数据被delete或update时，可能引起block产生free space对此：①如果有insert语句与相应释放block space的语句在同一个transaction中，则insert可以使用刚刚释放的block space；②如果insert语句与相应的释放block space的语句不在同一个transaction中，则释放的block space只有在事务被commit之后才能被使用。Oracle当发生以下两种情况会进行free space的合并：insert或update操作视图使用一个有足够free space的block；free space存在大量碎片，无法进行数据的insert等。\r\n## row的链接与迁移：当一条记录row的数据太大时，可能无法放在一个block中，这种情况下Oracle往往会使用chain（链接）的方法；此外，当one row被update后，数据量增大，当前的block已经不能完全容纳时，Oracle会把该row数据整个迁移（migrates）到其他的数据块中，但在原来row的位置上保存一个指针，链接到新的地址上，大量的迁移、链接将会降低DB的I/O性能。\r\n\r\n2、extent：extent 是每次分配给一个对象的逻辑最小单位，是由一定数量连续的block组成。一个或多个extent又组成了一个segment。\r\n@ Extent的分配：对于本地管理表空间，DB会先确定能够分配extent的候选datafile，随后查询该datafile的bitmap，确定是否有所需大小的连续空闲blocks，直到找到满足的datafile。如果使用dictionary managed tablespace，则是去查询数据字典，而不是datafile头部的bitmap信息。另外，由于某些原因，如果想手工非配extent时，可以使用alter table table_name allocate extent。\r\n@ Extent的收回： 当一个extent被分配给了某个object，除非这个obj被drop，否则extent将不会被其他obj所使用。除非 trauncate … drop storage.或者alter table … dealocate unused.（以上两种方法都不适用于index）。另外，对于rollback segments，如果指定了optimal参数，oracle会自己dealocate一些extent。\r\n在dictionary managed tablespace中，如果所请求的ext 大于各个free extents 大小，这是oracle将聚合临近的extent，形成一个更大的extent。在local managed tablespace中，则无此限制。 一旦extent 被分配和回收，相应的文件头bitmap或者数据字典都会被更新。\r\n\r\n3、segment：它是extents的集合，它包含了在表空间中所包含的具体逻辑存储机构的所有extents。例如一个未分区的table，index, cluster被成为一个段，一个被分区的index，table的一个partition 被成为一个段。对于temporary segment，主要用于排序等操作，只有当DB的内存无法存放相应的排序操作并无法找到其他更好的解决办法时，才会在临时表空间中创建temporary segment。以下语句都可能要创建temporary segment。\r\nCREATE INDEX\r\nSELECT ... ORDER BY\r\nSELECT DISTINCT ...\r\nSELECT ... GROUP BY\r\nSELECT . . . UNION\r\nSELECT ... INTERSECT\r\nSELECT ... MINUS\r\n\r\n&nbsp;\r\n\r\n补充：\r\n\r\n数据文件和日志文件是数据库中最重要的文件。它们是数据存储的地方。每个数据库至少有一个与之相关的数据文件，通常情况下不只一个，有很多。数据在数据文件中是如何组织的？要了解这些内容我们首先必须理解什么是表空间（tablespace）、段（segment）、区（extent）、块（block），这些都是oracle数据库在数据文件中组织数据的基本单元。现在我们来理解这些概念。\r\n块是数据存储的物理单位，也是数据文件中最基础的单位，数据直接存储在块上。是oracle空间分配的最小单位。oracle中的块大小常见的有三种，2KB、4KB、8KB。块的大小在数据库创建时就已经固定下来，数据库中每个块的大小都是相同的，而且所有的块都有相同的格式，由“块头＋表目录＋行目录＋空闲空间＋数据空间”组成。块头包含着块类型（比如是表块、还是索引块）的信息、磁盘上块的位置等信息。表目录（table directory），如果有的话，包含着此块中存储各行的表的信息（如果一个块中存有多个表中的数据）。行目录（row directory）包含着数据行的描述信息，它是一个指针数组，指示了每一行在数据块中的物理位置。块头、表目录、行目录统称为块开销（block overhead），是oracle原来统计、管理块本身的。剩下的两部分很简单，已经存有数据的就是数据空间，暂时没存的就是空闲空间。\r\n区又叫盘区，是数据文件中一个连续的分配空间，它比块要大，由块组成。有些对象分配空间时可能至少需要两个盘区，比如回滚段，而这两个盘区不一定要求相连。区的大小从一个块到2GB不等\r\n段是oracle数据库中的分配单位，对象如表、索引等都是以段为单位进行分配。当创建一个表时将创建一个表段，创建一个索引时就创建一个索引段。每一个消耗存储空间的对象最终被存储到一个单一的段中。有回滚段、临时段、聚簇段、索引段等。\r\n表空间是一个逻辑容器，它和数据文件关联起来，一个表空间至少有一个数据文件与之关联。一个表空间可以有多个段，一个段只能属于一个表空间。\r\n方案（schema）又叫模式，是比表空间小一级的逻辑概念，它也是一个逻辑容器。多个用户可能共用一个表空间，那如何区分开每一个用户？那么在表空间中对每个用户都有一个对应的方案，用于保存单个用户的信息。\r\noracle中存储的层次结构总结如下：\r\n一、数据库由一个或多个表空间组成\r\n二、表空间由一个或多个数据文件组成，一个表空间包含多个段\r\n三、段由一个或多个区组成\r\n四、区是数据文件中一个连续的分配空间，由一个或多个块组成\r\n五、块是数据库中最小、最基本的单位，是数据库使用的最小的I/O单元\r\n六、每个用户都有一个对应的方案','Oracle中block、extent、segment tablespace的关系','','inherit','open','open','','231-revision-v1','','','2014-05-15 02:05:16','2014-05-14 18:05:16','',231,'http://localhost/wordpress/?p=234',0,'revision','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (236,1,'2015-01-22 15:00:59','2015-01-22 07:00:59','密就在于Oracle 使用的事务机制.只要你修改数锁. Oraeleat会在两个不\r\n间位置创建记录条目(大多J!l其他数据库可能会把两个条自放在网一个位寝.对于这些数据库. undo\r\ni和1 rc归只是\"事务I!t馆\"1 . 甲个条自放在重傲日志中. 0\"\"，10 会在这里存储足够的f商品在来黛徽或\"前\r\nìM\" 事务.对于捅‘人，这个条n 就是摇入的行.对于删除.则是一个消息{晏删除文件X、抉飞行\r\n捕Z 中的行).谕如此类. 另『个条因是徽销条目，写31-个undo 段. 如果事务失败，稽\'哥撇销， Oracle\r\n将从undo 段中读取\"前峡像\"并恢复数据.除丁使111这个uodo 段数据撤销事务外， Oracle 还会用它\r\n撇销该数据块时对块作出的改变，也就是说会把块恢复到查询开始时的状态. 这样-来，你就能够通\r\n过-个锁正确地读取徽撞击.不仅可以得到正确一兹的答案.也不会锁定任何敛揣.','Oracle的读一致性及多版本控制','','publish','open','open','','oracle%e7%9a%84%e8%af%bb%e4%b8%80%e8%87%b4%e6%80%a7%e5%8f%8a%e5%a4%9a%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6','','','2015-01-22 15:00:59','2015-01-22 07:00:59','',0,'http://localhost/wordpress/?p=236',0,'post','',0);
insert  into `wp_posts`(`ID`,`post_author`,`post_date`,`post_date_gmt`,`post_content`,`post_title`,`post_excerpt`,`post_status`,`comment_status`,`ping_status`,`post_password`,`post_name`,`to_ping`,`pinged`,`post_modified`,`post_modified_gmt`,`post_content_filtered`,`post_parent`,`guid`,`menu_order`,`post_type`,`post_mime_type`,`comment_count`) values (237,1,'2015-01-22 15:00:59','2015-01-22 07:00:59','密就在于Oracle 使用的事务机制.只要你修改数锁. Oraeleat会在两个不\r\n间位置创建记录条目(大多J!l其他数据库可能会把两个条自放在网一个位寝.对于这些数据库. undo\r\ni和1 rc归只是\"事务I!t馆\"1 . 甲个条自放在重傲日志中. 0\"\"，10 会在这里存储足够的f商品在来黛徽或\"前\r\nìM\" 事务.对于捅‘人，这个条n 就是摇入的行.对于删除.则是一个消息{晏删除文件X、抉飞行\r\n捕Z 中的行).谕如此类. 另『个条因是徽销条目，写31-个undo 段. 如果事务失败，稽\'哥撇销， Oracle\r\n将从undo 段中读取\"前峡像\"并恢复数据.除丁使111这个uodo 段数据撤销事务外， Oracle 还会用它\r\n撇销该数据块时对块作出的改变，也就是说会把块恢复到查询开始时的状态. 这样-来，你就能够通\r\n过-个锁正确地读取徽撞击.不仅可以得到正确一兹的答案.也不会锁定任何敛揣.','Oracle的读一致性及多版本控制','','inherit','open','open','','236-revision-v1','','','2015-01-22 15:00:59','2015-01-22 07:00:59','',236,'http://localhost/wordpress/?p=237',0,'revision','',0);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
